<p>pandas是本书后续内容的首选库。它含有使数据清洗和分析工作变得更快更简单的数据结构和操作工具。pandas经常和其它工具一同使用，如数值计算工具NumPy和SciPy，分析库statsmodels和scikit-learn，和数据可视化库matplotlib。pandas是基于NumPy数组构建的，特别是基于数组的函数和不使用for循环的数据处理。</p>
<p>虽然pandas采用了大量的NumPy编码风格，但二者最大的不同是pandas是专门为处理表格和混杂数据设计的。而NumPy更适合处理统一的数值数组数据。</p>
<p>自从2010年pandas开源以来，pandas逐渐成长为一个非常大的库，应用于许多真实案例。开发者社区已经有了800个独立的贡献者，他们在解决日常数据问题的同时为这个项目提供贡献。</p>
<p>在本书后续部分中，我将使用下面这样的pandas引入约定：</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1"></a>In [<span class="dv">1</span>]: <span class="im">import</span> pandas <span class="im">as</span> pd</span></code></pre></div>
<p>因此，只要你在代码中看到pd.，就得想到这是pandas。因为Series和DataFrame用的次数非常多，所以将其引入本地命名空间中会更方便：</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1"></a>In [<span class="dv">2</span>]: <span class="im">from</span> pandas <span class="im">import</span> Series, DataFrame</span></code></pre></div>
<h1 id="pandas的数据结构介绍">5.1 pandas的数据结构介绍</h1>
<p>要使用pandas，你首先就得熟悉它的两个主要数据结构：Series和DataFrame。虽然它们并不能解决所有问题，但它们为大多数应用提供了一种可靠的、易于使用的基础。</p>
<h2 id="series">Series</h2>
<p>Series是一种类似于一维数组的对象，它由一组数据（各种NumPy数据类型）以及一组与之相关的数据标签（即索引）组成。仅由一组数据即可产生最简单的Series：</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1"></a>In [<span class="dv">11</span>]: obj <span class="op">=</span> pd.Series([<span class="dv">4</span>, <span class="dv">7</span>, <span class="op">-</span><span class="dv">5</span>, <span class="dv">3</span>])</span>
<span id="cb3-2"><a href="#cb3-2"></a></span>
<span id="cb3-3"><a href="#cb3-3"></a>In [<span class="dv">12</span>]: obj</span>
<span id="cb3-4"><a href="#cb3-4"></a>Out[<span class="dv">12</span>]: </span>
<span id="cb3-5"><a href="#cb3-5"></a><span class="dv">0</span>    <span class="dv">4</span></span>
<span id="cb3-6"><a href="#cb3-6"></a><span class="dv">1</span>    <span class="dv">7</span></span>
<span id="cb3-7"><a href="#cb3-7"></a><span class="dv">2</span>   <span class="op">-</span><span class="dv">5</span></span>
<span id="cb3-8"><a href="#cb3-8"></a><span class="dv">3</span>    <span class="dv">3</span></span>
<span id="cb3-9"><a href="#cb3-9"></a>dtype: int64</span></code></pre></div>
<p>Series的字符串表现形式为：索引在左边，值在右边。由于我们没有为数据指定索引，于是会自动创建一个0到N-1（N为数据的长度）的整数型索引。你可以通过Series 的values和index属性获取其数组表示形式和索引对象：</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1"></a>In [<span class="dv">13</span>]: obj.values</span>
<span id="cb4-2"><a href="#cb4-2"></a>Out[<span class="dv">13</span>]: array([ <span class="dv">4</span>,  <span class="dv">7</span>, <span class="op">-</span><span class="dv">5</span>,  <span class="dv">3</span>])</span>
<span id="cb4-3"><a href="#cb4-3"></a></span>
<span id="cb4-4"><a href="#cb4-4"></a>In [<span class="dv">14</span>]: obj.index  <span class="co"># like range(4)</span></span>
<span id="cb4-5"><a href="#cb4-5"></a>Out[<span class="dv">14</span>]: RangeIndex(start<span class="op">=</span><span class="dv">0</span>, stop<span class="op">=</span><span class="dv">4</span>, step<span class="op">=</span><span class="dv">1</span>)</span></code></pre></div>
<p>通常，我们希望所创建的Series带有一个可以对各个数据点进行标记的索引：</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb5-1"><a href="#cb5-1"></a>In [<span class="dv">15</span>]: obj2 <span class="op">=</span> pd.Series([<span class="dv">4</span>, <span class="dv">7</span>, <span class="op">-</span><span class="dv">5</span>, <span class="dv">3</span>], index<span class="op">=</span>[<span class="st">&#39;d&#39;</span>, <span class="st">&#39;b&#39;</span>, <span class="st">&#39;a&#39;</span>, <span class="st">&#39;c&#39;</span>])</span>
<span id="cb5-2"><a href="#cb5-2"></a></span>
<span id="cb5-3"><a href="#cb5-3"></a>In [<span class="dv">16</span>]: obj2</span>
<span id="cb5-4"><a href="#cb5-4"></a>Out[<span class="dv">16</span>]: </span>
<span id="cb5-5"><a href="#cb5-5"></a>d    <span class="dv">4</span></span>
<span id="cb5-6"><a href="#cb5-6"></a>b    <span class="dv">7</span></span>
<span id="cb5-7"><a href="#cb5-7"></a>a   <span class="op">-</span><span class="dv">5</span></span>
<span id="cb5-8"><a href="#cb5-8"></a>c    <span class="dv">3</span></span>
<span id="cb5-9"><a href="#cb5-9"></a>dtype: int64</span>
<span id="cb5-10"><a href="#cb5-10"></a></span>
<span id="cb5-11"><a href="#cb5-11"></a>In [<span class="dv">17</span>]: obj2.index</span>
<span id="cb5-12"><a href="#cb5-12"></a>Out[<span class="dv">17</span>]: Index([<span class="st">&#39;d&#39;</span>, <span class="st">&#39;b&#39;</span>, <span class="st">&#39;a&#39;</span>, <span class="st">&#39;c&#39;</span>], dtype<span class="op">=</span><span class="st">&#39;object&#39;</span>)</span></code></pre></div>
<p>与普通NumPy数组相比，你可以通过索引的方式选取Series中的单个或一组值：</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb6-1"><a href="#cb6-1"></a>In [<span class="dv">18</span>]: obj2[<span class="st">&#39;a&#39;</span>]</span>
<span id="cb6-2"><a href="#cb6-2"></a>Out[<span class="dv">18</span>]: <span class="op">-</span><span class="dv">5</span></span>
<span id="cb6-3"><a href="#cb6-3"></a></span>
<span id="cb6-4"><a href="#cb6-4"></a>In [<span class="dv">19</span>]: obj2[<span class="st">&#39;d&#39;</span>] <span class="op">=</span> <span class="dv">6</span></span>
<span id="cb6-5"><a href="#cb6-5"></a></span>
<span id="cb6-6"><a href="#cb6-6"></a>In [<span class="dv">20</span>]: obj2[[<span class="st">&#39;c&#39;</span>, <span class="st">&#39;a&#39;</span>, <span class="st">&#39;d&#39;</span>]]</span>
<span id="cb6-7"><a href="#cb6-7"></a>Out[<span class="dv">20</span>]: </span>
<span id="cb6-8"><a href="#cb6-8"></a>c    <span class="dv">3</span></span>
<span id="cb6-9"><a href="#cb6-9"></a>a   <span class="op">-</span><span class="dv">5</span></span>
<span id="cb6-10"><a href="#cb6-10"></a>d    <span class="dv">6</span></span>
<span id="cb6-11"><a href="#cb6-11"></a>dtype: int64</span></code></pre></div>
<p>[‘c’, ‘a’, ‘d’]是索引列表，即使它包含的是字符串而不是整数。</p>
<p>使用NumPy函数或类似NumPy的运算（如根据布尔型数组进行过滤、标量乘法、应用数学函数等）都会保留索引值的链接：</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb7-1"><a href="#cb7-1"></a>In [<span class="dv">21</span>]: obj2[obj2 <span class="op">&gt;</span> <span class="dv">0</span>]</span>
<span id="cb7-2"><a href="#cb7-2"></a>Out[<span class="dv">21</span>]: </span>
<span id="cb7-3"><a href="#cb7-3"></a>d    <span class="dv">6</span></span>
<span id="cb7-4"><a href="#cb7-4"></a>b    <span class="dv">7</span></span>
<span id="cb7-5"><a href="#cb7-5"></a>c    <span class="dv">3</span></span>
<span id="cb7-6"><a href="#cb7-6"></a>dtype: int64</span>
<span id="cb7-7"><a href="#cb7-7"></a></span>
<span id="cb7-8"><a href="#cb7-8"></a>In [<span class="dv">22</span>]: obj2 <span class="op">*</span> <span class="dv">2</span></span>
<span id="cb7-9"><a href="#cb7-9"></a>Out[<span class="dv">22</span>]:</span>
<span id="cb7-10"><a href="#cb7-10"></a>d    <span class="dv">12</span></span>
<span id="cb7-11"><a href="#cb7-11"></a>b    <span class="dv">14</span></span>
<span id="cb7-12"><a href="#cb7-12"></a>a   <span class="op">-</span><span class="dv">10</span></span>
<span id="cb7-13"><a href="#cb7-13"></a>c     <span class="dv">6</span></span>
<span id="cb7-14"><a href="#cb7-14"></a>dtype: int64</span>
<span id="cb7-15"><a href="#cb7-15"></a></span>
<span id="cb7-16"><a href="#cb7-16"></a>In [<span class="dv">23</span>]: np.exp(obj2)</span>
<span id="cb7-17"><a href="#cb7-17"></a>Out[<span class="dv">23</span>]: </span>
<span id="cb7-18"><a href="#cb7-18"></a>d     <span class="fl">403.428793</span></span>
<span id="cb7-19"><a href="#cb7-19"></a>b    <span class="fl">1096.633158</span></span>
<span id="cb7-20"><a href="#cb7-20"></a>a       <span class="fl">0.006738</span></span>
<span id="cb7-21"><a href="#cb7-21"></a>c      <span class="fl">20.085537</span></span>
<span id="cb7-22"><a href="#cb7-22"></a>dtype: float64</span></code></pre></div>
<p>还可以将Series看成是一个定长的有序字典，因为它是索引值到数据值的一个映射。它可以用在许多原本需要字典参数的函数中：</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb8-1"><a href="#cb8-1"></a>In [<span class="dv">24</span>]: <span class="st">&#39;b&#39;</span> <span class="kw">in</span> obj2</span>
<span id="cb8-2"><a href="#cb8-2"></a>Out[<span class="dv">24</span>]: <span class="va">True</span></span>
<span id="cb8-3"><a href="#cb8-3"></a></span>
<span id="cb8-4"><a href="#cb8-4"></a>In [<span class="dv">25</span>]: <span class="st">&#39;e&#39;</span> <span class="kw">in</span> obj2</span>
<span id="cb8-5"><a href="#cb8-5"></a>Out[<span class="dv">25</span>]: <span class="va">False</span></span></code></pre></div>
<p>如果数据被存放在一个Python字典中，也可以直接通过这个字典来创建Series：</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb9-1"><a href="#cb9-1"></a>In [<span class="dv">26</span>]: sdata <span class="op">=</span> {<span class="st">&#39;Ohio&#39;</span>: <span class="dv">35000</span>, <span class="st">&#39;Texas&#39;</span>: <span class="dv">71000</span>, <span class="st">&#39;Oregon&#39;</span>: <span class="dv">16000</span>, <span class="st">&#39;Utah&#39;</span>: <span class="dv">5000</span>}</span>
<span id="cb9-2"><a href="#cb9-2"></a></span>
<span id="cb9-3"><a href="#cb9-3"></a>In [<span class="dv">27</span>]: obj3 <span class="op">=</span> pd.Series(sdata)</span>
<span id="cb9-4"><a href="#cb9-4"></a></span>
<span id="cb9-5"><a href="#cb9-5"></a>In [<span class="dv">28</span>]: obj3</span>
<span id="cb9-6"><a href="#cb9-6"></a>Out[<span class="dv">28</span>]: </span>
<span id="cb9-7"><a href="#cb9-7"></a>Ohio      <span class="dv">35000</span></span>
<span id="cb9-8"><a href="#cb9-8"></a>Oregon    <span class="dv">16000</span></span>
<span id="cb9-9"><a href="#cb9-9"></a>Texas     <span class="dv">71000</span></span>
<span id="cb9-10"><a href="#cb9-10"></a>Utah       <span class="dv">5000</span></span>
<span id="cb9-11"><a href="#cb9-11"></a>dtype: int64</span></code></pre></div>
<p>如果只传入一个字典，则结果Series中的索引就是原字典的键（有序排列）。你可以传入排好序的字典的键以改变顺序：</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb10-1"><a href="#cb10-1"></a>In [<span class="dv">29</span>]: states <span class="op">=</span> [<span class="st">&#39;California&#39;</span>, <span class="st">&#39;Ohio&#39;</span>, <span class="st">&#39;Oregon&#39;</span>, <span class="st">&#39;Texas&#39;</span>]</span>
<span id="cb10-2"><a href="#cb10-2"></a></span>
<span id="cb10-3"><a href="#cb10-3"></a>In [<span class="dv">30</span>]: obj4 <span class="op">=</span> pd.Series(sdata, index<span class="op">=</span>states)</span>
<span id="cb10-4"><a href="#cb10-4"></a></span>
<span id="cb10-5"><a href="#cb10-5"></a>In [<span class="dv">31</span>]: obj4</span>
<span id="cb10-6"><a href="#cb10-6"></a>Out[<span class="dv">31</span>]: </span>
<span id="cb10-7"><a href="#cb10-7"></a>California        NaN</span>
<span id="cb10-8"><a href="#cb10-8"></a>Ohio          <span class="fl">35000.0</span></span>
<span id="cb10-9"><a href="#cb10-9"></a>Oregon        <span class="fl">16000.0</span></span>
<span id="cb10-10"><a href="#cb10-10"></a>Texas         <span class="fl">71000.0</span></span>
<span id="cb10-11"><a href="#cb10-11"></a>dtype: float64</span></code></pre></div>
<p>在这个例子中，sdata中跟states索引相匹配的那3个值会被找出来并放到相应的位置上，但由于“California”所对应的sdata值找不到，所以其结果就为NaN（即“非数字”（not a number），在pandas中，它用于表示缺失或NA值）。因为‘Utah’不在states中，它被从结果中除去。</p>
<p>我将使用缺失（missing）或NA表示缺失数据。pandas的isnull和notnull函数可用于检测缺失数据：</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb11-1"><a href="#cb11-1"></a>In [<span class="dv">32</span>]: pd.isnull(obj4)</span>
<span id="cb11-2"><a href="#cb11-2"></a>Out[<span class="dv">32</span>]: </span>
<span id="cb11-3"><a href="#cb11-3"></a>California     <span class="va">True</span></span>
<span id="cb11-4"><a href="#cb11-4"></a>Ohio          <span class="va">False</span></span>
<span id="cb11-5"><a href="#cb11-5"></a>Oregon        <span class="va">False</span></span>
<span id="cb11-6"><a href="#cb11-6"></a>Texas         <span class="va">False</span></span>
<span id="cb11-7"><a href="#cb11-7"></a>dtype: <span class="bu">bool</span></span>
<span id="cb11-8"><a href="#cb11-8"></a></span>
<span id="cb11-9"><a href="#cb11-9"></a>In [<span class="dv">33</span>]: pd.notnull(obj4)</span>
<span id="cb11-10"><a href="#cb11-10"></a>Out[<span class="dv">33</span>]: </span>
<span id="cb11-11"><a href="#cb11-11"></a>California    <span class="va">False</span></span>
<span id="cb11-12"><a href="#cb11-12"></a>Ohio           <span class="va">True</span></span>
<span id="cb11-13"><a href="#cb11-13"></a>Oregon         <span class="va">True</span></span>
<span id="cb11-14"><a href="#cb11-14"></a>Texas          <span class="va">True</span></span>
<span id="cb11-15"><a href="#cb11-15"></a>dtype: <span class="bu">bool</span></span></code></pre></div>
<p>Series也有类似的实例方法：</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb12-1"><a href="#cb12-1"></a>In [<span class="dv">34</span>]: obj4.isnull()</span>
<span id="cb12-2"><a href="#cb12-2"></a>Out[<span class="dv">34</span>]: </span>
<span id="cb12-3"><a href="#cb12-3"></a>California     <span class="va">True</span></span>
<span id="cb12-4"><a href="#cb12-4"></a>Ohio          <span class="va">False</span></span>
<span id="cb12-5"><a href="#cb12-5"></a>Oregon        <span class="va">False</span></span>
<span id="cb12-6"><a href="#cb12-6"></a>Texas         <span class="va">False</span></span>
<span id="cb12-7"><a href="#cb12-7"></a>dtype: <span class="bu">bool</span></span></code></pre></div>
<p>我将在第7章详细讲解如何处理缺失数据。</p>
<p>对于许多应用而言，Series最重要的一个功能是，它会根据运算的索引标签自动对齐数据：</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb13-1"><a href="#cb13-1"></a>In [<span class="dv">35</span>]: obj3</span>
<span id="cb13-2"><a href="#cb13-2"></a>Out[<span class="dv">35</span>]: </span>
<span id="cb13-3"><a href="#cb13-3"></a>Ohio      <span class="dv">35000</span></span>
<span id="cb13-4"><a href="#cb13-4"></a>Oregon    <span class="dv">16000</span></span>
<span id="cb13-5"><a href="#cb13-5"></a>Texas     <span class="dv">71000</span></span>
<span id="cb13-6"><a href="#cb13-6"></a>Utah       <span class="dv">5000</span></span>
<span id="cb13-7"><a href="#cb13-7"></a>dtype: int64</span>
<span id="cb13-8"><a href="#cb13-8"></a></span>
<span id="cb13-9"><a href="#cb13-9"></a>In [<span class="dv">36</span>]: obj4</span>
<span id="cb13-10"><a href="#cb13-10"></a>Out[<span class="dv">36</span>]: </span>
<span id="cb13-11"><a href="#cb13-11"></a>California        NaN</span>
<span id="cb13-12"><a href="#cb13-12"></a>Ohio          <span class="fl">35000.0</span></span>
<span id="cb13-13"><a href="#cb13-13"></a>Oregon        <span class="fl">16000.0</span></span>
<span id="cb13-14"><a href="#cb13-14"></a>Texas         <span class="fl">71000.0</span></span>
<span id="cb13-15"><a href="#cb13-15"></a>dtype: float64</span>
<span id="cb13-16"><a href="#cb13-16"></a></span>
<span id="cb13-17"><a href="#cb13-17"></a>In [<span class="dv">37</span>]: obj3 <span class="op">+</span> obj4</span>
<span id="cb13-18"><a href="#cb13-18"></a>Out[<span class="dv">37</span>]: </span>
<span id="cb13-19"><a href="#cb13-19"></a>California         NaN</span>
<span id="cb13-20"><a href="#cb13-20"></a>Ohio           <span class="fl">70000.0</span></span>
<span id="cb13-21"><a href="#cb13-21"></a>Oregon         <span class="fl">32000.0</span></span>
<span id="cb13-22"><a href="#cb13-22"></a>Texas         <span class="fl">142000.0</span></span>
<span id="cb13-23"><a href="#cb13-23"></a>Utah               NaN</span>
<span id="cb13-24"><a href="#cb13-24"></a>dtype: float64</span></code></pre></div>
<p>数据对齐功能将在后面详细讲解。如果你使用过数据库，你可以认为是类似join的操作。</p>
<p>Series对象本身及其索引都有一个name属性，该属性跟pandas其他的关键功能关系非常密切：</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb14-1"><a href="#cb14-1"></a>In [<span class="dv">38</span>]: obj4.name <span class="op">=</span> <span class="st">&#39;population&#39;</span></span>
<span id="cb14-2"><a href="#cb14-2"></a></span>
<span id="cb14-3"><a href="#cb14-3"></a>In [<span class="dv">39</span>]: obj4.index.name <span class="op">=</span> <span class="st">&#39;state&#39;</span></span>
<span id="cb14-4"><a href="#cb14-4"></a></span>
<span id="cb14-5"><a href="#cb14-5"></a>In [<span class="dv">40</span>]: obj4</span>
<span id="cb14-6"><a href="#cb14-6"></a>Out[<span class="dv">40</span>]: </span>
<span id="cb14-7"><a href="#cb14-7"></a>state</span>
<span id="cb14-8"><a href="#cb14-8"></a>California        NaN</span>
<span id="cb14-9"><a href="#cb14-9"></a>Ohio          <span class="fl">35000.0</span></span>
<span id="cb14-10"><a href="#cb14-10"></a>Oregon        <span class="fl">16000.0</span></span>
<span id="cb14-11"><a href="#cb14-11"></a>Texas         <span class="fl">71000.0</span></span>
<span id="cb14-12"><a href="#cb14-12"></a>Name: population, dtype: float64</span></code></pre></div>
<p>Series的索引可以通过赋值的方式就地修改：</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb15-1"><a href="#cb15-1"></a>In [<span class="dv">41</span>]: obj</span>
<span id="cb15-2"><a href="#cb15-2"></a>Out[<span class="dv">41</span>]: </span>
<span id="cb15-3"><a href="#cb15-3"></a><span class="dv">0</span>    <span class="dv">4</span></span>
<span id="cb15-4"><a href="#cb15-4"></a><span class="dv">1</span>    <span class="dv">7</span></span>
<span id="cb15-5"><a href="#cb15-5"></a><span class="dv">2</span>   <span class="op">-</span><span class="dv">5</span></span>
<span id="cb15-6"><a href="#cb15-6"></a><span class="dv">3</span>    <span class="dv">3</span></span>
<span id="cb15-7"><a href="#cb15-7"></a>dtype: int64</span>
<span id="cb15-8"><a href="#cb15-8"></a></span>
<span id="cb15-9"><a href="#cb15-9"></a>In [<span class="dv">42</span>]: obj.index <span class="op">=</span> [<span class="st">&#39;Bob&#39;</span>, <span class="st">&#39;Steve&#39;</span>, <span class="st">&#39;Jeff&#39;</span>, <span class="st">&#39;Ryan&#39;</span>]</span>
<span id="cb15-10"><a href="#cb15-10"></a></span>
<span id="cb15-11"><a href="#cb15-11"></a>In [<span class="dv">43</span>]: obj</span>
<span id="cb15-12"><a href="#cb15-12"></a>Out[<span class="dv">43</span>]: </span>
<span id="cb15-13"><a href="#cb15-13"></a>Bob      <span class="dv">4</span></span>
<span id="cb15-14"><a href="#cb15-14"></a>Steve    <span class="dv">7</span></span>
<span id="cb15-15"><a href="#cb15-15"></a>Jeff    <span class="op">-</span><span class="dv">5</span></span>
<span id="cb15-16"><a href="#cb15-16"></a>Ryan     <span class="dv">3</span></span>
<span id="cb15-17"><a href="#cb15-17"></a>dtype: int64</span></code></pre></div>
<h2 id="dataframe">DataFrame</h2>
<p>DataFrame是一个表格型的数据结构，它含有一组有序的列，每列可以是不同的值类型（数值、字符串、布尔值等）。DataFrame既有行索引也有列索引，它可以被看做由Series组成的字典（共用同一个索引）。DataFrame中的数据是以一个或多个二维块存放的（而不是列表、字典或别的一维数据结构）。有关DataFrame内部的技术细节远远超出了本书所讨论的范围。</p>
<blockquote>
<p>笔记：虽然DataFrame是以二维结构保存数据的，但你仍然可以轻松地将其表示为更高维度的数据（层次化索引的表格型结构，这是pandas中许多高级数据处理功能的关键要素，我们会在第8章讨论这个问题）。</p>
</blockquote>
<p>建DataFrame的办法有很多，最常用的一种是直接传入一个由等长列表或NumPy数组组成的字典：</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb16-1"><a href="#cb16-1"></a>data <span class="op">=</span> {<span class="st">&#39;state&#39;</span>: [<span class="st">&#39;Ohio&#39;</span>, <span class="st">&#39;Ohio&#39;</span>, <span class="st">&#39;Ohio&#39;</span>, <span class="st">&#39;Nevada&#39;</span>, <span class="st">&#39;Nevada&#39;</span>, <span class="st">&#39;Nevada&#39;</span>],</span>
<span id="cb16-2"><a href="#cb16-2"></a>        <span class="st">&#39;year&#39;</span>: [<span class="dv">2000</span>, <span class="dv">2001</span>, <span class="dv">2002</span>, <span class="dv">2001</span>, <span class="dv">2002</span>, <span class="dv">2003</span>],</span>
<span id="cb16-3"><a href="#cb16-3"></a>        <span class="st">&#39;pop&#39;</span>: [<span class="fl">1.5</span>, <span class="fl">1.7</span>, <span class="fl">3.6</span>, <span class="fl">2.4</span>, <span class="fl">2.9</span>, <span class="fl">3.2</span>]}</span>
<span id="cb16-4"><a href="#cb16-4"></a>frame <span class="op">=</span> pd.DataFrame(data)</span></code></pre></div>
<p>结果DataFrame会自动加上索引（跟Series一样），且全部列会被有序排列：</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb17-1"><a href="#cb17-1"></a>In [<span class="dv">45</span>]: frame</span>
<span id="cb17-2"><a href="#cb17-2"></a>Out[<span class="dv">45</span>]: </span>
<span id="cb17-3"><a href="#cb17-3"></a>   pop   state  year</span>
<span id="cb17-4"><a href="#cb17-4"></a><span class="dv">0</span>  <span class="fl">1.5</span>    Ohio  <span class="dv">2000</span></span>
<span id="cb17-5"><a href="#cb17-5"></a><span class="dv">1</span>  <span class="fl">1.7</span>    Ohio  <span class="dv">2001</span></span>
<span id="cb17-6"><a href="#cb17-6"></a><span class="dv">2</span>  <span class="fl">3.6</span>    Ohio  <span class="dv">2002</span></span>
<span id="cb17-7"><a href="#cb17-7"></a><span class="dv">3</span>  <span class="fl">2.4</span>  Nevada  <span class="dv">2001</span></span>
<span id="cb17-8"><a href="#cb17-8"></a><span class="dv">4</span>  <span class="fl">2.9</span>  Nevada  <span class="dv">2002</span></span>
<span id="cb17-9"><a href="#cb17-9"></a><span class="dv">5</span>  <span class="fl">3.2</span>  Nevada  <span class="dv">2003</span></span></code></pre></div>
<p>如果你使用的是Jupyter notebook，pandas DataFrame对象会以对浏览器友好的HTML表格的方式呈现。</p>
<p>对于特别大的DataFrame，head方法会选取前五行：</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb18-1"><a href="#cb18-1"></a>In [<span class="dv">46</span>]: frame.head()</span>
<span id="cb18-2"><a href="#cb18-2"></a>Out[<span class="dv">46</span>]: </span>
<span id="cb18-3"><a href="#cb18-3"></a>   pop   state  year</span>
<span id="cb18-4"><a href="#cb18-4"></a><span class="dv">0</span>  <span class="fl">1.5</span>    Ohio  <span class="dv">2000</span></span>
<span id="cb18-5"><a href="#cb18-5"></a><span class="dv">1</span>  <span class="fl">1.7</span>    Ohio  <span class="dv">2001</span></span>
<span id="cb18-6"><a href="#cb18-6"></a><span class="dv">2</span>  <span class="fl">3.6</span>    Ohio  <span class="dv">2002</span></span>
<span id="cb18-7"><a href="#cb18-7"></a><span class="dv">3</span>  <span class="fl">2.4</span>  Nevada  <span class="dv">2001</span></span>
<span id="cb18-8"><a href="#cb18-8"></a><span class="dv">4</span>  <span class="fl">2.9</span>  Nevada  <span class="dv">2002</span></span></code></pre></div>
<p>如果指定了列序列，则DataFrame的列就会按照指定顺序进行排列：</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb19-1"><a href="#cb19-1"></a>In [<span class="dv">47</span>]: pd.DataFrame(data, columns<span class="op">=</span>[<span class="st">&#39;year&#39;</span>, <span class="st">&#39;state&#39;</span>, <span class="st">&#39;pop&#39;</span>])</span>
<span id="cb19-2"><a href="#cb19-2"></a>Out[<span class="dv">47</span>]: </span>
<span id="cb19-3"><a href="#cb19-3"></a>   year   state  pop</span>
<span id="cb19-4"><a href="#cb19-4"></a><span class="dv">0</span>  <span class="dv">2000</span>    Ohio  <span class="fl">1.5</span></span>
<span id="cb19-5"><a href="#cb19-5"></a><span class="dv">1</span>  <span class="dv">2001</span>    Ohio  <span class="fl">1.7</span></span>
<span id="cb19-6"><a href="#cb19-6"></a><span class="dv">2</span>  <span class="dv">2002</span>    Ohio  <span class="fl">3.6</span></span>
<span id="cb19-7"><a href="#cb19-7"></a><span class="dv">3</span>  <span class="dv">2001</span>  Nevada  <span class="fl">2.4</span></span>
<span id="cb19-8"><a href="#cb19-8"></a><span class="dv">4</span>  <span class="dv">2002</span>  Nevada  <span class="fl">2.9</span></span>
<span id="cb19-9"><a href="#cb19-9"></a><span class="dv">5</span>  <span class="dv">2003</span>  Nevada  <span class="fl">3.2</span></span></code></pre></div>
<p>如果传入的列在数据中找不到，就会在结果中产生缺失值：</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb20-1"><a href="#cb20-1"></a>In [<span class="dv">48</span>]: frame2 <span class="op">=</span> pd.DataFrame(data, columns<span class="op">=</span>[<span class="st">&#39;year&#39;</span>, <span class="st">&#39;state&#39;</span>, <span class="st">&#39;pop&#39;</span>, <span class="st">&#39;debt&#39;</span>],</span>
<span id="cb20-2"><a href="#cb20-2"></a>   ....:                       index<span class="op">=</span>[<span class="st">&#39;one&#39;</span>, <span class="st">&#39;two&#39;</span>, <span class="st">&#39;three&#39;</span>, <span class="st">&#39;four&#39;</span>,</span>
<span id="cb20-3"><a href="#cb20-3"></a>   ....:                              <span class="st">&#39;five&#39;</span>, <span class="st">&#39;six&#39;</span>])</span>
<span id="cb20-4"><a href="#cb20-4"></a></span>
<span id="cb20-5"><a href="#cb20-5"></a>In [<span class="dv">49</span>]: frame2</span>
<span id="cb20-6"><a href="#cb20-6"></a>Out[<span class="dv">49</span>]: </span>
<span id="cb20-7"><a href="#cb20-7"></a>       year   state  pop debt</span>
<span id="cb20-8"><a href="#cb20-8"></a>one    <span class="dv">2000</span>    Ohio  <span class="fl">1.5</span>  NaN</span>
<span id="cb20-9"><a href="#cb20-9"></a>two    <span class="dv">2001</span>    Ohio  <span class="fl">1.7</span>  NaN</span>
<span id="cb20-10"><a href="#cb20-10"></a>three  <span class="dv">2002</span>    Ohio  <span class="fl">3.6</span>  NaN</span>
<span id="cb20-11"><a href="#cb20-11"></a>four   <span class="dv">2001</span>  Nevada  <span class="fl">2.4</span>  NaN</span>
<span id="cb20-12"><a href="#cb20-12"></a>five   <span class="dv">2002</span>  Nevada  <span class="fl">2.9</span>  NaN</span>
<span id="cb20-13"><a href="#cb20-13"></a>six    <span class="dv">2003</span>  Nevada  <span class="fl">3.2</span>  NaN</span>
<span id="cb20-14"><a href="#cb20-14"></a></span>
<span id="cb20-15"><a href="#cb20-15"></a>In [<span class="dv">50</span>]: frame2.columns</span>
<span id="cb20-16"><a href="#cb20-16"></a>Out[<span class="dv">50</span>]: Index([<span class="st">&#39;year&#39;</span>, <span class="st">&#39;state&#39;</span>, <span class="st">&#39;pop&#39;</span>, <span class="st">&#39;debt&#39;</span>], dtype<span class="op">=</span><span class="st">&#39;object&#39;</span>)</span></code></pre></div>
<p>通过类似字典标记的方式或属性的方式，可以将DataFrame的列获取为一个Series：</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb21-1"><a href="#cb21-1"></a>In [<span class="dv">51</span>]: frame2[<span class="st">&#39;state&#39;</span>]</span>
<span id="cb21-2"><a href="#cb21-2"></a>Out[<span class="dv">51</span>]: </span>
<span id="cb21-3"><a href="#cb21-3"></a>one        Ohio</span>
<span id="cb21-4"><a href="#cb21-4"></a>two        Ohio</span>
<span id="cb21-5"><a href="#cb21-5"></a>three      Ohio</span>
<span id="cb21-6"><a href="#cb21-6"></a>four     Nevada</span>
<span id="cb21-7"><a href="#cb21-7"></a>five     Nevada</span>
<span id="cb21-8"><a href="#cb21-8"></a>six      Nevada</span>
<span id="cb21-9"><a href="#cb21-9"></a>Name: state, dtype: <span class="bu">object</span></span>
<span id="cb21-10"><a href="#cb21-10"></a></span>
<span id="cb21-11"><a href="#cb21-11"></a>In [<span class="dv">52</span>]: frame2.year</span>
<span id="cb21-12"><a href="#cb21-12"></a>Out[<span class="dv">52</span>]: </span>
<span id="cb21-13"><a href="#cb21-13"></a>one      <span class="dv">2000</span></span>
<span id="cb21-14"><a href="#cb21-14"></a>two      <span class="dv">2001</span></span>
<span id="cb21-15"><a href="#cb21-15"></a>three    <span class="dv">2002</span></span>
<span id="cb21-16"><a href="#cb21-16"></a>four     <span class="dv">2001</span></span>
<span id="cb21-17"><a href="#cb21-17"></a>five     <span class="dv">2002</span></span>
<span id="cb21-18"><a href="#cb21-18"></a>six      <span class="dv">2003</span></span>
<span id="cb21-19"><a href="#cb21-19"></a>Name: year, dtype: int64</span></code></pre></div>
<blockquote>
<p>笔记：IPython提供了类似属性的访问（即frame2.year）和tab补全。 frame2[column]适用于任何列的名，但是frame2.column只有在列名是一个合理的Python变量名时才适用。</p>
</blockquote>
<p>注意，返回的Series拥有原DataFrame相同的索引，且其name属性也已经被相应地设置好了。</p>
<p>行也可以通过位置或名称的方式进行获取，比如用loc属性（稍后将对此进行详细讲解）：</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb22-1"><a href="#cb22-1"></a>In [<span class="dv">53</span>]: frame2.loc[<span class="st">&#39;three&#39;</span>]</span>
<span id="cb22-2"><a href="#cb22-2"></a>Out[<span class="dv">53</span>]: </span>
<span id="cb22-3"><a href="#cb22-3"></a>year     <span class="dv">2002</span></span>
<span id="cb22-4"><a href="#cb22-4"></a>state    Ohio</span>
<span id="cb22-5"><a href="#cb22-5"></a>pop       <span class="fl">3.6</span></span>
<span id="cb22-6"><a href="#cb22-6"></a>debt      NaN</span>
<span id="cb22-7"><a href="#cb22-7"></a>Name: three, dtype: <span class="bu">object</span></span></code></pre></div>
<p>列可以通过赋值的方式进行修改。例如，我们可以给那个空的“debt”列赋上一个标量值或一组值：</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb23-1"><a href="#cb23-1"></a>In [<span class="dv">54</span>]: frame2[<span class="st">&#39;debt&#39;</span>] <span class="op">=</span> <span class="fl">16.5</span></span>
<span id="cb23-2"><a href="#cb23-2"></a></span>
<span id="cb23-3"><a href="#cb23-3"></a>In [<span class="dv">55</span>]: frame2</span>
<span id="cb23-4"><a href="#cb23-4"></a>Out[<span class="dv">55</span>]: </span>
<span id="cb23-5"><a href="#cb23-5"></a>       year   state  pop  debt</span>
<span id="cb23-6"><a href="#cb23-6"></a>one    <span class="dv">2000</span>    Ohio  <span class="fl">1.5</span>  <span class="fl">16.5</span></span>
<span id="cb23-7"><a href="#cb23-7"></a>two    <span class="dv">2001</span>    Ohio  <span class="fl">1.7</span>  <span class="fl">16.5</span></span>
<span id="cb23-8"><a href="#cb23-8"></a>three  <span class="dv">2002</span>    Ohio  <span class="fl">3.6</span>  <span class="fl">16.5</span></span>
<span id="cb23-9"><a href="#cb23-9"></a>four   <span class="dv">2001</span>  Nevada  <span class="fl">2.4</span>  <span class="fl">16.5</span></span>
<span id="cb23-10"><a href="#cb23-10"></a>five   <span class="dv">2002</span>  Nevada  <span class="fl">2.9</span>  <span class="fl">16.5</span></span>
<span id="cb23-11"><a href="#cb23-11"></a>six    <span class="dv">2003</span>  Nevada  <span class="fl">3.2</span>  <span class="fl">16.5</span></span>
<span id="cb23-12"><a href="#cb23-12"></a></span>
<span id="cb23-13"><a href="#cb23-13"></a>In [<span class="dv">56</span>]: frame2[<span class="st">&#39;debt&#39;</span>] <span class="op">=</span> np.arange(<span class="fl">6.</span>)</span>
<span id="cb23-14"><a href="#cb23-14"></a></span>
<span id="cb23-15"><a href="#cb23-15"></a>In [<span class="dv">57</span>]: frame2</span>
<span id="cb23-16"><a href="#cb23-16"></a>Out[<span class="dv">57</span>]: </span>
<span id="cb23-17"><a href="#cb23-17"></a>       year   state  pop  debt</span>
<span id="cb23-18"><a href="#cb23-18"></a>one    <span class="dv">2000</span>    Ohio  <span class="fl">1.5</span>   <span class="fl">0.0</span></span>
<span id="cb23-19"><a href="#cb23-19"></a>two    <span class="dv">2001</span>    Ohio  <span class="fl">1.7</span>   <span class="fl">1.0</span></span>
<span id="cb23-20"><a href="#cb23-20"></a>three  <span class="dv">2002</span>    Ohio  <span class="fl">3.6</span>   <span class="fl">2.0</span></span>
<span id="cb23-21"><a href="#cb23-21"></a>four   <span class="dv">2001</span>  Nevada  <span class="fl">2.4</span>   <span class="fl">3.0</span></span>
<span id="cb23-22"><a href="#cb23-22"></a>five   <span class="dv">2002</span>  Nevada  <span class="fl">2.9</span>   <span class="fl">4.0</span></span>
<span id="cb23-23"><a href="#cb23-23"></a>six    <span class="dv">2003</span>  Nevada  <span class="fl">3.2</span>   <span class="fl">5.0</span></span></code></pre></div>
<p>将列表或数组赋值给某个列时，其长度必须跟DataFrame的长度相匹配。如果赋值的是一个Series，就会精确匹配DataFrame的索引，所有的空位都将被填上缺失值：</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb24-1"><a href="#cb24-1"></a>In [<span class="dv">58</span>]: val <span class="op">=</span> pd.Series([<span class="op">-</span><span class="fl">1.2</span>, <span class="op">-</span><span class="fl">1.5</span>, <span class="op">-</span><span class="fl">1.7</span>], index<span class="op">=</span>[<span class="st">&#39;two&#39;</span>, <span class="st">&#39;four&#39;</span>, <span class="st">&#39;five&#39;</span>])</span>
<span id="cb24-2"><a href="#cb24-2"></a></span>
<span id="cb24-3"><a href="#cb24-3"></a>In [<span class="dv">59</span>]: frame2[<span class="st">&#39;debt&#39;</span>] <span class="op">=</span> val</span>
<span id="cb24-4"><a href="#cb24-4"></a></span>
<span id="cb24-5"><a href="#cb24-5"></a>In [<span class="dv">60</span>]: frame2</span>
<span id="cb24-6"><a href="#cb24-6"></a>Out[<span class="dv">60</span>]: </span>
<span id="cb24-7"><a href="#cb24-7"></a>       year   state  pop  debt</span>
<span id="cb24-8"><a href="#cb24-8"></a>one    <span class="dv">2000</span>    Ohio  <span class="fl">1.5</span>   NaN</span>
<span id="cb24-9"><a href="#cb24-9"></a>two    <span class="dv">2001</span>    Ohio  <span class="fl">1.7</span>  <span class="op">-</span><span class="fl">1.2</span></span>
<span id="cb24-10"><a href="#cb24-10"></a>three  <span class="dv">2002</span>    Ohio  <span class="fl">3.6</span>   NaN</span>
<span id="cb24-11"><a href="#cb24-11"></a>four   <span class="dv">2001</span>  Nevada  <span class="fl">2.4</span>  <span class="op">-</span><span class="fl">1.5</span></span>
<span id="cb24-12"><a href="#cb24-12"></a>five   <span class="dv">2002</span>  Nevada  <span class="fl">2.9</span>  <span class="op">-</span><span class="fl">1.7</span></span>
<span id="cb24-13"><a href="#cb24-13"></a>six    <span class="dv">2003</span>  Nevada  <span class="fl">3.2</span>   NaN</span></code></pre></div>
<p>为不存在的列赋值会创建出一个新列。关键字del用于删除列。</p>
<p>作为del的例子，我先添加一个新的布尔值的列，state是否为’Ohio’：</p>
<div class="sourceCode" id="cb25"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb25-1"><a href="#cb25-1"></a>In [<span class="dv">61</span>]: frame2[<span class="st">&#39;eastern&#39;</span>] <span class="op">=</span> frame2.state <span class="op">==</span> <span class="st">&#39;Ohio&#39;</span></span>
<span id="cb25-2"><a href="#cb25-2"></a></span>
<span id="cb25-3"><a href="#cb25-3"></a>In [<span class="dv">62</span>]: frame2</span>
<span id="cb25-4"><a href="#cb25-4"></a>Out[<span class="dv">62</span>]: </span>
<span id="cb25-5"><a href="#cb25-5"></a>       year   state  pop  debt  eastern</span>
<span id="cb25-6"><a href="#cb25-6"></a>one    <span class="dv">2000</span>    Ohio  <span class="fl">1.5</span>   NaN     <span class="va">True</span></span>
<span id="cb25-7"><a href="#cb25-7"></a>two    <span class="dv">2001</span>    Ohio  <span class="fl">1.7</span>  <span class="op">-</span><span class="fl">1.2</span>     <span class="va">True</span></span>
<span id="cb25-8"><a href="#cb25-8"></a>three  <span class="dv">2002</span>    Ohio  <span class="fl">3.6</span>   NaN     <span class="va">True</span></span>
<span id="cb25-9"><a href="#cb25-9"></a>four   <span class="dv">2001</span>  Nevada  <span class="fl">2.4</span>  <span class="op">-</span><span class="fl">1.5</span>    <span class="va">False</span></span>
<span id="cb25-10"><a href="#cb25-10"></a>five   <span class="dv">2002</span>  Nevada  <span class="fl">2.9</span>  <span class="op">-</span><span class="fl">1.7</span>    <span class="va">False</span></span>
<span id="cb25-11"><a href="#cb25-11"></a>six    <span class="dv">2003</span>  Nevada  <span class="fl">3.2</span>   NaN    <span class="va">False</span></span></code></pre></div>
<blockquote>
<p>注意：不能用frame2.eastern创建新的列。</p>
</blockquote>
<p>del方法可以用来删除这列：</p>
<div class="sourceCode" id="cb26"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb26-1"><a href="#cb26-1"></a>In [<span class="dv">63</span>]: <span class="kw">del</span> frame2[<span class="st">&#39;eastern&#39;</span>]</span>
<span id="cb26-2"><a href="#cb26-2"></a></span>
<span id="cb26-3"><a href="#cb26-3"></a>In [<span class="dv">64</span>]: frame2.columns</span>
<span id="cb26-4"><a href="#cb26-4"></a>Out[<span class="dv">64</span>]: Index([<span class="st">&#39;year&#39;</span>, <span class="st">&#39;state&#39;</span>, <span class="st">&#39;pop&#39;</span>, <span class="st">&#39;debt&#39;</span>], dtype<span class="op">=</span><span class="st">&#39;object&#39;</span>)</span></code></pre></div>
<blockquote>
<p>注意：通过索引方式返回的列只是相应数据的视图而已，并不是副本。因此，对返回的Series所做的任何就地修改全都会反映到源DataFrame上。通过Series的copy方法即可指定复制列。</p>
</blockquote>
<p>另一种常见的数据形式是嵌套字典：</p>
<div class="sourceCode" id="cb27"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb27-1"><a href="#cb27-1"></a>In [<span class="dv">65</span>]: pop <span class="op">=</span> {<span class="st">&#39;Nevada&#39;</span>: {<span class="dv">2001</span>: <span class="fl">2.4</span>, <span class="dv">2002</span>: <span class="fl">2.9</span>},</span>
<span id="cb27-2"><a href="#cb27-2"></a>....:        <span class="st">&#39;Ohio&#39;</span>: {<span class="dv">2000</span>: <span class="fl">1.5</span>, <span class="dv">2001</span>: <span class="fl">1.7</span>, <span class="dv">2002</span>: <span class="fl">3.6</span>}}</span></code></pre></div>
<p>如果嵌套字典传给DataFrame，pandas就会被解释为：外层字典的键作为列，内层键则作为行索引：</p>
<div class="sourceCode" id="cb28"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb28-1"><a href="#cb28-1"></a>In [<span class="dv">66</span>]: frame3 <span class="op">=</span> pd.DataFrame(pop)</span>
<span id="cb28-2"><a href="#cb28-2"></a></span>
<span id="cb28-3"><a href="#cb28-3"></a>In [<span class="dv">67</span>]: frame3</span>
<span id="cb28-4"><a href="#cb28-4"></a>Out[<span class="dv">67</span>]: </span>
<span id="cb28-5"><a href="#cb28-5"></a>      Nevada  Ohio</span>
<span id="cb28-6"><a href="#cb28-6"></a><span class="dv">2000</span>     NaN   <span class="fl">1.5</span></span>
<span id="cb28-7"><a href="#cb28-7"></a><span class="dv">2001</span>     <span class="fl">2.4</span>   <span class="fl">1.7</span></span>
<span id="cb28-8"><a href="#cb28-8"></a><span class="dv">2002</span>     <span class="fl">2.9</span>   <span class="fl">3.6</span></span></code></pre></div>
<p>你也可以使用类似NumPy数组的方法，对DataFrame进行转置（交换行和列）：</p>
<div class="sourceCode" id="cb29"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb29-1"><a href="#cb29-1"></a>In [<span class="dv">68</span>]: frame3.T</span>
<span id="cb29-2"><a href="#cb29-2"></a>Out[<span class="dv">68</span>]: </span>
<span id="cb29-3"><a href="#cb29-3"></a>        <span class="dv">2000</span>  <span class="dv">2001</span>  <span class="dv">2002</span></span>
<span id="cb29-4"><a href="#cb29-4"></a>Nevada   NaN   <span class="fl">2.4</span>   <span class="fl">2.9</span></span>
<span id="cb29-5"><a href="#cb29-5"></a>Ohio     <span class="fl">1.5</span>   <span class="fl">1.7</span>   <span class="fl">3.6</span></span></code></pre></div>
<p>内层字典的键会被合并、排序以形成最终的索引。如果明确指定了索引，则不会这样：</p>
<div class="sourceCode" id="cb30"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb30-1"><a href="#cb30-1"></a>In [<span class="dv">69</span>]: pd.DataFrame(pop, index<span class="op">=</span>[<span class="dv">2001</span>, <span class="dv">2002</span>, <span class="dv">2003</span>])</span>
<span id="cb30-2"><a href="#cb30-2"></a>Out[<span class="dv">69</span>]: </span>
<span id="cb30-3"><a href="#cb30-3"></a>      Nevada  Ohio</span>
<span id="cb30-4"><a href="#cb30-4"></a><span class="dv">2001</span>     <span class="fl">2.4</span>   <span class="fl">1.7</span></span>
<span id="cb30-5"><a href="#cb30-5"></a><span class="dv">2002</span>     <span class="fl">2.9</span>   <span class="fl">3.6</span></span>
<span id="cb30-6"><a href="#cb30-6"></a><span class="dv">2003</span>     NaN   NaN</span></code></pre></div>
<p>由Series组成的字典差不多也是一样的用法：</p>
<div class="sourceCode" id="cb31"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb31-1"><a href="#cb31-1"></a>In [<span class="dv">70</span>]: pdata <span class="op">=</span> {<span class="st">&#39;Ohio&#39;</span>: frame3[<span class="st">&#39;Ohio&#39;</span>][:<span class="op">-</span><span class="dv">1</span>],</span>
<span id="cb31-2"><a href="#cb31-2"></a>....:          <span class="st">&#39;Nevada&#39;</span>: frame3[<span class="st">&#39;Nevada&#39;</span>][:<span class="dv">2</span>]}</span>
<span id="cb31-3"><a href="#cb31-3"></a></span>
<span id="cb31-4"><a href="#cb31-4"></a>In [<span class="dv">71</span>]: pd.DataFrame(pdata)</span>
<span id="cb31-5"><a href="#cb31-5"></a>Out[<span class="dv">71</span>]: </span>
<span id="cb31-6"><a href="#cb31-6"></a>      Nevada  Ohio</span>
<span id="cb31-7"><a href="#cb31-7"></a><span class="dv">2000</span>     NaN   <span class="fl">1.5</span></span>
<span id="cb31-8"><a href="#cb31-8"></a><span class="dv">2001</span>     <span class="fl">2.4</span>   <span class="fl">1.7</span></span></code></pre></div>
<p>表5-1列出了DataFrame构造函数所能接受的各种数据。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/7178691-106835b28c0cea5a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" /></p>
<p>如果设置了DataFrame的index和columns的name属性，则这些信息也会被显示出来：</p>
<div class="sourceCode" id="cb32"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb32-1"><a href="#cb32-1"></a>In [<span class="dv">72</span>]: frame3.index.name <span class="op">=</span> <span class="st">&#39;year&#39;</span><span class="op">;</span> frame3.columns.name <span class="op">=</span> <span class="st">&#39;state&#39;</span></span>
<span id="cb32-2"><a href="#cb32-2"></a></span>
<span id="cb32-3"><a href="#cb32-3"></a>In [<span class="dv">73</span>]: frame3</span>
<span id="cb32-4"><a href="#cb32-4"></a>Out[<span class="dv">73</span>]: </span>
<span id="cb32-5"><a href="#cb32-5"></a>state  Nevada  Ohio</span>
<span id="cb32-6"><a href="#cb32-6"></a>year</span>
<span id="cb32-7"><a href="#cb32-7"></a><span class="dv">2000</span>      NaN   <span class="fl">1.5</span></span>
<span id="cb32-8"><a href="#cb32-8"></a><span class="dv">2001</span>      <span class="fl">2.4</span>   <span class="fl">1.7</span></span>
<span id="cb32-9"><a href="#cb32-9"></a><span class="dv">2002</span>      <span class="fl">2.9</span>   <span class="fl">3.6</span></span></code></pre></div>
<p>跟Series一样，values属性也会以二维ndarray的形式返回DataFrame中的数据：</p>
<div class="sourceCode" id="cb33"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb33-1"><a href="#cb33-1"></a>In [<span class="dv">74</span>]: frame3.values</span>
<span id="cb33-2"><a href="#cb33-2"></a>Out[<span class="dv">74</span>]: </span>
<span id="cb33-3"><a href="#cb33-3"></a>array([[ nan,  <span class="fl">1.5</span>],</span>
<span id="cb33-4"><a href="#cb33-4"></a>       [ <span class="fl">2.4</span>,  <span class="fl">1.7</span>],</span>
<span id="cb33-5"><a href="#cb33-5"></a>       [ <span class="fl">2.9</span>,  <span class="fl">3.6</span>]])</span></code></pre></div>
<p>如果DataFrame各列的数据类型不同，则值数组的dtype就会选用能兼容所有列的数据类型：</p>
<div class="sourceCode" id="cb34"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb34-1"><a href="#cb34-1"></a>In [<span class="dv">75</span>]: frame2.values</span>
<span id="cb34-2"><a href="#cb34-2"></a>Out[<span class="dv">75</span>]:</span>
<span id="cb34-3"><a href="#cb34-3"></a>array([[<span class="dv">2000</span>, <span class="st">&#39;Ohio&#39;</span>, <span class="fl">1.5</span>, nan],</span>
<span id="cb34-4"><a href="#cb34-4"></a>       [<span class="dv">2001</span>, <span class="st">&#39;Ohio&#39;</span>, <span class="fl">1.7</span>, <span class="op">-</span><span class="fl">1.2</span>],</span>
<span id="cb34-5"><a href="#cb34-5"></a>       [<span class="dv">2002</span>, <span class="st">&#39;Ohio&#39;</span>, <span class="fl">3.6</span>, nan],</span>
<span id="cb34-6"><a href="#cb34-6"></a>       [<span class="dv">2001</span>, <span class="st">&#39;Nevada&#39;</span>, <span class="fl">2.4</span>, <span class="op">-</span><span class="fl">1.5</span>],</span>
<span id="cb34-7"><a href="#cb34-7"></a>       [<span class="dv">2002</span>, <span class="st">&#39;Nevada&#39;</span>, <span class="fl">2.9</span>, <span class="op">-</span><span class="fl">1.7</span>],</span>
<span id="cb34-8"><a href="#cb34-8"></a>       [<span class="dv">2003</span>, <span class="st">&#39;Nevada&#39;</span>, <span class="fl">3.2</span>, nan]], dtype<span class="op">=</span><span class="bu">object</span>)</span></code></pre></div>
<h2 id="索引对象">索引对象</h2>
<p>pandas的索引对象负责管理轴标签和其他元数据（比如轴名称等）。构建Series或DataFrame时，所用到的任何数组或其他序列的标签都会被转换成一个Index：</p>
<div class="sourceCode" id="cb35"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb35-1"><a href="#cb35-1"></a>In [<span class="dv">76</span>]: obj <span class="op">=</span> pd.Series(<span class="bu">range</span>(<span class="dv">3</span>), index<span class="op">=</span>[<span class="st">&#39;a&#39;</span>, <span class="st">&#39;b&#39;</span>, <span class="st">&#39;c&#39;</span>])</span>
<span id="cb35-2"><a href="#cb35-2"></a></span>
<span id="cb35-3"><a href="#cb35-3"></a>In [<span class="dv">77</span>]: index <span class="op">=</span> obj.index</span>
<span id="cb35-4"><a href="#cb35-4"></a></span>
<span id="cb35-5"><a href="#cb35-5"></a>In [<span class="dv">78</span>]: index</span>
<span id="cb35-6"><a href="#cb35-6"></a>Out[<span class="dv">78</span>]: Index([<span class="st">&#39;a&#39;</span>, <span class="st">&#39;b&#39;</span>, <span class="st">&#39;c&#39;</span>], dtype<span class="op">=</span><span class="st">&#39;object&#39;</span>)</span>
<span id="cb35-7"><a href="#cb35-7"></a></span>
<span id="cb35-8"><a href="#cb35-8"></a>In [<span class="dv">79</span>]: index[<span class="dv">1</span>:]</span>
<span id="cb35-9"><a href="#cb35-9"></a>Out[<span class="dv">79</span>]: Index([<span class="st">&#39;b&#39;</span>, <span class="st">&#39;c&#39;</span>], dtype<span class="op">=</span><span class="st">&#39;object&#39;</span>)</span></code></pre></div>
<p>Index对象是不可变的，因此用户不能对其进行修改：</p>
<div class="sourceCode" id="cb36"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb36-1"><a href="#cb36-1"></a>index[<span class="dv">1</span>] <span class="op">=</span> <span class="st">&#39;d&#39;</span>  <span class="co"># TypeError</span></span></code></pre></div>
<p>不可变可以使Index对象在多个数据结构之间安全共享：</p>
<div class="sourceCode" id="cb37"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb37-1"><a href="#cb37-1"></a>In [<span class="dv">80</span>]: labels <span class="op">=</span> pd.Index(np.arange(<span class="dv">3</span>))</span>
<span id="cb37-2"><a href="#cb37-2"></a></span>
<span id="cb37-3"><a href="#cb37-3"></a>In [<span class="dv">81</span>]: labels</span>
<span id="cb37-4"><a href="#cb37-4"></a>Out[<span class="dv">81</span>]: Int64Index([<span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">2</span>], dtype<span class="op">=</span><span class="st">&#39;int64&#39;</span>)</span>
<span id="cb37-5"><a href="#cb37-5"></a></span>
<span id="cb37-6"><a href="#cb37-6"></a>In [<span class="dv">82</span>]: obj2 <span class="op">=</span> pd.Series([<span class="fl">1.5</span>, <span class="op">-</span><span class="fl">2.5</span>, <span class="dv">0</span>], index<span class="op">=</span>labels)</span>
<span id="cb37-7"><a href="#cb37-7"></a></span>
<span id="cb37-8"><a href="#cb37-8"></a>In [<span class="dv">83</span>]: obj2</span>
<span id="cb37-9"><a href="#cb37-9"></a>Out[<span class="dv">83</span>]: </span>
<span id="cb37-10"><a href="#cb37-10"></a><span class="dv">0</span>    <span class="fl">1.5</span></span>
<span id="cb37-11"><a href="#cb37-11"></a><span class="dv">1</span>   <span class="op">-</span><span class="fl">2.5</span></span>
<span id="cb37-12"><a href="#cb37-12"></a><span class="dv">2</span>    <span class="fl">0.0</span></span>
<span id="cb37-13"><a href="#cb37-13"></a>dtype: float64</span>
<span id="cb37-14"><a href="#cb37-14"></a></span>
<span id="cb37-15"><a href="#cb37-15"></a>In [<span class="dv">84</span>]: obj2.index <span class="kw">is</span> labels</span>
<span id="cb37-16"><a href="#cb37-16"></a>Out[<span class="dv">84</span>]: <span class="va">True</span></span></code></pre></div>
<blockquote>
<p>注意：虽然用户不需要经常使用Index的功能，但是因为一些操作会生成包含被索引化的数据，理解它们的工作原理是很重要的。</p>
</blockquote>
<p>除了类似于数组，Index的功能也类似一个固定大小的集合：</p>
<div class="sourceCode" id="cb38"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb38-1"><a href="#cb38-1"></a>In [<span class="dv">85</span>]: frame3</span>
<span id="cb38-2"><a href="#cb38-2"></a>Out[<span class="dv">85</span>]: </span>
<span id="cb38-3"><a href="#cb38-3"></a>state  Nevada  Ohio</span>
<span id="cb38-4"><a href="#cb38-4"></a>year               </span>
<span id="cb38-5"><a href="#cb38-5"></a><span class="dv">2000</span>      NaN   <span class="fl">1.5</span></span>
<span id="cb38-6"><a href="#cb38-6"></a><span class="dv">2001</span>      <span class="fl">2.4</span>   <span class="fl">1.7</span></span>
<span id="cb38-7"><a href="#cb38-7"></a><span class="dv">2002</span>      <span class="fl">2.9</span>   <span class="fl">3.6</span></span>
<span id="cb38-8"><a href="#cb38-8"></a>In [<span class="dv">86</span>]: frame3.columns</span>
<span id="cb38-9"><a href="#cb38-9"></a>Out[<span class="dv">86</span>]: Index([<span class="st">&#39;Nevada&#39;</span>, <span class="st">&#39;Ohio&#39;</span>], dtype<span class="op">=</span><span class="st">&#39;object&#39;</span>, name<span class="op">=</span><span class="st">&#39;state&#39;</span>)</span>
<span id="cb38-10"><a href="#cb38-10"></a></span>
<span id="cb38-11"><a href="#cb38-11"></a>In [<span class="dv">87</span>]: <span class="st">&#39;Ohio&#39;</span> <span class="kw">in</span> frame3.columns</span>
<span id="cb38-12"><a href="#cb38-12"></a>Out[<span class="dv">87</span>]: <span class="va">True</span></span>
<span id="cb38-13"><a href="#cb38-13"></a></span>
<span id="cb38-14"><a href="#cb38-14"></a>In [<span class="dv">88</span>]: <span class="dv">2003</span> <span class="kw">in</span> frame3.index</span>
<span id="cb38-15"><a href="#cb38-15"></a>Out[<span class="dv">88</span>]: <span class="va">False</span></span></code></pre></div>
<p>与python的集合不同，pandas的Index可以包含重复的标签：</p>
<div class="sourceCode" id="cb39"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb39-1"><a href="#cb39-1"></a>In [<span class="dv">89</span>]: dup_labels <span class="op">=</span> pd.Index([<span class="st">&#39;foo&#39;</span>, <span class="st">&#39;foo&#39;</span>, <span class="st">&#39;bar&#39;</span>, <span class="st">&#39;bar&#39;</span>])</span>
<span id="cb39-2"><a href="#cb39-2"></a></span>
<span id="cb39-3"><a href="#cb39-3"></a>In [<span class="dv">90</span>]: dup_labels</span>
<span id="cb39-4"><a href="#cb39-4"></a>Out[<span class="dv">90</span>]: Index([<span class="st">&#39;foo&#39;</span>, <span class="st">&#39;foo&#39;</span>, <span class="st">&#39;bar&#39;</span>, <span class="st">&#39;bar&#39;</span>], dtype<span class="op">=</span><span class="st">&#39;object&#39;</span>)</span></code></pre></div>
<p>选择重复的标签，会显示所有的结果。</p>
<p>每个索引都有一些方法和属性，它们可用于设置逻辑并回答有关该索引所包含的数据的常见问题。表5-2列出了这些函数。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/7178691-5499d14f0e2cd639.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" /></p>
<h1 id="基本功能">5.2 基本功能</h1>
<p>本节中，我将介绍操作Series和DataFrame中的数据的基本手段。后续章节将更加深入地挖掘pandas在数据分析和处理方面的功能。本书不是pandas库的详尽文档，主要关注的是最重要的功能，那些不大常用的内容（也就是那些更深奥的内容）就交给你自己去摸索吧。</p>
<h2 id="重新索引">重新索引</h2>
<p>pandas对象的一个重要方法是reindex，其作用是创建一个新对象，它的数据符合新的索引。看下面的例子：</p>
<div class="sourceCode" id="cb40"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb40-1"><a href="#cb40-1"></a>In [<span class="dv">91</span>]: obj <span class="op">=</span> pd.Series([<span class="fl">4.5</span>, <span class="fl">7.2</span>, <span class="op">-</span><span class="fl">5.3</span>, <span class="fl">3.6</span>], index<span class="op">=</span>[<span class="st">&#39;d&#39;</span>, <span class="st">&#39;b&#39;</span>, <span class="st">&#39;a&#39;</span>, <span class="st">&#39;c&#39;</span>])</span>
<span id="cb40-2"><a href="#cb40-2"></a></span>
<span id="cb40-3"><a href="#cb40-3"></a>In [<span class="dv">92</span>]: obj</span>
<span id="cb40-4"><a href="#cb40-4"></a>Out[<span class="dv">92</span>]: </span>
<span id="cb40-5"><a href="#cb40-5"></a>d    <span class="fl">4.5</span></span>
<span id="cb40-6"><a href="#cb40-6"></a>b    <span class="fl">7.2</span></span>
<span id="cb40-7"><a href="#cb40-7"></a>a   <span class="op">-</span><span class="fl">5.3</span></span>
<span id="cb40-8"><a href="#cb40-8"></a>c    <span class="fl">3.6</span></span>
<span id="cb40-9"><a href="#cb40-9"></a>dtype: float64</span></code></pre></div>
<p>用该Series的reindex将会根据新索引进行重排。如果某个索引值当前不存在，就引入缺失值：</p>
<div class="sourceCode" id="cb41"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb41-1"><a href="#cb41-1"></a>In [<span class="dv">93</span>]: obj2 <span class="op">=</span> obj.reindex([<span class="st">&#39;a&#39;</span>, <span class="st">&#39;b&#39;</span>, <span class="st">&#39;c&#39;</span>, <span class="st">&#39;d&#39;</span>, <span class="st">&#39;e&#39;</span>])</span>
<span id="cb41-2"><a href="#cb41-2"></a></span>
<span id="cb41-3"><a href="#cb41-3"></a>In [<span class="dv">94</span>]: obj2</span>
<span id="cb41-4"><a href="#cb41-4"></a>Out[<span class="dv">94</span>]: </span>
<span id="cb41-5"><a href="#cb41-5"></a>a   <span class="op">-</span><span class="fl">5.3</span></span>
<span id="cb41-6"><a href="#cb41-6"></a>b    <span class="fl">7.2</span></span>
<span id="cb41-7"><a href="#cb41-7"></a>c    <span class="fl">3.6</span></span>
<span id="cb41-8"><a href="#cb41-8"></a>d    <span class="fl">4.5</span></span>
<span id="cb41-9"><a href="#cb41-9"></a>e    NaN</span>
<span id="cb41-10"><a href="#cb41-10"></a>dtype: float64</span></code></pre></div>
<p>对于时间序列这样的有序数据，重新索引时可能需要做一些插值处理。method选项即可达到此目的，例如，使用ffill可以实现前向值填充：</p>
<div class="sourceCode" id="cb42"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb42-1"><a href="#cb42-1"></a>In [<span class="dv">95</span>]: obj3 <span class="op">=</span> pd.Series([<span class="st">&#39;blue&#39;</span>, <span class="st">&#39;purple&#39;</span>, <span class="st">&#39;yellow&#39;</span>], index<span class="op">=</span>[<span class="dv">0</span>, <span class="dv">2</span>, <span class="dv">4</span>])</span>
<span id="cb42-2"><a href="#cb42-2"></a></span>
<span id="cb42-3"><a href="#cb42-3"></a>In [<span class="dv">96</span>]: obj3</span>
<span id="cb42-4"><a href="#cb42-4"></a>Out[<span class="dv">96</span>]: </span>
<span id="cb42-5"><a href="#cb42-5"></a><span class="dv">0</span>      blue</span>
<span id="cb42-6"><a href="#cb42-6"></a><span class="dv">2</span>    purple</span>
<span id="cb42-7"><a href="#cb42-7"></a><span class="dv">4</span>    yellow</span>
<span id="cb42-8"><a href="#cb42-8"></a>dtype: <span class="bu">object</span></span>
<span id="cb42-9"><a href="#cb42-9"></a></span>
<span id="cb42-10"><a href="#cb42-10"></a>In [<span class="dv">97</span>]: obj3.reindex(<span class="bu">range</span>(<span class="dv">6</span>), method<span class="op">=</span><span class="st">&#39;ffill&#39;</span>)</span>
<span id="cb42-11"><a href="#cb42-11"></a>Out[<span class="dv">97</span>]: </span>
<span id="cb42-12"><a href="#cb42-12"></a><span class="dv">0</span>      blue</span>
<span id="cb42-13"><a href="#cb42-13"></a><span class="dv">1</span>      blue</span>
<span id="cb42-14"><a href="#cb42-14"></a><span class="dv">2</span>    purple</span>
<span id="cb42-15"><a href="#cb42-15"></a><span class="dv">3</span>    purple</span>
<span id="cb42-16"><a href="#cb42-16"></a><span class="dv">4</span>    yellow</span>
<span id="cb42-17"><a href="#cb42-17"></a><span class="dv">5</span>    yellow</span>
<span id="cb42-18"><a href="#cb42-18"></a>dtype: <span class="bu">object</span></span></code></pre></div>
<p>借助DataFrame，reindex可以修改（行）索引和列。只传递一个序列时，会重新索引结果的行：</p>
<div class="sourceCode" id="cb43"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb43-1"><a href="#cb43-1"></a>In [<span class="dv">98</span>]: frame <span class="op">=</span> pd.DataFrame(np.arange(<span class="dv">9</span>).reshape((<span class="dv">3</span>, <span class="dv">3</span>)),</span>
<span id="cb43-2"><a href="#cb43-2"></a>   ....:                      index<span class="op">=</span>[<span class="st">&#39;a&#39;</span>, <span class="st">&#39;c&#39;</span>, <span class="st">&#39;d&#39;</span>],</span>
<span id="cb43-3"><a href="#cb43-3"></a>   ....:                      columns<span class="op">=</span>[<span class="st">&#39;Ohio&#39;</span>, <span class="st">&#39;Texas&#39;</span>, <span class="st">&#39;California&#39;</span>])</span>
<span id="cb43-4"><a href="#cb43-4"></a></span>
<span id="cb43-5"><a href="#cb43-5"></a>In [<span class="dv">99</span>]: frame</span>
<span id="cb43-6"><a href="#cb43-6"></a>Out[<span class="dv">99</span>]: </span>
<span id="cb43-7"><a href="#cb43-7"></a>   Ohio  Texas  California</span>
<span id="cb43-8"><a href="#cb43-8"></a>a     <span class="dv">0</span>      <span class="dv">1</span>           <span class="dv">2</span></span>
<span id="cb43-9"><a href="#cb43-9"></a>c     <span class="dv">3</span>      <span class="dv">4</span>           <span class="dv">5</span></span>
<span id="cb43-10"><a href="#cb43-10"></a>d     <span class="dv">6</span>      <span class="dv">7</span>           <span class="dv">8</span></span>
<span id="cb43-11"><a href="#cb43-11"></a></span>
<span id="cb43-12"><a href="#cb43-12"></a>In [<span class="dv">100</span>]: frame2 <span class="op">=</span> frame.reindex([<span class="st">&#39;a&#39;</span>, <span class="st">&#39;b&#39;</span>, <span class="st">&#39;c&#39;</span>, <span class="st">&#39;d&#39;</span>])</span>
<span id="cb43-13"><a href="#cb43-13"></a></span>
<span id="cb43-14"><a href="#cb43-14"></a>In [<span class="dv">101</span>]: frame2</span>
<span id="cb43-15"><a href="#cb43-15"></a>Out[<span class="dv">101</span>]: </span>
<span id="cb43-16"><a href="#cb43-16"></a>   Ohio  Texas  California</span>
<span id="cb43-17"><a href="#cb43-17"></a>a   <span class="fl">0.0</span>    <span class="fl">1.0</span>         <span class="fl">2.0</span></span>
<span id="cb43-18"><a href="#cb43-18"></a>b   NaN    NaN         NaN</span>
<span id="cb43-19"><a href="#cb43-19"></a>c   <span class="fl">3.0</span>    <span class="fl">4.0</span>         <span class="fl">5.0</span></span>
<span id="cb43-20"><a href="#cb43-20"></a>d   <span class="fl">6.0</span>    <span class="fl">7.0</span>         <span class="fl">8.0</span></span></code></pre></div>
<p>列可以用columns关键字重新索引：</p>
<div class="sourceCode" id="cb44"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb44-1"><a href="#cb44-1"></a>In [<span class="dv">102</span>]: states <span class="op">=</span> [<span class="st">&#39;Texas&#39;</span>, <span class="st">&#39;Utah&#39;</span>, <span class="st">&#39;California&#39;</span>]</span>
<span id="cb44-2"><a href="#cb44-2"></a></span>
<span id="cb44-3"><a href="#cb44-3"></a>In [<span class="dv">103</span>]: frame.reindex(columns<span class="op">=</span>states)</span>
<span id="cb44-4"><a href="#cb44-4"></a>Out[<span class="dv">103</span>]: </span>
<span id="cb44-5"><a href="#cb44-5"></a>   Texas  Utah  California</span>
<span id="cb44-6"><a href="#cb44-6"></a>a      <span class="dv">1</span>   NaN           <span class="dv">2</span></span>
<span id="cb44-7"><a href="#cb44-7"></a>c      <span class="dv">4</span>   NaN           <span class="dv">5</span></span>
<span id="cb44-8"><a href="#cb44-8"></a>d      <span class="dv">7</span>   NaN           <span class="dv">8</span></span></code></pre></div>
<p>表5-3列出了reindex函数的各参数及说明。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/7178691-efa3dbd4b83c61ec.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" /></p>
<h2 id="丢弃指定轴上的项">丢弃指定轴上的项</h2>
<p>丢弃某条轴上的一个或多个项很简单，只要有一个索引数组或列表即可。由于需要执行一些数据整理和集合逻辑，所以drop方法返回的是一个在指定轴上删除了指定值的新对象：</p>
<div class="sourceCode" id="cb45"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb45-1"><a href="#cb45-1"></a>In [<span class="dv">105</span>]: obj <span class="op">=</span> pd.Series(np.arange(<span class="fl">5.</span>), index<span class="op">=</span>[<span class="st">&#39;a&#39;</span>, <span class="st">&#39;b&#39;</span>, <span class="st">&#39;c&#39;</span>, <span class="st">&#39;d&#39;</span>, <span class="st">&#39;e&#39;</span>])</span>
<span id="cb45-2"><a href="#cb45-2"></a></span>
<span id="cb45-3"><a href="#cb45-3"></a>In [<span class="dv">106</span>]: obj</span>
<span id="cb45-4"><a href="#cb45-4"></a>Out[<span class="dv">106</span>]: </span>
<span id="cb45-5"><a href="#cb45-5"></a>a    <span class="fl">0.0</span></span>
<span id="cb45-6"><a href="#cb45-6"></a>b    <span class="fl">1.0</span></span>
<span id="cb45-7"><a href="#cb45-7"></a>c    <span class="fl">2.0</span></span>
<span id="cb45-8"><a href="#cb45-8"></a>d    <span class="fl">3.0</span></span>
<span id="cb45-9"><a href="#cb45-9"></a>e    <span class="fl">4.0</span></span>
<span id="cb45-10"><a href="#cb45-10"></a>dtype: float64</span>
<span id="cb45-11"><a href="#cb45-11"></a></span>
<span id="cb45-12"><a href="#cb45-12"></a>In [<span class="dv">107</span>]: new_obj <span class="op">=</span> obj.drop(<span class="st">&#39;c&#39;</span>)</span>
<span id="cb45-13"><a href="#cb45-13"></a></span>
<span id="cb45-14"><a href="#cb45-14"></a>In [<span class="dv">108</span>]: new_obj</span>
<span id="cb45-15"><a href="#cb45-15"></a>Out[<span class="dv">108</span>]: </span>
<span id="cb45-16"><a href="#cb45-16"></a>a    <span class="fl">0.0</span></span>
<span id="cb45-17"><a href="#cb45-17"></a>b    <span class="fl">1.0</span></span>
<span id="cb45-18"><a href="#cb45-18"></a>d    <span class="fl">3.0</span></span>
<span id="cb45-19"><a href="#cb45-19"></a>e    <span class="fl">4.0</span></span>
<span id="cb45-20"><a href="#cb45-20"></a>dtype: float64</span>
<span id="cb45-21"><a href="#cb45-21"></a></span>
<span id="cb45-22"><a href="#cb45-22"></a>In [<span class="dv">109</span>]: obj.drop([<span class="st">&#39;d&#39;</span>, <span class="st">&#39;c&#39;</span>])</span>
<span id="cb45-23"><a href="#cb45-23"></a>Out[<span class="dv">109</span>]: </span>
<span id="cb45-24"><a href="#cb45-24"></a>a    <span class="fl">0.0</span></span>
<span id="cb45-25"><a href="#cb45-25"></a>b    <span class="fl">1.0</span></span>
<span id="cb45-26"><a href="#cb45-26"></a>e    <span class="fl">4.0</span></span>
<span id="cb45-27"><a href="#cb45-27"></a>dtype: float64</span></code></pre></div>
<p>对于DataFrame，可以删除任意轴上的索引值。为了演示，先新建一个DataFrame例子：</p>
<div class="sourceCode" id="cb46"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb46-1"><a href="#cb46-1"></a>In [<span class="dv">110</span>]: data <span class="op">=</span> pd.DataFrame(np.arange(<span class="dv">16</span>).reshape((<span class="dv">4</span>, <span class="dv">4</span>)),</span>
<span id="cb46-2"><a href="#cb46-2"></a>   .....:                     index<span class="op">=</span>[<span class="st">&#39;Ohio&#39;</span>, <span class="st">&#39;Colorado&#39;</span>, <span class="st">&#39;Utah&#39;</span>, <span class="st">&#39;New York&#39;</span>],</span>
<span id="cb46-3"><a href="#cb46-3"></a>   .....:                     columns<span class="op">=</span>[<span class="st">&#39;one&#39;</span>, <span class="st">&#39;two&#39;</span>, <span class="st">&#39;three&#39;</span>, <span class="st">&#39;four&#39;</span>])</span>
<span id="cb46-4"><a href="#cb46-4"></a></span>
<span id="cb46-5"><a href="#cb46-5"></a>In [<span class="dv">111</span>]: data</span>
<span id="cb46-6"><a href="#cb46-6"></a>Out[<span class="dv">111</span>]: </span>
<span id="cb46-7"><a href="#cb46-7"></a>          one  two  three  four</span>
<span id="cb46-8"><a href="#cb46-8"></a>Ohio        <span class="dv">0</span>    <span class="dv">1</span>      <span class="dv">2</span>     <span class="dv">3</span></span>
<span id="cb46-9"><a href="#cb46-9"></a>Colorado    <span class="dv">4</span>    <span class="dv">5</span>      <span class="dv">6</span>     <span class="dv">7</span></span>
<span id="cb46-10"><a href="#cb46-10"></a>Utah        <span class="dv">8</span>    <span class="dv">9</span>     <span class="dv">10</span>    <span class="dv">11</span></span>
<span id="cb46-11"><a href="#cb46-11"></a>New York   <span class="dv">12</span>   <span class="dv">13</span>     <span class="dv">14</span>    <span class="dv">15</span></span></code></pre></div>
<p>用标签序列调用drop会从行标签（axis 0）删除值：</p>
<div class="sourceCode" id="cb47"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb47-1"><a href="#cb47-1"></a>In [<span class="dv">112</span>]: data.drop([<span class="st">&#39;Colorado&#39;</span>, <span class="st">&#39;Ohio&#39;</span>])</span>
<span id="cb47-2"><a href="#cb47-2"></a>Out[<span class="dv">112</span>]: </span>
<span id="cb47-3"><a href="#cb47-3"></a>          one  two  three  four</span>
<span id="cb47-4"><a href="#cb47-4"></a>Utah        <span class="dv">8</span>    <span class="dv">9</span>     <span class="dv">10</span>    <span class="dv">11</span></span>
<span id="cb47-5"><a href="#cb47-5"></a>New York   <span class="dv">12</span>   <span class="dv">13</span>     <span class="dv">14</span>    <span class="dv">15</span></span></code></pre></div>
<p>通过传递axis=1或axis=’columns’可以删除列的值：</p>
<div class="sourceCode" id="cb48"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb48-1"><a href="#cb48-1"></a>In [<span class="dv">113</span>]: data.drop(<span class="st">&#39;two&#39;</span>, axis<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb48-2"><a href="#cb48-2"></a>Out[<span class="dv">113</span>]: </span>
<span id="cb48-3"><a href="#cb48-3"></a>          one  three  four</span>
<span id="cb48-4"><a href="#cb48-4"></a>Ohio        <span class="dv">0</span>      <span class="dv">2</span>     <span class="dv">3</span></span>
<span id="cb48-5"><a href="#cb48-5"></a>Colorado    <span class="dv">4</span>      <span class="dv">6</span>     <span class="dv">7</span></span>
<span id="cb48-6"><a href="#cb48-6"></a>Utah        <span class="dv">8</span>     <span class="dv">10</span>    <span class="dv">11</span></span>
<span id="cb48-7"><a href="#cb48-7"></a>New York   <span class="dv">12</span>     <span class="dv">14</span>    <span class="dv">15</span></span>
<span id="cb48-8"><a href="#cb48-8"></a></span>
<span id="cb48-9"><a href="#cb48-9"></a>In [<span class="dv">114</span>]: data.drop([<span class="st">&#39;two&#39;</span>, <span class="st">&#39;four&#39;</span>], axis<span class="op">=</span><span class="st">&#39;columns&#39;</span>)</span>
<span id="cb48-10"><a href="#cb48-10"></a>Out[<span class="dv">114</span>]: </span>
<span id="cb48-11"><a href="#cb48-11"></a>          one  three</span>
<span id="cb48-12"><a href="#cb48-12"></a>Ohio        <span class="dv">0</span>      <span class="dv">2</span></span>
<span id="cb48-13"><a href="#cb48-13"></a>Colorado    <span class="dv">4</span>      <span class="dv">6</span></span>
<span id="cb48-14"><a href="#cb48-14"></a>Utah        <span class="dv">8</span>     <span class="dv">10</span></span>
<span id="cb48-15"><a href="#cb48-15"></a>New York   <span class="dv">12</span>     <span class="dv">14</span></span></code></pre></div>
<p>许多函数，如drop，会修改Series或DataFrame的大小或形状，可以就地修改对象，不会返回新的对象：</p>
<div class="sourceCode" id="cb49"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb49-1"><a href="#cb49-1"></a>In [<span class="dv">115</span>]: obj.drop(<span class="st">&#39;c&#39;</span>, inplace<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb49-2"><a href="#cb49-2"></a></span>
<span id="cb49-3"><a href="#cb49-3"></a>In [<span class="dv">116</span>]: obj</span>
<span id="cb49-4"><a href="#cb49-4"></a>Out[<span class="dv">116</span>]: </span>
<span id="cb49-5"><a href="#cb49-5"></a>a    <span class="fl">0.0</span></span>
<span id="cb49-6"><a href="#cb49-6"></a>b    <span class="fl">1.0</span></span>
<span id="cb49-7"><a href="#cb49-7"></a>d    <span class="fl">3.0</span></span>
<span id="cb49-8"><a href="#cb49-8"></a>e    <span class="fl">4.0</span></span>
<span id="cb49-9"><a href="#cb49-9"></a>dtype: float64</span></code></pre></div>
<p>小心使用inplace，它会销毁所有被删除的数据。</p>
<h2 id="索引选取和过滤">索引、选取和过滤</h2>
<p>Series索引（obj[…]）的工作方式类似于NumPy数组的索引，只不过Series的索引值不只是整数。下面是几个例子：</p>
<div class="sourceCode" id="cb50"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb50-1"><a href="#cb50-1"></a>In [<span class="dv">117</span>]: obj <span class="op">=</span> pd.Series(np.arange(<span class="fl">4.</span>), index<span class="op">=</span>[<span class="st">&#39;a&#39;</span>, <span class="st">&#39;b&#39;</span>, <span class="st">&#39;c&#39;</span>, <span class="st">&#39;d&#39;</span>])</span>
<span id="cb50-2"><a href="#cb50-2"></a></span>
<span id="cb50-3"><a href="#cb50-3"></a>In [<span class="dv">118</span>]: obj</span>
<span id="cb50-4"><a href="#cb50-4"></a>Out[<span class="dv">118</span>]: </span>
<span id="cb50-5"><a href="#cb50-5"></a>a    <span class="fl">0.0</span></span>
<span id="cb50-6"><a href="#cb50-6"></a>b    <span class="fl">1.0</span></span>
<span id="cb50-7"><a href="#cb50-7"></a>c    <span class="fl">2.0</span></span>
<span id="cb50-8"><a href="#cb50-8"></a>d    <span class="fl">3.0</span></span>
<span id="cb50-9"><a href="#cb50-9"></a>dtype: float64</span>
<span id="cb50-10"><a href="#cb50-10"></a></span>
<span id="cb50-11"><a href="#cb50-11"></a>In [<span class="dv">119</span>]: obj[<span class="st">&#39;b&#39;</span>]</span>
<span id="cb50-12"><a href="#cb50-12"></a>Out[<span class="dv">119</span>]: <span class="fl">1.0</span></span>
<span id="cb50-13"><a href="#cb50-13"></a></span>
<span id="cb50-14"><a href="#cb50-14"></a>In [<span class="dv">120</span>]: obj[<span class="dv">1</span>]</span>
<span id="cb50-15"><a href="#cb50-15"></a>Out[<span class="dv">120</span>]: <span class="fl">1.0</span></span>
<span id="cb50-16"><a href="#cb50-16"></a></span>
<span id="cb50-17"><a href="#cb50-17"></a>In [<span class="dv">121</span>]: obj[<span class="dv">2</span>:<span class="dv">4</span>]</span>
<span id="cb50-18"><a href="#cb50-18"></a>Out[<span class="dv">121</span>]: </span>
<span id="cb50-19"><a href="#cb50-19"></a>c    <span class="fl">2.0</span></span>
<span id="cb50-20"><a href="#cb50-20"></a>d    <span class="fl">3.0</span></span>
<span id="cb50-21"><a href="#cb50-21"></a>dtype: float64</span>
<span id="cb50-22"><a href="#cb50-22"></a></span>
<span id="cb50-23"><a href="#cb50-23"></a>In [<span class="dv">122</span>]: obj[[<span class="st">&#39;b&#39;</span>, <span class="st">&#39;a&#39;</span>, <span class="st">&#39;d&#39;</span>]]</span>
<span id="cb50-24"><a href="#cb50-24"></a>Out[<span class="dv">122</span>]:</span>
<span id="cb50-25"><a href="#cb50-25"></a>b    <span class="fl">1.0</span></span>
<span id="cb50-26"><a href="#cb50-26"></a>a    <span class="fl">0.0</span></span>
<span id="cb50-27"><a href="#cb50-27"></a>d    <span class="fl">3.0</span></span>
<span id="cb50-28"><a href="#cb50-28"></a>dtype: float64</span>
<span id="cb50-29"><a href="#cb50-29"></a></span>
<span id="cb50-30"><a href="#cb50-30"></a>In [<span class="dv">123</span>]: obj[[<span class="dv">1</span>, <span class="dv">3</span>]]</span>
<span id="cb50-31"><a href="#cb50-31"></a>Out[<span class="dv">123</span>]: </span>
<span id="cb50-32"><a href="#cb50-32"></a>b    <span class="fl">1.0</span></span>
<span id="cb50-33"><a href="#cb50-33"></a>d    <span class="fl">3.0</span></span>
<span id="cb50-34"><a href="#cb50-34"></a>dtype: float64</span>
<span id="cb50-35"><a href="#cb50-35"></a></span>
<span id="cb50-36"><a href="#cb50-36"></a>In [<span class="dv">124</span>]: obj[obj <span class="op">&lt;</span> <span class="dv">2</span>]</span>
<span id="cb50-37"><a href="#cb50-37"></a>Out[<span class="dv">124</span>]: </span>
<span id="cb50-38"><a href="#cb50-38"></a>a    <span class="fl">0.0</span></span>
<span id="cb50-39"><a href="#cb50-39"></a>b    <span class="fl">1.0</span></span>
<span id="cb50-40"><a href="#cb50-40"></a>dtype: float64</span></code></pre></div>
<p>利用标签的切片运算与普通的Python切片运算不同，其末端是包含的：</p>
<div class="sourceCode" id="cb51"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb51-1"><a href="#cb51-1"></a>In [<span class="dv">125</span>]: obj[<span class="st">&#39;b&#39;</span>:<span class="st">&#39;c&#39;</span>]</span>
<span id="cb51-2"><a href="#cb51-2"></a>Out[<span class="dv">125</span>]:</span>
<span id="cb51-3"><a href="#cb51-3"></a>b    <span class="fl">1.0</span></span>
<span id="cb51-4"><a href="#cb51-4"></a>c    <span class="fl">2.0</span></span>
<span id="cb51-5"><a href="#cb51-5"></a>dtype: float64</span></code></pre></div>
<p>用切片可以对Series的相应部分进行设置：</p>
<div class="sourceCode" id="cb52"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb52-1"><a href="#cb52-1"></a>In [<span class="dv">126</span>]: obj[<span class="st">&#39;b&#39;</span>:<span class="st">&#39;c&#39;</span>] <span class="op">=</span> <span class="dv">5</span></span>
<span id="cb52-2"><a href="#cb52-2"></a></span>
<span id="cb52-3"><a href="#cb52-3"></a>In [<span class="dv">127</span>]: obj</span>
<span id="cb52-4"><a href="#cb52-4"></a>Out[<span class="dv">127</span>]: </span>
<span id="cb52-5"><a href="#cb52-5"></a>a    <span class="fl">0.0</span></span>
<span id="cb52-6"><a href="#cb52-6"></a>b    <span class="fl">5.0</span></span>
<span id="cb52-7"><a href="#cb52-7"></a>c    <span class="fl">5.0</span></span>
<span id="cb52-8"><a href="#cb52-8"></a>d    <span class="fl">3.0</span></span>
<span id="cb52-9"><a href="#cb52-9"></a>dtype: float64</span></code></pre></div>
<p>用一个值或序列对DataFrame进行索引其实就是获取一个或多个列：</p>
<div class="sourceCode" id="cb53"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb53-1"><a href="#cb53-1"></a>In [<span class="dv">128</span>]: data <span class="op">=</span> pd.DataFrame(np.arange(<span class="dv">16</span>).reshape((<span class="dv">4</span>, <span class="dv">4</span>)),</span>
<span id="cb53-2"><a href="#cb53-2"></a>   .....:                     index<span class="op">=</span>[<span class="st">&#39;Ohio&#39;</span>, <span class="st">&#39;Colorado&#39;</span>, <span class="st">&#39;Utah&#39;</span>, <span class="st">&#39;New York&#39;</span>],</span>
<span id="cb53-3"><a href="#cb53-3"></a>   .....:                     columns<span class="op">=</span>[<span class="st">&#39;one&#39;</span>, <span class="st">&#39;two&#39;</span>, <span class="st">&#39;three&#39;</span>, <span class="st">&#39;four&#39;</span>])</span>
<span id="cb53-4"><a href="#cb53-4"></a></span>
<span id="cb53-5"><a href="#cb53-5"></a>In [<span class="dv">129</span>]: data</span>
<span id="cb53-6"><a href="#cb53-6"></a>Out[<span class="dv">129</span>]: </span>
<span id="cb53-7"><a href="#cb53-7"></a>          one  two  three  four</span>
<span id="cb53-8"><a href="#cb53-8"></a>Ohio        <span class="dv">0</span>    <span class="dv">1</span>      <span class="dv">2</span>     <span class="dv">3</span></span>
<span id="cb53-9"><a href="#cb53-9"></a>Colorado    <span class="dv">4</span>    <span class="dv">5</span>      <span class="dv">6</span>     <span class="dv">7</span></span>
<span id="cb53-10"><a href="#cb53-10"></a>Utah        <span class="dv">8</span>    <span class="dv">9</span>     <span class="dv">10</span>    <span class="dv">11</span></span>
<span id="cb53-11"><a href="#cb53-11"></a>New York   <span class="dv">12</span>   <span class="dv">13</span>     <span class="dv">14</span>    <span class="dv">15</span></span>
<span id="cb53-12"><a href="#cb53-12"></a></span>
<span id="cb53-13"><a href="#cb53-13"></a>In [<span class="dv">130</span>]: data[<span class="st">&#39;two&#39;</span>]</span>
<span id="cb53-14"><a href="#cb53-14"></a>Out[<span class="dv">130</span>]: </span>
<span id="cb53-15"><a href="#cb53-15"></a>Ohio         <span class="dv">1</span></span>
<span id="cb53-16"><a href="#cb53-16"></a>Colorado     <span class="dv">5</span></span>
<span id="cb53-17"><a href="#cb53-17"></a>Utah         <span class="dv">9</span></span>
<span id="cb53-18"><a href="#cb53-18"></a>New York    <span class="dv">13</span></span>
<span id="cb53-19"><a href="#cb53-19"></a>Name: two, dtype: int64</span>
<span id="cb53-20"><a href="#cb53-20"></a></span>
<span id="cb53-21"><a href="#cb53-21"></a>In [<span class="dv">131</span>]: data[[<span class="st">&#39;three&#39;</span>, <span class="st">&#39;one&#39;</span>]]</span>
<span id="cb53-22"><a href="#cb53-22"></a>Out[<span class="dv">131</span>]: </span>
<span id="cb53-23"><a href="#cb53-23"></a>          three  one</span>
<span id="cb53-24"><a href="#cb53-24"></a>Ohio          <span class="dv">2</span>    <span class="dv">0</span></span>
<span id="cb53-25"><a href="#cb53-25"></a>Colorado      <span class="dv">6</span>    <span class="dv">4</span></span>
<span id="cb53-26"><a href="#cb53-26"></a>Utah         <span class="dv">10</span>    <span class="dv">8</span></span>
<span id="cb53-27"><a href="#cb53-27"></a>New York     <span class="dv">14</span>   <span class="dv">12</span></span></code></pre></div>
<p>这种索引方式有几个特殊的情况。首先通过切片或布尔型数组选取数据：</p>
<div class="sourceCode" id="cb54"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb54-1"><a href="#cb54-1"></a>In [<span class="dv">132</span>]: data[:<span class="dv">2</span>]</span>
<span id="cb54-2"><a href="#cb54-2"></a>Out[<span class="dv">132</span>]: </span>
<span id="cb54-3"><a href="#cb54-3"></a>          one  two  three  four</span>
<span id="cb54-4"><a href="#cb54-4"></a>Ohio        <span class="dv">0</span>    <span class="dv">1</span>      <span class="dv">2</span>     <span class="dv">3</span></span>
<span id="cb54-5"><a href="#cb54-5"></a>Colorado    <span class="dv">4</span>    <span class="dv">5</span>      <span class="dv">6</span>     <span class="dv">7</span></span>
<span id="cb54-6"><a href="#cb54-6"></a></span>
<span id="cb54-7"><a href="#cb54-7"></a>In [<span class="dv">133</span>]: data[data[<span class="st">&#39;three&#39;</span>] <span class="op">&gt;</span> <span class="dv">5</span>]</span>
<span id="cb54-8"><a href="#cb54-8"></a>Out[<span class="dv">133</span>]: </span>
<span id="cb54-9"><a href="#cb54-9"></a>          one  two  three  four</span>
<span id="cb54-10"><a href="#cb54-10"></a>Colorado    <span class="dv">4</span>    <span class="dv">5</span>      <span class="dv">6</span>     <span class="dv">7</span></span>
<span id="cb54-11"><a href="#cb54-11"></a>Utah        <span class="dv">8</span>    <span class="dv">9</span>     <span class="dv">10</span>    <span class="dv">11</span></span>
<span id="cb54-12"><a href="#cb54-12"></a>New York   <span class="dv">12</span>   <span class="dv">13</span>     <span class="dv">14</span>    <span class="dv">15</span></span></code></pre></div>
<p>选取行的语法data[:2]十分方便。向[ ]传递单一的元素或列表，就可选择列。</p>
<p>另一种用法是通过布尔型DataFrame（比如下面这个由标量比较运算得出的）进行索引：</p>
<div class="sourceCode" id="cb55"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb55-1"><a href="#cb55-1"></a>In [<span class="dv">134</span>]: data <span class="op">&lt;</span> <span class="dv">5</span></span>
<span id="cb55-2"><a href="#cb55-2"></a>Out[<span class="dv">134</span>]: </span>
<span id="cb55-3"><a href="#cb55-3"></a>            one    two  three   four</span>
<span id="cb55-4"><a href="#cb55-4"></a>Ohio       <span class="va">True</span>   <span class="va">True</span>   <span class="va">True</span>   <span class="va">True</span></span>
<span id="cb55-5"><a href="#cb55-5"></a>Colorado   <span class="va">True</span>  <span class="va">False</span>  <span class="va">False</span>  <span class="va">False</span></span>
<span id="cb55-6"><a href="#cb55-6"></a>Utah      <span class="va">False</span>  <span class="va">False</span>  <span class="va">False</span>  <span class="va">False</span></span>
<span id="cb55-7"><a href="#cb55-7"></a>New York  <span class="va">False</span>  <span class="va">False</span>  <span class="va">False</span>  <span class="va">False</span></span>
<span id="cb55-8"><a href="#cb55-8"></a></span>
<span id="cb55-9"><a href="#cb55-9"></a>In [<span class="dv">135</span>]: data[data <span class="op">&lt;</span> <span class="dv">5</span>] <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb55-10"><a href="#cb55-10"></a></span>
<span id="cb55-11"><a href="#cb55-11"></a>In [<span class="dv">136</span>]: data</span>
<span id="cb55-12"><a href="#cb55-12"></a>Out[<span class="dv">136</span>]: </span>
<span id="cb55-13"><a href="#cb55-13"></a>          one  two  three  four</span>
<span id="cb55-14"><a href="#cb55-14"></a>Ohio        <span class="dv">0</span>    <span class="dv">0</span>      <span class="dv">0</span>     <span class="dv">0</span></span>
<span id="cb55-15"><a href="#cb55-15"></a>Colorado    <span class="dv">0</span>    <span class="dv">5</span>      <span class="dv">6</span>     <span class="dv">7</span></span>
<span id="cb55-16"><a href="#cb55-16"></a>Utah        <span class="dv">8</span>    <span class="dv">9</span>     <span class="dv">10</span>    <span class="dv">11</span></span>
<span id="cb55-17"><a href="#cb55-17"></a>New York   <span class="dv">12</span>   <span class="dv">13</span>     <span class="dv">14</span>    <span class="dv">15</span></span></code></pre></div>
<p>这使得DataFrame的语法与NumPy二维数组的语法很像。</p>
<h2 id="用loc和iloc进行选取">用loc和iloc进行选取</h2>
<p>对于DataFrame的行的标签索引，我引入了特殊的标签运算符loc和iloc。它们可以让你用类似NumPy的标记，使用轴标签（loc）或整数索引（iloc），从DataFrame选择行和列的子集。</p>
<p>作为一个初步示例，让我们通过标签选择一行和多列：</p>
<div class="sourceCode" id="cb56"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb56-1"><a href="#cb56-1"></a>In [<span class="dv">137</span>]: data.loc[<span class="st">&#39;Colorado&#39;</span>, [<span class="st">&#39;two&#39;</span>, <span class="st">&#39;three&#39;</span>]]</span>
<span id="cb56-2"><a href="#cb56-2"></a>Out[<span class="dv">137</span>]: </span>
<span id="cb56-3"><a href="#cb56-3"></a>two      <span class="dv">5</span></span>
<span id="cb56-4"><a href="#cb56-4"></a>three    <span class="dv">6</span></span>
<span id="cb56-5"><a href="#cb56-5"></a>Name: Colorado, dtype: int64</span></code></pre></div>
<p>然后用iloc和整数进行选取：</p>
<div class="sourceCode" id="cb57"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb57-1"><a href="#cb57-1"></a>In [<span class="dv">138</span>]: data.iloc[<span class="dv">2</span>, [<span class="dv">3</span>, <span class="dv">0</span>, <span class="dv">1</span>]]</span>
<span id="cb57-2"><a href="#cb57-2"></a>Out[<span class="dv">138</span>]: </span>
<span id="cb57-3"><a href="#cb57-3"></a>four    <span class="dv">11</span></span>
<span id="cb57-4"><a href="#cb57-4"></a>one      <span class="dv">8</span></span>
<span id="cb57-5"><a href="#cb57-5"></a>two      <span class="dv">9</span></span>
<span id="cb57-6"><a href="#cb57-6"></a>Name: Utah, dtype: int64</span>
<span id="cb57-7"><a href="#cb57-7"></a></span>
<span id="cb57-8"><a href="#cb57-8"></a>In [<span class="dv">139</span>]: data.iloc[<span class="dv">2</span>]</span>
<span id="cb57-9"><a href="#cb57-9"></a>Out[<span class="dv">139</span>]: </span>
<span id="cb57-10"><a href="#cb57-10"></a>one       <span class="dv">8</span></span>
<span id="cb57-11"><a href="#cb57-11"></a>two       <span class="dv">9</span></span>
<span id="cb57-12"><a href="#cb57-12"></a>three    <span class="dv">10</span></span>
<span id="cb57-13"><a href="#cb57-13"></a>four     <span class="dv">11</span></span>
<span id="cb57-14"><a href="#cb57-14"></a>Name: Utah, dtype: int64</span>
<span id="cb57-15"><a href="#cb57-15"></a></span>
<span id="cb57-16"><a href="#cb57-16"></a>In [<span class="dv">140</span>]: data.iloc[[<span class="dv">1</span>, <span class="dv">2</span>], [<span class="dv">3</span>, <span class="dv">0</span>, <span class="dv">1</span>]]</span>
<span id="cb57-17"><a href="#cb57-17"></a>Out[<span class="dv">140</span>]: </span>
<span id="cb57-18"><a href="#cb57-18"></a>          four  one  two</span>
<span id="cb57-19"><a href="#cb57-19"></a>Colorado     <span class="dv">7</span>    <span class="dv">0</span>    <span class="dv">5</span></span>
<span id="cb57-20"><a href="#cb57-20"></a>Utah        <span class="dv">11</span>    <span class="dv">8</span>    <span class="dv">9</span></span></code></pre></div>
<p>这两个索引函数也适用于一个标签或多个标签的切片：</p>
<div class="sourceCode" id="cb58"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb58-1"><a href="#cb58-1"></a>In [<span class="dv">141</span>]: data.loc[:<span class="st">&#39;Utah&#39;</span>, <span class="st">&#39;two&#39;</span>]</span>
<span id="cb58-2"><a href="#cb58-2"></a>Out[<span class="dv">141</span>]: </span>
<span id="cb58-3"><a href="#cb58-3"></a>Ohio        <span class="dv">0</span></span>
<span id="cb58-4"><a href="#cb58-4"></a>Colorado    <span class="dv">5</span></span>
<span id="cb58-5"><a href="#cb58-5"></a>Utah        <span class="dv">9</span></span>
<span id="cb58-6"><a href="#cb58-6"></a>Name: two, dtype: int64</span>
<span id="cb58-7"><a href="#cb58-7"></a></span>
<span id="cb58-8"><a href="#cb58-8"></a>In [<span class="dv">142</span>]: data.iloc[:, :<span class="dv">3</span>][data.three <span class="op">&gt;</span> <span class="dv">5</span>]</span>
<span id="cb58-9"><a href="#cb58-9"></a>Out[<span class="dv">142</span>]: </span>
<span id="cb58-10"><a href="#cb58-10"></a>          one  two  three</span>
<span id="cb58-11"><a href="#cb58-11"></a>Colorado    <span class="dv">0</span>    <span class="dv">5</span>      <span class="dv">6</span></span>
<span id="cb58-12"><a href="#cb58-12"></a>Utah        <span class="dv">8</span>    <span class="dv">9</span>     <span class="dv">10</span></span>
<span id="cb58-13"><a href="#cb58-13"></a>New York   <span class="dv">12</span>   <span class="dv">13</span>     <span class="dv">14</span></span></code></pre></div>
<p>所以，在pandas中，有多个方法可以选取和重新组合数据。对于DataFrame，表5-4进行了总结。后面会看到，还有更多的方法进行层级化索引。</p>
<blockquote>
<p>笔记：在一开始设计pandas时，我觉得用frame[:, col]选取列过于繁琐（也容易出错），因为列的选择是非常常见的操作。我做了些取舍，将花式索引的功能（标签和整数）放到了ix运算符中。在实践中，这会导致许多边缘情况，数据的轴标签是整数，所以pandas团队决定创造loc和iloc运算符分别处理严格基于标签和整数的索引。 ix运算符仍然可用，但并不推荐。</p>
</blockquote>
<figure>
<img src="http://upload-images.jianshu.io/upload_images/7178691-64354f2ab777bd8c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="" /><figcaption>表5-4 DataFrame的索引选项</figcaption>
</figure>
<h2 id="整数索引">整数索引</h2>
<p>处理整数索引的pandas对象常常难住新手，因为它与Python内置的列表和元组的索引语法不同。例如，你可能不认为下面的代码会出错：</p>
<div class="sourceCode" id="cb59"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb59-1"><a href="#cb59-1"></a>ser <span class="op">=</span> pd.Series(np.arange(<span class="fl">3.</span>))</span>
<span id="cb59-2"><a href="#cb59-2"></a>ser</span>
<span id="cb59-3"><a href="#cb59-3"></a>ser[<span class="op">-</span><span class="dv">1</span>]</span></code></pre></div>
<p>这里，pandas可以勉强进行整数索引，但是会导致小bug。我们有包含0,1,2的索引，但是引入用户想要的东西（基于标签或位置的索引）很难：</p>
<div class="sourceCode" id="cb60"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb60-1"><a href="#cb60-1"></a>In [<span class="dv">144</span>]: ser</span>
<span id="cb60-2"><a href="#cb60-2"></a>Out[<span class="dv">144</span>]: </span>
<span id="cb60-3"><a href="#cb60-3"></a><span class="dv">0</span>    <span class="fl">0.0</span></span>
<span id="cb60-4"><a href="#cb60-4"></a><span class="dv">1</span>    <span class="fl">1.0</span></span>
<span id="cb60-5"><a href="#cb60-5"></a><span class="dv">2</span>    <span class="fl">2.0</span></span>
<span id="cb60-6"><a href="#cb60-6"></a>dtype: float64</span></code></pre></div>
<p>另外，对于非整数索引，不会产生歧义：</p>
<div class="sourceCode" id="cb61"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb61-1"><a href="#cb61-1"></a>In [<span class="dv">145</span>]: ser2 <span class="op">=</span> pd.Series(np.arange(<span class="fl">3.</span>), index<span class="op">=</span>[<span class="st">&#39;a&#39;</span>, <span class="st">&#39;b&#39;</span>, <span class="st">&#39;c&#39;</span>])</span>
<span id="cb61-2"><a href="#cb61-2"></a></span>
<span id="cb61-3"><a href="#cb61-3"></a>In [<span class="dv">146</span>]: ser2[<span class="op">-</span><span class="dv">1</span>]</span>
<span id="cb61-4"><a href="#cb61-4"></a>Out[<span class="dv">146</span>]: <span class="fl">2.0</span></span></code></pre></div>
<p>为了进行统一，如果轴索引含有整数，数据选取总会使用标签。为了更准确，请使用loc（标签）或iloc（整数）：</p>
<div class="sourceCode" id="cb62"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb62-1"><a href="#cb62-1"></a>In [<span class="dv">147</span>]: ser[:<span class="dv">1</span>]</span>
<span id="cb62-2"><a href="#cb62-2"></a>Out[<span class="dv">147</span>]: </span>
<span id="cb62-3"><a href="#cb62-3"></a><span class="dv">0</span>    <span class="fl">0.0</span></span>
<span id="cb62-4"><a href="#cb62-4"></a>dtype: float64</span>
<span id="cb62-5"><a href="#cb62-5"></a></span>
<span id="cb62-6"><a href="#cb62-6"></a>In [<span class="dv">148</span>]: ser.loc[:<span class="dv">1</span>]</span>
<span id="cb62-7"><a href="#cb62-7"></a>Out[<span class="dv">148</span>]: </span>
<span id="cb62-8"><a href="#cb62-8"></a><span class="dv">0</span>    <span class="fl">0.0</span></span>
<span id="cb62-9"><a href="#cb62-9"></a><span class="dv">1</span>    <span class="fl">1.0</span></span>
<span id="cb62-10"><a href="#cb62-10"></a>dtype: float64</span>
<span id="cb62-11"><a href="#cb62-11"></a></span>
<span id="cb62-12"><a href="#cb62-12"></a>In [<span class="dv">149</span>]: ser.iloc[:<span class="dv">1</span>]</span>
<span id="cb62-13"><a href="#cb62-13"></a>Out[<span class="dv">149</span>]: </span>
<span id="cb62-14"><a href="#cb62-14"></a><span class="dv">0</span>    <span class="fl">0.0</span></span>
<span id="cb62-15"><a href="#cb62-15"></a>dtype: float64</span></code></pre></div>
<h2 id="算术运算和数据对齐">算术运算和数据对齐</h2>
<p>pandas最重要的一个功能是，它可以对不同索引的对象进行算术运算。在将对象相加时，如果存在不同的索引对，则结果的索引就是该索引对的并集。对于有数据库经验的用户，这就像在索引标签上进行自动外连接。看一个简单的例子：</p>
<div class="sourceCode" id="cb63"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb63-1"><a href="#cb63-1"></a>In [<span class="dv">150</span>]: s1 <span class="op">=</span> pd.Series([<span class="fl">7.3</span>, <span class="op">-</span><span class="fl">2.5</span>, <span class="fl">3.4</span>, <span class="fl">1.5</span>], index<span class="op">=</span>[<span class="st">&#39;a&#39;</span>, <span class="st">&#39;c&#39;</span>, <span class="st">&#39;d&#39;</span>, <span class="st">&#39;e&#39;</span>])</span>
<span id="cb63-2"><a href="#cb63-2"></a></span>
<span id="cb63-3"><a href="#cb63-3"></a>In [<span class="dv">151</span>]: s2 <span class="op">=</span> pd.Series([<span class="op">-</span><span class="fl">2.1</span>, <span class="fl">3.6</span>, <span class="op">-</span><span class="fl">1.5</span>, <span class="dv">4</span>, <span class="fl">3.1</span>],</span>
<span id="cb63-4"><a href="#cb63-4"></a>   .....:                index<span class="op">=</span>[<span class="st">&#39;a&#39;</span>, <span class="st">&#39;c&#39;</span>, <span class="st">&#39;e&#39;</span>, <span class="st">&#39;f&#39;</span>, <span class="st">&#39;g&#39;</span>])</span>
<span id="cb63-5"><a href="#cb63-5"></a></span>
<span id="cb63-6"><a href="#cb63-6"></a>In [<span class="dv">152</span>]: s1</span>
<span id="cb63-7"><a href="#cb63-7"></a>Out[<span class="dv">152</span>]: </span>
<span id="cb63-8"><a href="#cb63-8"></a>a    <span class="fl">7.3</span></span>
<span id="cb63-9"><a href="#cb63-9"></a>c   <span class="op">-</span><span class="fl">2.5</span></span>
<span id="cb63-10"><a href="#cb63-10"></a>d    <span class="fl">3.4</span></span>
<span id="cb63-11"><a href="#cb63-11"></a>e    <span class="fl">1.5</span></span>
<span id="cb63-12"><a href="#cb63-12"></a>dtype: float64</span>
<span id="cb63-13"><a href="#cb63-13"></a></span>
<span id="cb63-14"><a href="#cb63-14"></a>In [<span class="dv">153</span>]: s2</span>
<span id="cb63-15"><a href="#cb63-15"></a>Out[<span class="dv">153</span>]: </span>
<span id="cb63-16"><a href="#cb63-16"></a>a   <span class="op">-</span><span class="fl">2.1</span></span>
<span id="cb63-17"><a href="#cb63-17"></a>c    <span class="fl">3.6</span></span>
<span id="cb63-18"><a href="#cb63-18"></a>e   <span class="op">-</span><span class="fl">1.5</span></span>
<span id="cb63-19"><a href="#cb63-19"></a>f    <span class="fl">4.0</span></span>
<span id="cb63-20"><a href="#cb63-20"></a>g    <span class="fl">3.1</span></span>
<span id="cb63-21"><a href="#cb63-21"></a>dtype: float64</span></code></pre></div>
<p>将它们相加就会产生：</p>
<div class="sourceCode" id="cb64"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb64-1"><a href="#cb64-1"></a>In [<span class="dv">154</span>]: s1 <span class="op">+</span> s2</span>
<span id="cb64-2"><a href="#cb64-2"></a>Out[<span class="dv">154</span>]: </span>
<span id="cb64-3"><a href="#cb64-3"></a>a    <span class="fl">5.2</span></span>
<span id="cb64-4"><a href="#cb64-4"></a>c    <span class="fl">1.1</span></span>
<span id="cb64-5"><a href="#cb64-5"></a>d    NaN</span>
<span id="cb64-6"><a href="#cb64-6"></a>e    <span class="fl">0.0</span></span>
<span id="cb64-7"><a href="#cb64-7"></a>f    NaN</span>
<span id="cb64-8"><a href="#cb64-8"></a>g    NaN</span>
<span id="cb64-9"><a href="#cb64-9"></a>dtype: float64</span></code></pre></div>
<p>自动的数据对齐操作在不重叠的索引处引入了NA值。缺失值会在算术运算过程中传播。</p>
<p>对于DataFrame，对齐操作会同时发生在行和列上：</p>
<div class="sourceCode" id="cb65"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb65-1"><a href="#cb65-1"></a>In [<span class="dv">155</span>]: df1 <span class="op">=</span> pd.DataFrame(np.arange(<span class="fl">9.</span>).reshape((<span class="dv">3</span>, <span class="dv">3</span>)), columns<span class="op">=</span><span class="bu">list</span>(<span class="st">&#39;bcd&#39;</span>),</span>
<span id="cb65-2"><a href="#cb65-2"></a>   .....:                    index<span class="op">=</span>[<span class="st">&#39;Ohio&#39;</span>, <span class="st">&#39;Texas&#39;</span>, <span class="st">&#39;Colorado&#39;</span>])</span>
<span id="cb65-3"><a href="#cb65-3"></a></span>
<span id="cb65-4"><a href="#cb65-4"></a>In [<span class="dv">156</span>]: df2 <span class="op">=</span> pd.DataFrame(np.arange(<span class="fl">12.</span>).reshape((<span class="dv">4</span>, <span class="dv">3</span>)), columns<span class="op">=</span><span class="bu">list</span>(<span class="st">&#39;bde&#39;</span>),</span>
<span id="cb65-5"><a href="#cb65-5"></a>   .....:                    index<span class="op">=</span>[<span class="st">&#39;Utah&#39;</span>, <span class="st">&#39;Ohio&#39;</span>, <span class="st">&#39;Texas&#39;</span>, <span class="st">&#39;Oregon&#39;</span>])</span>
<span id="cb65-6"><a href="#cb65-6"></a></span>
<span id="cb65-7"><a href="#cb65-7"></a>In [<span class="dv">157</span>]: df1</span>
<span id="cb65-8"><a href="#cb65-8"></a>Out[<span class="dv">157</span>]: </span>
<span id="cb65-9"><a href="#cb65-9"></a>            b    c    d</span>
<span id="cb65-10"><a href="#cb65-10"></a>Ohio      <span class="fl">0.0</span>  <span class="fl">1.0</span>  <span class="fl">2.0</span></span>
<span id="cb65-11"><a href="#cb65-11"></a>Texas     <span class="fl">3.0</span>  <span class="fl">4.0</span>  <span class="fl">5.0</span></span>
<span id="cb65-12"><a href="#cb65-12"></a>Colorado  <span class="fl">6.0</span>  <span class="fl">7.0</span>  <span class="fl">8.0</span></span>
<span id="cb65-13"><a href="#cb65-13"></a></span>
<span id="cb65-14"><a href="#cb65-14"></a>In [<span class="dv">158</span>]: df2</span>
<span id="cb65-15"><a href="#cb65-15"></a>Out[<span class="dv">158</span>]: </span>
<span id="cb65-16"><a href="#cb65-16"></a>          b     d     e</span>
<span id="cb65-17"><a href="#cb65-17"></a>Utah    <span class="fl">0.0</span>   <span class="fl">1.0</span>   <span class="fl">2.0</span></span>
<span id="cb65-18"><a href="#cb65-18"></a>Ohio    <span class="fl">3.0</span>   <span class="fl">4.0</span>   <span class="fl">5.0</span></span>
<span id="cb65-19"><a href="#cb65-19"></a>Texas   <span class="fl">6.0</span>   <span class="fl">7.0</span>   <span class="fl">8.0</span></span>
<span id="cb65-20"><a href="#cb65-20"></a>Oregon  <span class="fl">9.0</span>  <span class="fl">10.0</span>  <span class="fl">11.0</span></span></code></pre></div>
<p>把它们相加后将会返回一个新的DataFrame，其索引和列为原来那两个DataFrame的并集：</p>
<div class="sourceCode" id="cb66"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb66-1"><a href="#cb66-1"></a>In [<span class="dv">159</span>]: df1 <span class="op">+</span> df2</span>
<span id="cb66-2"><a href="#cb66-2"></a>Out[<span class="dv">159</span>]: </span>
<span id="cb66-3"><a href="#cb66-3"></a>            b   c     d   e</span>
<span id="cb66-4"><a href="#cb66-4"></a>Colorado  NaN NaN   NaN NaN</span>
<span id="cb66-5"><a href="#cb66-5"></a>Ohio      <span class="fl">3.0</span> NaN   <span class="fl">6.0</span> NaN</span>
<span id="cb66-6"><a href="#cb66-6"></a>Oregon    NaN NaN   NaN NaN</span>
<span id="cb66-7"><a href="#cb66-7"></a>Texas     <span class="fl">9.0</span> NaN  <span class="fl">12.0</span> NaN</span>
<span id="cb66-8"><a href="#cb66-8"></a>Utah      NaN NaN   NaN NaN</span></code></pre></div>
<p>因为’c’和’e’列均不在两个DataFrame对象中，在结果中以缺省值呈现。行也是同样。</p>
<p>如果DataFrame对象相加，没有共用的列或行标签，结果都会是空：</p>
<div class="sourceCode" id="cb67"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb67-1"><a href="#cb67-1"></a>In [<span class="dv">160</span>]: df1 <span class="op">=</span> pd.DataFrame({<span class="st">&#39;A&#39;</span>: [<span class="dv">1</span>, <span class="dv">2</span>]})</span>
<span id="cb67-2"><a href="#cb67-2"></a></span>
<span id="cb67-3"><a href="#cb67-3"></a>In [<span class="dv">161</span>]: df2 <span class="op">=</span> pd.DataFrame({<span class="st">&#39;B&#39;</span>: [<span class="dv">3</span>, <span class="dv">4</span>]})</span>
<span id="cb67-4"><a href="#cb67-4"></a></span>
<span id="cb67-5"><a href="#cb67-5"></a>In [<span class="dv">162</span>]: df1</span>
<span id="cb67-6"><a href="#cb67-6"></a>Out[<span class="dv">162</span>]: </span>
<span id="cb67-7"><a href="#cb67-7"></a>   A</span>
<span id="cb67-8"><a href="#cb67-8"></a><span class="dv">0</span>  <span class="dv">1</span></span>
<span id="cb67-9"><a href="#cb67-9"></a><span class="dv">1</span>  <span class="dv">2</span></span>
<span id="cb67-10"><a href="#cb67-10"></a></span>
<span id="cb67-11"><a href="#cb67-11"></a>In [<span class="dv">163</span>]: df2</span>
<span id="cb67-12"><a href="#cb67-12"></a>Out[<span class="dv">163</span>]: </span>
<span id="cb67-13"><a href="#cb67-13"></a>   B</span>
<span id="cb67-14"><a href="#cb67-14"></a><span class="dv">0</span>  <span class="dv">3</span></span>
<span id="cb67-15"><a href="#cb67-15"></a><span class="dv">1</span>  <span class="dv">4</span></span>
<span id="cb67-16"><a href="#cb67-16"></a></span>
<span id="cb67-17"><a href="#cb67-17"></a>In [<span class="dv">164</span>]: df1 <span class="op">-</span> df2</span>
<span id="cb67-18"><a href="#cb67-18"></a>Out[<span class="dv">164</span>]: </span>
<span id="cb67-19"><a href="#cb67-19"></a>    A   B</span>
<span id="cb67-20"><a href="#cb67-20"></a><span class="dv">0</span> NaN NaN</span>
<span id="cb67-21"><a href="#cb67-21"></a><span class="dv">1</span> NaN NaN</span></code></pre></div>
<h2 id="在算术方法中填充值">在算术方法中填充值</h2>
<p>在对不同索引的对象进行算术运算时，你可能希望当一个对象中某个轴标签在另一个对象中找不到时填充一个特殊值（比如0）：</p>
<div class="sourceCode" id="cb68"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb68-1"><a href="#cb68-1"></a>In [<span class="dv">165</span>]: df1 <span class="op">=</span> pd.DataFrame(np.arange(<span class="fl">12.</span>).reshape((<span class="dv">3</span>, <span class="dv">4</span>)),</span>
<span id="cb68-2"><a href="#cb68-2"></a>   .....:                    columns<span class="op">=</span><span class="bu">list</span>(<span class="st">&#39;abcd&#39;</span>))</span>
<span id="cb68-3"><a href="#cb68-3"></a></span>
<span id="cb68-4"><a href="#cb68-4"></a>In [<span class="dv">166</span>]: df2 <span class="op">=</span> pd.DataFrame(np.arange(<span class="fl">20.</span>).reshape((<span class="dv">4</span>, <span class="dv">5</span>)),</span>
<span id="cb68-5"><a href="#cb68-5"></a>   .....:                    columns<span class="op">=</span><span class="bu">list</span>(<span class="st">&#39;abcde&#39;</span>))</span>
<span id="cb68-6"><a href="#cb68-6"></a></span>
<span id="cb68-7"><a href="#cb68-7"></a>In [<span class="dv">167</span>]: df2.loc[<span class="dv">1</span>, <span class="st">&#39;b&#39;</span>] <span class="op">=</span> np.nan</span>
<span id="cb68-8"><a href="#cb68-8"></a></span>
<span id="cb68-9"><a href="#cb68-9"></a>In [<span class="dv">168</span>]: df1</span>
<span id="cb68-10"><a href="#cb68-10"></a>Out[<span class="dv">168</span>]: </span>
<span id="cb68-11"><a href="#cb68-11"></a>     a    b     c     d</span>
<span id="cb68-12"><a href="#cb68-12"></a><span class="dv">0</span>  <span class="fl">0.0</span>  <span class="fl">1.0</span>   <span class="fl">2.0</span>   <span class="fl">3.0</span></span>
<span id="cb68-13"><a href="#cb68-13"></a><span class="dv">1</span>  <span class="fl">4.0</span>  <span class="fl">5.0</span>   <span class="fl">6.0</span>   <span class="fl">7.0</span></span>
<span id="cb68-14"><a href="#cb68-14"></a><span class="dv">2</span>  <span class="fl">8.0</span>  <span class="fl">9.0</span>  <span class="fl">10.0</span>  <span class="fl">11.0</span></span>
<span id="cb68-15"><a href="#cb68-15"></a></span>
<span id="cb68-16"><a href="#cb68-16"></a>In [<span class="dv">169</span>]: df2</span>
<span id="cb68-17"><a href="#cb68-17"></a>Out[<span class="dv">169</span>]: </span>
<span id="cb68-18"><a href="#cb68-18"></a>      a     b     c     d     e</span>
<span id="cb68-19"><a href="#cb68-19"></a><span class="dv">0</span>   <span class="fl">0.0</span>   <span class="fl">1.0</span>   <span class="fl">2.0</span>   <span class="fl">3.0</span>   <span class="fl">4.0</span></span>
<span id="cb68-20"><a href="#cb68-20"></a><span class="dv">1</span>   <span class="fl">5.0</span>   NaN   <span class="fl">7.0</span>   <span class="fl">8.0</span>   <span class="fl">9.0</span></span>
<span id="cb68-21"><a href="#cb68-21"></a><span class="dv">2</span>  <span class="fl">10.0</span>  <span class="fl">11.0</span>  <span class="fl">12.0</span>  <span class="fl">13.0</span>  <span class="fl">14.0</span></span>
<span id="cb68-22"><a href="#cb68-22"></a><span class="dv">3</span>  <span class="fl">15.0</span>  <span class="fl">16.0</span>  <span class="fl">17.0</span>  <span class="fl">18.0</span>  <span class="fl">19.0</span></span></code></pre></div>
<p>将它们相加时，没有重叠的位置就会产生NA值：</p>
<div class="sourceCode" id="cb69"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb69-1"><a href="#cb69-1"></a>In [<span class="dv">170</span>]: df1 <span class="op">+</span> df2</span>
<span id="cb69-2"><a href="#cb69-2"></a>Out[<span class="dv">170</span>]: </span>
<span id="cb69-3"><a href="#cb69-3"></a>      a     b     c     d   e</span>
<span id="cb69-4"><a href="#cb69-4"></a><span class="dv">0</span>   <span class="fl">0.0</span>   <span class="fl">2.0</span>   <span class="fl">4.0</span>   <span class="fl">6.0</span> NaN</span>
<span id="cb69-5"><a href="#cb69-5"></a><span class="dv">1</span>   <span class="fl">9.0</span>   NaN  <span class="fl">13.0</span>  <span class="fl">15.0</span> NaN</span>
<span id="cb69-6"><a href="#cb69-6"></a><span class="dv">2</span>  <span class="fl">18.0</span>  <span class="fl">20.0</span>  <span class="fl">22.0</span>  <span class="fl">24.0</span> NaN</span>
<span id="cb69-7"><a href="#cb69-7"></a><span class="dv">3</span>   NaN   NaN   NaN   NaN NaN</span></code></pre></div>
<p>使用df1的add方法，传入df2以及一个fill_value参数：</p>
<div class="sourceCode" id="cb70"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb70-1"><a href="#cb70-1"></a>In [<span class="dv">171</span>]: df1.add(df2, fill_value<span class="op">=</span><span class="dv">0</span>)</span>
<span id="cb70-2"><a href="#cb70-2"></a>Out[<span class="dv">171</span>]: </span>
<span id="cb70-3"><a href="#cb70-3"></a>      a     b     c     d     e</span>
<span id="cb70-4"><a href="#cb70-4"></a><span class="dv">0</span>   <span class="fl">0.0</span>   <span class="fl">2.0</span>   <span class="fl">4.0</span>   <span class="fl">6.0</span>   <span class="fl">4.0</span></span>
<span id="cb70-5"><a href="#cb70-5"></a><span class="dv">1</span>   <span class="fl">9.0</span>   <span class="fl">5.0</span>  <span class="fl">13.0</span>  <span class="fl">15.0</span>   <span class="fl">9.0</span></span>
<span id="cb70-6"><a href="#cb70-6"></a><span class="dv">2</span>  <span class="fl">18.0</span>  <span class="fl">20.0</span>  <span class="fl">22.0</span>  <span class="fl">24.0</span>  <span class="fl">14.0</span></span>
<span id="cb70-7"><a href="#cb70-7"></a><span class="dv">3</span>  <span class="fl">15.0</span>  <span class="fl">16.0</span>  <span class="fl">17.0</span>  <span class="fl">18.0</span>  <span class="fl">19.0</span></span></code></pre></div>
<p>表5-5列出了Series和DataFrame的算术方法。它们每个都有一个副本，以字母r开头，它会翻转参数。因此这两个语句是等价的：</p>
<div class="sourceCode" id="cb71"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb71-1"><a href="#cb71-1"></a>In [<span class="dv">172</span>]: <span class="dv">1</span> <span class="op">/</span> df1</span>
<span id="cb71-2"><a href="#cb71-2"></a>Out[<span class="dv">172</span>]: </span>
<span id="cb71-3"><a href="#cb71-3"></a>          a         b         c         d</span>
<span id="cb71-4"><a href="#cb71-4"></a><span class="dv">0</span>       inf  <span class="fl">1.000000</span>  <span class="fl">0.500000</span>  <span class="fl">0.333333</span></span>
<span id="cb71-5"><a href="#cb71-5"></a><span class="dv">1</span>  <span class="fl">0.250000</span>  <span class="fl">0.200000</span>  <span class="fl">0.166667</span>  <span class="fl">0.142857</span></span>
<span id="cb71-6"><a href="#cb71-6"></a><span class="dv">2</span>  <span class="fl">0.125000</span>  <span class="fl">0.111111</span>  <span class="fl">0.100000</span>  <span class="fl">0.090909</span></span>
<span id="cb71-7"><a href="#cb71-7"></a></span>
<span id="cb71-8"><a href="#cb71-8"></a>In [<span class="dv">173</span>]: df1.rdiv(<span class="dv">1</span>)</span>
<span id="cb71-9"><a href="#cb71-9"></a>Out[<span class="dv">173</span>]: </span>
<span id="cb71-10"><a href="#cb71-10"></a>          a         b         c         d</span>
<span id="cb71-11"><a href="#cb71-11"></a><span class="dv">0</span>       inf  <span class="fl">1.000000</span>  <span class="fl">0.500000</span>  <span class="fl">0.333333</span></span>
<span id="cb71-12"><a href="#cb71-12"></a><span class="dv">1</span>  <span class="fl">0.250000</span>  <span class="fl">0.200000</span>  <span class="fl">0.166667</span>  <span class="fl">0.142857</span></span>
<span id="cb71-13"><a href="#cb71-13"></a><span class="dv">2</span>  <span class="fl">0.125000</span>  <span class="fl">0.111111</span>  <span class="fl">0.100000</span>  <span class="fl">0.090909</span></span></code></pre></div>
<figure>
<img src="http://upload-images.jianshu.io/upload_images/7178691-16857a1021f98d1f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="" /><figcaption>表5-5 灵活的算术方法</figcaption>
</figure>
<p>与此类似，在对Series或DataFrame重新索引时，也可以指定一个填充值：</p>
<div class="sourceCode" id="cb72"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb72-1"><a href="#cb72-1"></a>In [<span class="dv">174</span>]: df1.reindex(columns<span class="op">=</span>df2.columns, fill_value<span class="op">=</span><span class="dv">0</span>)</span>
<span id="cb72-2"><a href="#cb72-2"></a>Out[<span class="dv">174</span>]: </span>
<span id="cb72-3"><a href="#cb72-3"></a>     a    b     c     d  e</span>
<span id="cb72-4"><a href="#cb72-4"></a><span class="dv">0</span>  <span class="fl">0.0</span>  <span class="fl">1.0</span>   <span class="fl">2.0</span>   <span class="fl">3.0</span>  <span class="dv">0</span></span>
<span id="cb72-5"><a href="#cb72-5"></a><span class="dv">1</span>  <span class="fl">4.0</span>  <span class="fl">5.0</span>   <span class="fl">6.0</span>   <span class="fl">7.0</span>  <span class="dv">0</span></span>
<span id="cb72-6"><a href="#cb72-6"></a><span class="dv">2</span>  <span class="fl">8.0</span>  <span class="fl">9.0</span>  <span class="fl">10.0</span>  <span class="fl">11.0</span>  <span class="dv">0</span></span></code></pre></div>
<h2 id="dataframe和series之间的运算">DataFrame和Series之间的运算</h2>
<p>跟不同维度的NumPy数组一样，DataFrame和Series之间算术运算也是有明确规定的。先来看一个具有启发性的例子，计算一个二维数组与其某行之间的差：</p>
<div class="sourceCode" id="cb73"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb73-1"><a href="#cb73-1"></a>In [<span class="dv">175</span>]: arr <span class="op">=</span> np.arange(<span class="fl">12.</span>).reshape((<span class="dv">3</span>, <span class="dv">4</span>))</span>
<span id="cb73-2"><a href="#cb73-2"></a></span>
<span id="cb73-3"><a href="#cb73-3"></a>In [<span class="dv">176</span>]: arr</span>
<span id="cb73-4"><a href="#cb73-4"></a>Out[<span class="dv">176</span>]: </span>
<span id="cb73-5"><a href="#cb73-5"></a>array([[  <span class="fl">0.</span>,   <span class="fl">1.</span>,   <span class="fl">2.</span>,   <span class="fl">3.</span>],</span>
<span id="cb73-6"><a href="#cb73-6"></a>       [  <span class="fl">4.</span>,   <span class="fl">5.</span>,   <span class="fl">6.</span>,   <span class="fl">7.</span>],</span>
<span id="cb73-7"><a href="#cb73-7"></a>       [  <span class="fl">8.</span>,   <span class="fl">9.</span>,  <span class="fl">10.</span>,  <span class="fl">11.</span>]])</span>
<span id="cb73-8"><a href="#cb73-8"></a></span>
<span id="cb73-9"><a href="#cb73-9"></a>In [<span class="dv">177</span>]: arr[<span class="dv">0</span>]</span>
<span id="cb73-10"><a href="#cb73-10"></a>Out[<span class="dv">177</span>]: array([ <span class="fl">0.</span>,  <span class="fl">1.</span>,  <span class="fl">2.</span>,  <span class="fl">3.</span>])</span>
<span id="cb73-11"><a href="#cb73-11"></a></span>
<span id="cb73-12"><a href="#cb73-12"></a>In [<span class="dv">178</span>]: arr <span class="op">-</span> arr[<span class="dv">0</span>]</span>
<span id="cb73-13"><a href="#cb73-13"></a>Out[<span class="dv">178</span>]: </span>
<span id="cb73-14"><a href="#cb73-14"></a>array([[ <span class="fl">0.</span>,  <span class="fl">0.</span>,  <span class="fl">0.</span>,  <span class="fl">0.</span>],</span>
<span id="cb73-15"><a href="#cb73-15"></a>       [ <span class="fl">4.</span>,  <span class="fl">4.</span>,  <span class="fl">4.</span>,  <span class="fl">4.</span>],</span>
<span id="cb73-16"><a href="#cb73-16"></a>       [ <span class="fl">8.</span>,  <span class="fl">8.</span>,  <span class="fl">8.</span>,  <span class="fl">8.</span>]])</span></code></pre></div>
<p>当我们从arr减去arr[0]，每一行都会执行这个操作。这就叫做广播（broadcasting），附录A将对此进行详细讲解。DataFrame和Series之间的运算差不多也是如此：</p>
<div class="sourceCode" id="cb74"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb74-1"><a href="#cb74-1"></a>In [<span class="dv">179</span>]: frame <span class="op">=</span> pd.DataFrame(np.arange(<span class="fl">12.</span>).reshape((<span class="dv">4</span>, <span class="dv">3</span>)),</span>
<span id="cb74-2"><a href="#cb74-2"></a>   .....:                      columns<span class="op">=</span><span class="bu">list</span>(<span class="st">&#39;bde&#39;</span>),</span>
<span id="cb74-3"><a href="#cb74-3"></a>   .....:                      index<span class="op">=</span>[<span class="st">&#39;Utah&#39;</span>, <span class="st">&#39;Ohio&#39;</span>, <span class="st">&#39;Texas&#39;</span>, <span class="st">&#39;Oregon&#39;</span>])</span>
<span id="cb74-4"><a href="#cb74-4"></a></span>
<span id="cb74-5"><a href="#cb74-5"></a>In [<span class="dv">180</span>]: series <span class="op">=</span> frame.iloc[<span class="dv">0</span>]</span>
<span id="cb74-6"><a href="#cb74-6"></a></span>
<span id="cb74-7"><a href="#cb74-7"></a>In [<span class="dv">181</span>]: frame</span>
<span id="cb74-8"><a href="#cb74-8"></a>Out[<span class="dv">181</span>]: </span>
<span id="cb74-9"><a href="#cb74-9"></a>          b     d     e</span>
<span id="cb74-10"><a href="#cb74-10"></a>Utah    <span class="fl">0.0</span>   <span class="fl">1.0</span>   <span class="fl">2.0</span></span>
<span id="cb74-11"><a href="#cb74-11"></a>Ohio    <span class="fl">3.0</span>   <span class="fl">4.0</span>   <span class="fl">5.0</span></span>
<span id="cb74-12"><a href="#cb74-12"></a>Texas   <span class="fl">6.0</span>   <span class="fl">7.0</span>   <span class="fl">8.0</span></span>
<span id="cb74-13"><a href="#cb74-13"></a>Oregon  <span class="fl">9.0</span>  <span class="fl">10.0</span>  <span class="fl">11.0</span></span>
<span id="cb74-14"><a href="#cb74-14"></a></span>
<span id="cb74-15"><a href="#cb74-15"></a>In [<span class="dv">182</span>]: series</span>
<span id="cb74-16"><a href="#cb74-16"></a>Out[<span class="dv">182</span>]: </span>
<span id="cb74-17"><a href="#cb74-17"></a>b    <span class="fl">0.0</span></span>
<span id="cb74-18"><a href="#cb74-18"></a>d    <span class="fl">1.0</span></span>
<span id="cb74-19"><a href="#cb74-19"></a>e    <span class="fl">2.0</span></span>
<span id="cb74-20"><a href="#cb74-20"></a>Name: Utah, dtype: float64</span></code></pre></div>
<p>默认情况下，DataFrame和Series之间的算术运算会将Series的索引匹配到DataFrame的列，然后沿着行一直向下广播：</p>
<div class="sourceCode" id="cb75"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb75-1"><a href="#cb75-1"></a>In [<span class="dv">183</span>]: frame <span class="op">-</span> series</span>
<span id="cb75-2"><a href="#cb75-2"></a>Out[<span class="dv">183</span>]: </span>
<span id="cb75-3"><a href="#cb75-3"></a>          b    d    e</span>
<span id="cb75-4"><a href="#cb75-4"></a>Utah    <span class="fl">0.0</span>  <span class="fl">0.0</span>  <span class="fl">0.0</span></span>
<span id="cb75-5"><a href="#cb75-5"></a>Ohio    <span class="fl">3.0</span>  <span class="fl">3.0</span>  <span class="fl">3.0</span></span>
<span id="cb75-6"><a href="#cb75-6"></a>Texas   <span class="fl">6.0</span>  <span class="fl">6.0</span>  <span class="fl">6.0</span></span>
<span id="cb75-7"><a href="#cb75-7"></a>Oregon  <span class="fl">9.0</span>  <span class="fl">9.0</span>  <span class="fl">9.0</span></span></code></pre></div>
<p>如果某个索引值在DataFrame的列或Series的索引中找不到，则参与运算的两个对象就会被重新索引以形成并集：</p>
<div class="sourceCode" id="cb76"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb76-1"><a href="#cb76-1"></a>In [<span class="dv">184</span>]: series2 <span class="op">=</span> pd.Series(<span class="bu">range</span>(<span class="dv">3</span>), index<span class="op">=</span>[<span class="st">&#39;b&#39;</span>, <span class="st">&#39;e&#39;</span>, <span class="st">&#39;f&#39;</span>])</span>
<span id="cb76-2"><a href="#cb76-2"></a></span>
<span id="cb76-3"><a href="#cb76-3"></a>In [<span class="dv">185</span>]: frame <span class="op">+</span> series2</span>
<span id="cb76-4"><a href="#cb76-4"></a>Out[<span class="dv">185</span>]: </span>
<span id="cb76-5"><a href="#cb76-5"></a>          b   d     e   f</span>
<span id="cb76-6"><a href="#cb76-6"></a>Utah    <span class="fl">0.0</span> NaN   <span class="fl">3.0</span> NaN</span>
<span id="cb76-7"><a href="#cb76-7"></a>Ohio    <span class="fl">3.0</span> NaN   <span class="fl">6.0</span> NaN</span>
<span id="cb76-8"><a href="#cb76-8"></a>Texas   <span class="fl">6.0</span> NaN   <span class="fl">9.0</span> NaN</span>
<span id="cb76-9"><a href="#cb76-9"></a>Oregon  <span class="fl">9.0</span> NaN  <span class="fl">12.0</span> NaN</span></code></pre></div>
<p>如果你希望匹配行且在列上广播，则必须使用算术运算方法。例如：</p>
<div class="sourceCode" id="cb77"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb77-1"><a href="#cb77-1"></a>In [<span class="dv">186</span>]: series3 <span class="op">=</span> frame[<span class="st">&#39;d&#39;</span>]</span>
<span id="cb77-2"><a href="#cb77-2"></a></span>
<span id="cb77-3"><a href="#cb77-3"></a>In [<span class="dv">187</span>]: frame</span>
<span id="cb77-4"><a href="#cb77-4"></a>Out[<span class="dv">187</span>]: </span>
<span id="cb77-5"><a href="#cb77-5"></a>          b     d     e</span>
<span id="cb77-6"><a href="#cb77-6"></a>Utah    <span class="fl">0.0</span>   <span class="fl">1.0</span>   <span class="fl">2.0</span></span>
<span id="cb77-7"><a href="#cb77-7"></a>Ohio    <span class="fl">3.0</span>   <span class="fl">4.0</span>   <span class="fl">5.0</span></span>
<span id="cb77-8"><a href="#cb77-8"></a>Texas   <span class="fl">6.0</span>   <span class="fl">7.0</span>   <span class="fl">8.0</span></span>
<span id="cb77-9"><a href="#cb77-9"></a>Oregon  <span class="fl">9.0</span>  <span class="fl">10.0</span>  <span class="fl">11.0</span></span>
<span id="cb77-10"><a href="#cb77-10"></a></span>
<span id="cb77-11"><a href="#cb77-11"></a>In [<span class="dv">188</span>]: series3</span>
<span id="cb77-12"><a href="#cb77-12"></a>Out[<span class="dv">188</span>]: </span>
<span id="cb77-13"><a href="#cb77-13"></a>Utah       <span class="fl">1.0</span></span>
<span id="cb77-14"><a href="#cb77-14"></a>Ohio       <span class="fl">4.0</span></span>
<span id="cb77-15"><a href="#cb77-15"></a>Texas      <span class="fl">7.0</span></span>
<span id="cb77-16"><a href="#cb77-16"></a>Oregon    <span class="fl">10.0</span></span>
<span id="cb77-17"><a href="#cb77-17"></a>Name: d, dtype: float64</span>
<span id="cb77-18"><a href="#cb77-18"></a></span>
<span id="cb77-19"><a href="#cb77-19"></a>In [<span class="dv">189</span>]: frame.sub(series3, axis<span class="op">=</span><span class="st">&#39;index&#39;</span>)</span>
<span id="cb77-20"><a href="#cb77-20"></a>Out[<span class="dv">189</span>]: </span>
<span id="cb77-21"><a href="#cb77-21"></a>          b    d    e</span>
<span id="cb77-22"><a href="#cb77-22"></a>Utah   <span class="op">-</span><span class="fl">1.0</span>  <span class="fl">0.0</span>  <span class="fl">1.0</span></span>
<span id="cb77-23"><a href="#cb77-23"></a>Ohio   <span class="op">-</span><span class="fl">1.0</span>  <span class="fl">0.0</span>  <span class="fl">1.0</span></span>
<span id="cb77-24"><a href="#cb77-24"></a>Texas  <span class="op">-</span><span class="fl">1.0</span>  <span class="fl">0.0</span>  <span class="fl">1.0</span></span>
<span id="cb77-25"><a href="#cb77-25"></a>Oregon <span class="op">-</span><span class="fl">1.0</span>  <span class="fl">0.0</span>  <span class="fl">1.0</span></span></code></pre></div>
<p>传入的轴号就是希望匹配的轴。在本例中，我们的目的是匹配DataFrame的行索引（axis=‘index’ or axis=0）并进行广播。</p>
<h2 id="函数应用和映射">函数应用和映射</h2>
<p>NumPy的ufuncs（元素级数组方法）也可用于操作pandas对象：</p>
<div class="sourceCode" id="cb78"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb78-1"><a href="#cb78-1"></a>In [<span class="dv">190</span>]: frame <span class="op">=</span> pd.DataFrame(np.random.randn(<span class="dv">4</span>, <span class="dv">3</span>), columns<span class="op">=</span><span class="bu">list</span>(<span class="st">&#39;bde&#39;</span>),</span>
<span id="cb78-2"><a href="#cb78-2"></a>   .....:                      index<span class="op">=</span>[<span class="st">&#39;Utah&#39;</span>, <span class="st">&#39;Ohio&#39;</span>, <span class="st">&#39;Texas&#39;</span>, <span class="st">&#39;Oregon&#39;</span>])</span>
<span id="cb78-3"><a href="#cb78-3"></a></span>
<span id="cb78-4"><a href="#cb78-4"></a>In [<span class="dv">191</span>]: frame</span>
<span id="cb78-5"><a href="#cb78-5"></a>Out[<span class="dv">191</span>]: </span>
<span id="cb78-6"><a href="#cb78-6"></a>               b         d         e</span>
<span id="cb78-7"><a href="#cb78-7"></a>Utah   <span class="op">-</span><span class="fl">0.204708</span>  <span class="fl">0.478943</span> <span class="op">-</span><span class="fl">0.519439</span></span>
<span id="cb78-8"><a href="#cb78-8"></a>Ohio   <span class="op">-</span><span class="fl">0.555730</span>  <span class="fl">1.965781</span>  <span class="fl">1.393406</span></span>
<span id="cb78-9"><a href="#cb78-9"></a>Texas   <span class="fl">0.092908</span>  <span class="fl">0.281746</span>  <span class="fl">0.769023</span></span>
<span id="cb78-10"><a href="#cb78-10"></a>Oregon  <span class="fl">1.246435</span>  <span class="fl">1.007189</span> <span class="op">-</span><span class="fl">1.296221</span></span>
<span id="cb78-11"><a href="#cb78-11"></a></span>
<span id="cb78-12"><a href="#cb78-12"></a>In [<span class="dv">192</span>]: np.<span class="bu">abs</span>(frame)</span>
<span id="cb78-13"><a href="#cb78-13"></a>Out[<span class="dv">192</span>]: </span>
<span id="cb78-14"><a href="#cb78-14"></a>               b         d         e</span>
<span id="cb78-15"><a href="#cb78-15"></a>Utah    <span class="fl">0.204708</span>  <span class="fl">0.478943</span>  <span class="fl">0.519439</span></span>
<span id="cb78-16"><a href="#cb78-16"></a>Ohio    <span class="fl">0.555730</span>  <span class="fl">1.965781</span>  <span class="fl">1.393406</span></span>
<span id="cb78-17"><a href="#cb78-17"></a>Texas   <span class="fl">0.092908</span>  <span class="fl">0.281746</span>  <span class="fl">0.769023</span></span>
<span id="cb78-18"><a href="#cb78-18"></a>Oregon  <span class="fl">1.246435</span>  <span class="fl">1.007189</span>  <span class="fl">1.296221</span></span></code></pre></div>
<p>另一个常见的操作是，将函数应用到由各列或行所形成的一维数组上。DataFrame的apply方法即可实现此功能：</p>
<div class="sourceCode" id="cb79"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb79-1"><a href="#cb79-1"></a>In [<span class="dv">193</span>]: f <span class="op">=</span> <span class="kw">lambda</span> x: x.<span class="bu">max</span>() <span class="op">-</span> x.<span class="bu">min</span>()</span>
<span id="cb79-2"><a href="#cb79-2"></a></span>
<span id="cb79-3"><a href="#cb79-3"></a>In [<span class="dv">194</span>]: frame.<span class="bu">apply</span>(f)</span>
<span id="cb79-4"><a href="#cb79-4"></a>Out[<span class="dv">194</span>]: </span>
<span id="cb79-5"><a href="#cb79-5"></a>b    <span class="fl">1.802165</span></span>
<span id="cb79-6"><a href="#cb79-6"></a>d    <span class="fl">1.684034</span></span>
<span id="cb79-7"><a href="#cb79-7"></a>e    <span class="fl">2.689627</span></span>
<span id="cb79-8"><a href="#cb79-8"></a>dtype: float64</span></code></pre></div>
<p>这里的函数f，计算了一个Series的最大值和最小值的差，在frame的每列都执行了一次。结果是一个Series，使用frame的列作为索引。</p>
<p>如果传递axis=’columns’到apply，这个函数会在每行执行：</p>
<div class="sourceCode" id="cb80"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb80-1"><a href="#cb80-1"></a>In [<span class="dv">195</span>]: frame.<span class="bu">apply</span>(f, axis<span class="op">=</span><span class="st">&#39;columns&#39;</span>)</span>
<span id="cb80-2"><a href="#cb80-2"></a>Out[<span class="dv">195</span>]:</span>
<span id="cb80-3"><a href="#cb80-3"></a>Utah      <span class="fl">0.998382</span></span>
<span id="cb80-4"><a href="#cb80-4"></a>Ohio      <span class="fl">2.521511</span></span>
<span id="cb80-5"><a href="#cb80-5"></a>Texas     <span class="fl">0.676115</span></span>
<span id="cb80-6"><a href="#cb80-6"></a>Oregon    <span class="fl">2.542656</span></span>
<span id="cb80-7"><a href="#cb80-7"></a>dtype: float64</span></code></pre></div>
<p>许多最为常见的数组统计功能都被实现成DataFrame的方法（如sum和mean），因此无需使用apply方法。</p>
<p>传递到apply的函数不是必须返回一个标量，还可以返回由多个值组成的Series：</p>
<div class="sourceCode" id="cb81"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb81-1"><a href="#cb81-1"></a>In [<span class="dv">196</span>]: <span class="kw">def</span> f(x):</span>
<span id="cb81-2"><a href="#cb81-2"></a>   .....:     <span class="cf">return</span> pd.Series([x.<span class="bu">min</span>(), x.<span class="bu">max</span>()], index<span class="op">=</span>[<span class="st">&#39;min&#39;</span>, <span class="st">&#39;max&#39;</span>])</span>
<span id="cb81-3"><a href="#cb81-3"></a></span>
<span id="cb81-4"><a href="#cb81-4"></a>In [<span class="dv">197</span>]: frame.<span class="bu">apply</span>(f)</span>
<span id="cb81-5"><a href="#cb81-5"></a>Out[<span class="dv">197</span>]: </span>
<span id="cb81-6"><a href="#cb81-6"></a>            b         d         e</span>
<span id="cb81-7"><a href="#cb81-7"></a><span class="bu">min</span> <span class="op">-</span><span class="fl">0.555730</span>  <span class="fl">0.281746</span> <span class="op">-</span><span class="fl">1.296221</span></span>
<span id="cb81-8"><a href="#cb81-8"></a><span class="bu">max</span>  <span class="fl">1.246435</span>  <span class="fl">1.965781</span>  <span class="fl">1.393406</span></span></code></pre></div>
<p>元素级的Python函数也是可以用的。假如你想得到frame中各个浮点值的格式化字符串，使用applymap即可：</p>
<div class="sourceCode" id="cb82"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb82-1"><a href="#cb82-1"></a>In [<span class="dv">198</span>]: <span class="bu">format</span> <span class="op">=</span> <span class="kw">lambda</span> x: <span class="st">&#39;</span><span class="sc">%.2f</span><span class="st">&#39;</span> <span class="op">%</span> x</span>
<span id="cb82-2"><a href="#cb82-2"></a></span>
<span id="cb82-3"><a href="#cb82-3"></a>In [<span class="dv">199</span>]: frame.applymap(<span class="bu">format</span>)</span>
<span id="cb82-4"><a href="#cb82-4"></a>Out[<span class="dv">199</span>]: </span>
<span id="cb82-5"><a href="#cb82-5"></a>            b     d      e</span>
<span id="cb82-6"><a href="#cb82-6"></a>Utah    <span class="op">-</span><span class="fl">0.20</span>  <span class="fl">0.48</span>  <span class="op">-</span><span class="fl">0.52</span></span>
<span id="cb82-7"><a href="#cb82-7"></a>Ohio    <span class="op">-</span><span class="fl">0.56</span>  <span class="fl">1.97</span>   <span class="fl">1.39</span></span>
<span id="cb82-8"><a href="#cb82-8"></a>Texas    <span class="fl">0.09</span>  <span class="fl">0.28</span>   <span class="fl">0.77</span></span>
<span id="cb82-9"><a href="#cb82-9"></a>Oregon   <span class="fl">1.25</span>  <span class="fl">1.01</span>  <span class="op">-</span><span class="fl">1.30</span></span></code></pre></div>
<p>之所以叫做applymap，是因为Series有一个用于应用元素级函数的map方法：</p>
<div class="sourceCode" id="cb83"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb83-1"><a href="#cb83-1"></a>In [<span class="dv">200</span>]: frame[<span class="st">&#39;e&#39;</span>].<span class="bu">map</span>(<span class="bu">format</span>)</span>
<span id="cb83-2"><a href="#cb83-2"></a>Out[<span class="dv">200</span>]: </span>
<span id="cb83-3"><a href="#cb83-3"></a>Utah      <span class="op">-</span><span class="fl">0.52</span></span>
<span id="cb83-4"><a href="#cb83-4"></a>Ohio       <span class="fl">1.39</span></span>
<span id="cb83-5"><a href="#cb83-5"></a>Texas      <span class="fl">0.77</span></span>
<span id="cb83-6"><a href="#cb83-6"></a>Oregon    <span class="op">-</span><span class="fl">1.30</span></span>
<span id="cb83-7"><a href="#cb83-7"></a>Name: e, dtype: <span class="bu">object</span></span></code></pre></div>
<h2 id="排序和排名">排序和排名</h2>
<p>根据条件对数据集排序（sorting）也是一种重要的内置运算。要对行或列索引进行排序（按字典顺序），可使用sort_index方法，它将返回一个已排序的新对象：</p>
<div class="sourceCode" id="cb84"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb84-1"><a href="#cb84-1"></a>In [<span class="dv">201</span>]: obj <span class="op">=</span> pd.Series(<span class="bu">range</span>(<span class="dv">4</span>), index<span class="op">=</span>[<span class="st">&#39;d&#39;</span>, <span class="st">&#39;a&#39;</span>, <span class="st">&#39;b&#39;</span>, <span class="st">&#39;c&#39;</span>])</span>
<span id="cb84-2"><a href="#cb84-2"></a></span>
<span id="cb84-3"><a href="#cb84-3"></a>In [<span class="dv">202</span>]: obj.sort_index()</span>
<span id="cb84-4"><a href="#cb84-4"></a>Out[<span class="dv">202</span>]:</span>
<span id="cb84-5"><a href="#cb84-5"></a>a    <span class="dv">1</span></span>
<span id="cb84-6"><a href="#cb84-6"></a>b    <span class="dv">2</span></span>
<span id="cb84-7"><a href="#cb84-7"></a>c    <span class="dv">3</span></span>
<span id="cb84-8"><a href="#cb84-8"></a>d    <span class="dv">0</span></span>
<span id="cb84-9"><a href="#cb84-9"></a>dtype: int64</span></code></pre></div>
<p>对于DataFrame，则可以根据任意一个轴上的索引进行排序：</p>
<div class="sourceCode" id="cb85"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb85-1"><a href="#cb85-1"></a>In [<span class="dv">203</span>]: frame <span class="op">=</span> pd.DataFrame(np.arange(<span class="dv">8</span>).reshape((<span class="dv">2</span>, <span class="dv">4</span>)),</span>
<span id="cb85-2"><a href="#cb85-2"></a>   .....:                      index<span class="op">=</span>[<span class="st">&#39;three&#39;</span>, <span class="st">&#39;one&#39;</span>],</span>
<span id="cb85-3"><a href="#cb85-3"></a>   .....:                      columns<span class="op">=</span>[<span class="st">&#39;d&#39;</span>, <span class="st">&#39;a&#39;</span>, <span class="st">&#39;b&#39;</span>, <span class="st">&#39;c&#39;</span>])</span>
<span id="cb85-4"><a href="#cb85-4"></a></span>
<span id="cb85-5"><a href="#cb85-5"></a>In [<span class="dv">204</span>]: frame.sort_index()</span>
<span id="cb85-6"><a href="#cb85-6"></a>Out[<span class="dv">204</span>]: </span>
<span id="cb85-7"><a href="#cb85-7"></a>       d  a  b  c</span>
<span id="cb85-8"><a href="#cb85-8"></a>one    <span class="dv">4</span>  <span class="dv">5</span>  <span class="dv">6</span>  <span class="dv">7</span></span>
<span id="cb85-9"><a href="#cb85-9"></a>three  <span class="dv">0</span>  <span class="dv">1</span>  <span class="dv">2</span>  <span class="dv">3</span></span>
<span id="cb85-10"><a href="#cb85-10"></a></span>
<span id="cb85-11"><a href="#cb85-11"></a>In [<span class="dv">205</span>]: frame.sort_index(axis<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb85-12"><a href="#cb85-12"></a>Out[<span class="dv">205</span>]:</span>
<span id="cb85-13"><a href="#cb85-13"></a>       a  b  c  d</span>
<span id="cb85-14"><a href="#cb85-14"></a>three  <span class="dv">1</span>  <span class="dv">2</span>  <span class="dv">3</span>  <span class="dv">0</span></span>
<span id="cb85-15"><a href="#cb85-15"></a>one    <span class="dv">5</span>  <span class="dv">6</span>  <span class="dv">7</span>  <span class="dv">4</span></span></code></pre></div>
<p>数据默认是按升序排序的，但也可以降序排序：</p>
<div class="sourceCode" id="cb86"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb86-1"><a href="#cb86-1"></a>In [<span class="dv">206</span>]: frame.sort_index(axis<span class="op">=</span><span class="dv">1</span>, ascending<span class="op">=</span><span class="va">False</span>)</span>
<span id="cb86-2"><a href="#cb86-2"></a>Out[<span class="dv">206</span>]: </span>
<span id="cb86-3"><a href="#cb86-3"></a>       d  c  b  a</span>
<span id="cb86-4"><a href="#cb86-4"></a>three  <span class="dv">0</span>  <span class="dv">3</span>  <span class="dv">2</span>  <span class="dv">1</span></span>
<span id="cb86-5"><a href="#cb86-5"></a>one    <span class="dv">4</span>  <span class="dv">7</span>  <span class="dv">6</span>  <span class="dv">5</span></span></code></pre></div>
<p>若要按值对Series进行排序，可使用其sort_values方法：</p>
<div class="sourceCode" id="cb87"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb87-1"><a href="#cb87-1"></a>In [<span class="dv">207</span>]: obj <span class="op">=</span> pd.Series([<span class="dv">4</span>, <span class="dv">7</span>, <span class="op">-</span><span class="dv">3</span>, <span class="dv">2</span>])</span>
<span id="cb87-2"><a href="#cb87-2"></a></span>
<span id="cb87-3"><a href="#cb87-3"></a>In [<span class="dv">208</span>]: obj.sort_values()</span>
<span id="cb87-4"><a href="#cb87-4"></a>Out[<span class="dv">208</span>]: </span>
<span id="cb87-5"><a href="#cb87-5"></a><span class="dv">2</span>   <span class="op">-</span><span class="dv">3</span></span>
<span id="cb87-6"><a href="#cb87-6"></a><span class="dv">3</span>    <span class="dv">2</span></span>
<span id="cb87-7"><a href="#cb87-7"></a><span class="dv">0</span>    <span class="dv">4</span></span>
<span id="cb87-8"><a href="#cb87-8"></a><span class="dv">1</span>    <span class="dv">7</span></span>
<span id="cb87-9"><a href="#cb87-9"></a>dtype: int64</span></code></pre></div>
<p>在排序时，任何缺失值默认都会被放到Series的末尾：</p>
<div class="sourceCode" id="cb88"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb88-1"><a href="#cb88-1"></a>In [<span class="dv">209</span>]: obj <span class="op">=</span> pd.Series([<span class="dv">4</span>, np.nan, <span class="dv">7</span>, np.nan, <span class="op">-</span><span class="dv">3</span>, <span class="dv">2</span>])</span>
<span id="cb88-2"><a href="#cb88-2"></a></span>
<span id="cb88-3"><a href="#cb88-3"></a>In [<span class="dv">210</span>]: obj.sort_values()</span>
<span id="cb88-4"><a href="#cb88-4"></a>Out[<span class="dv">210</span>]: </span>
<span id="cb88-5"><a href="#cb88-5"></a><span class="dv">4</span>   <span class="op">-</span><span class="fl">3.0</span></span>
<span id="cb88-6"><a href="#cb88-6"></a><span class="dv">5</span>    <span class="fl">2.0</span></span>
<span id="cb88-7"><a href="#cb88-7"></a><span class="dv">0</span>    <span class="fl">4.0</span></span>
<span id="cb88-8"><a href="#cb88-8"></a><span class="dv">2</span>    <span class="fl">7.0</span></span>
<span id="cb88-9"><a href="#cb88-9"></a><span class="dv">1</span>    NaN</span>
<span id="cb88-10"><a href="#cb88-10"></a><span class="dv">3</span>    NaN</span>
<span id="cb88-11"><a href="#cb88-11"></a>dtype: float64</span></code></pre></div>
<p>当排序一个DataFrame时，你可能希望根据一个或多个列中的值进行排序。将一个或多个列的名字传递给sort_values的by选项即可达到该目的：</p>
<div class="sourceCode" id="cb89"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb89-1"><a href="#cb89-1"></a>In [<span class="dv">211</span>]: frame <span class="op">=</span> pd.DataFrame({<span class="st">&#39;b&#39;</span>: [<span class="dv">4</span>, <span class="dv">7</span>, <span class="op">-</span><span class="dv">3</span>, <span class="dv">2</span>], <span class="st">&#39;a&#39;</span>: [<span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">0</span>, <span class="dv">1</span>]})</span>
<span id="cb89-2"><a href="#cb89-2"></a></span>
<span id="cb89-3"><a href="#cb89-3"></a>In [<span class="dv">212</span>]: frame</span>
<span id="cb89-4"><a href="#cb89-4"></a>Out[<span class="dv">212</span>]: </span>
<span id="cb89-5"><a href="#cb89-5"></a>   a  b</span>
<span id="cb89-6"><a href="#cb89-6"></a><span class="dv">0</span>  <span class="dv">0</span>  <span class="dv">4</span></span>
<span id="cb89-7"><a href="#cb89-7"></a><span class="dv">1</span>  <span class="dv">1</span>  <span class="dv">7</span></span>
<span id="cb89-8"><a href="#cb89-8"></a><span class="dv">2</span>  <span class="dv">0</span> <span class="op">-</span><span class="dv">3</span></span>
<span id="cb89-9"><a href="#cb89-9"></a><span class="dv">3</span>  <span class="dv">1</span>  <span class="dv">2</span></span>
<span id="cb89-10"><a href="#cb89-10"></a></span>
<span id="cb89-11"><a href="#cb89-11"></a>In [<span class="dv">213</span>]: frame.sort_values(by<span class="op">=</span><span class="st">&#39;b&#39;</span>)</span>
<span id="cb89-12"><a href="#cb89-12"></a>Out[<span class="dv">213</span>]: </span>
<span id="cb89-13"><a href="#cb89-13"></a>   a  b</span>
<span id="cb89-14"><a href="#cb89-14"></a><span class="dv">2</span>  <span class="dv">0</span> <span class="op">-</span><span class="dv">3</span></span>
<span id="cb89-15"><a href="#cb89-15"></a><span class="dv">3</span>  <span class="dv">1</span>  <span class="dv">2</span></span>
<span id="cb89-16"><a href="#cb89-16"></a><span class="dv">0</span>  <span class="dv">0</span>  <span class="dv">4</span></span>
<span id="cb89-17"><a href="#cb89-17"></a><span class="dv">1</span>  <span class="dv">1</span>  <span class="dv">7</span></span></code></pre></div>
<p>要根据多个列进行排序，传入名称的列表即可：</p>
<div class="sourceCode" id="cb90"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb90-1"><a href="#cb90-1"></a>In [<span class="dv">214</span>]: frame.sort_values(by<span class="op">=</span>[<span class="st">&#39;a&#39;</span>, <span class="st">&#39;b&#39;</span>])</span>
<span id="cb90-2"><a href="#cb90-2"></a>Out[<span class="dv">214</span>]: </span>
<span id="cb90-3"><a href="#cb90-3"></a>   a  b</span>
<span id="cb90-4"><a href="#cb90-4"></a><span class="dv">2</span>  <span class="dv">0</span> <span class="op">-</span><span class="dv">3</span></span>
<span id="cb90-5"><a href="#cb90-5"></a><span class="dv">0</span>  <span class="dv">0</span>  <span class="dv">4</span></span>
<span id="cb90-6"><a href="#cb90-6"></a><span class="dv">3</span>  <span class="dv">1</span>  <span class="dv">2</span></span>
<span id="cb90-7"><a href="#cb90-7"></a><span class="dv">1</span>  <span class="dv">1</span>  <span class="dv">7</span></span></code></pre></div>
<p>排名会从1开始一直到数组中有效数据的数量。接下来介绍Series和DataFrame的rank方法。默认情况下，rank是通过“为各组分配一个平均排名”的方式破坏平级关系的：</p>
<div class="sourceCode" id="cb91"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb91-1"><a href="#cb91-1"></a>In [<span class="dv">215</span>]: obj <span class="op">=</span> pd.Series([<span class="dv">7</span>, <span class="op">-</span><span class="dv">5</span>, <span class="dv">7</span>, <span class="dv">4</span>, <span class="dv">2</span>, <span class="dv">0</span>, <span class="dv">4</span>])</span>
<span id="cb91-2"><a href="#cb91-2"></a>In [<span class="dv">216</span>]: obj.rank()</span>
<span id="cb91-3"><a href="#cb91-3"></a>Out[<span class="dv">216</span>]: </span>
<span id="cb91-4"><a href="#cb91-4"></a><span class="dv">0</span>    <span class="fl">6.5</span></span>
<span id="cb91-5"><a href="#cb91-5"></a><span class="dv">1</span>    <span class="fl">1.0</span></span>
<span id="cb91-6"><a href="#cb91-6"></a><span class="dv">2</span>    <span class="fl">6.5</span></span>
<span id="cb91-7"><a href="#cb91-7"></a><span class="dv">3</span>    <span class="fl">4.5</span></span>
<span id="cb91-8"><a href="#cb91-8"></a><span class="dv">4</span>    <span class="fl">3.0</span></span>
<span id="cb91-9"><a href="#cb91-9"></a><span class="dv">5</span>    <span class="fl">2.0</span></span>
<span id="cb91-10"><a href="#cb91-10"></a><span class="dv">6</span>    <span class="fl">4.5</span></span>
<span id="cb91-11"><a href="#cb91-11"></a>dtype: float64</span></code></pre></div>
<p>也可以根据值在原数据中出现的顺序给出排名：</p>
<div class="sourceCode" id="cb92"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb92-1"><a href="#cb92-1"></a>In [<span class="dv">217</span>]: obj.rank(method<span class="op">=</span><span class="st">&#39;first&#39;</span>)</span>
<span id="cb92-2"><a href="#cb92-2"></a>Out[<span class="dv">217</span>]: </span>
<span id="cb92-3"><a href="#cb92-3"></a><span class="dv">0</span>    <span class="fl">6.0</span></span>
<span id="cb92-4"><a href="#cb92-4"></a><span class="dv">1</span>    <span class="fl">1.0</span></span>
<span id="cb92-5"><a href="#cb92-5"></a><span class="dv">2</span>    <span class="fl">7.0</span></span>
<span id="cb92-6"><a href="#cb92-6"></a><span class="dv">3</span>    <span class="fl">4.0</span></span>
<span id="cb92-7"><a href="#cb92-7"></a><span class="dv">4</span>    <span class="fl">3.0</span></span>
<span id="cb92-8"><a href="#cb92-8"></a><span class="dv">5</span>    <span class="fl">2.0</span></span>
<span id="cb92-9"><a href="#cb92-9"></a><span class="dv">6</span>    <span class="fl">5.0</span></span>
<span id="cb92-10"><a href="#cb92-10"></a>dtype: float64</span></code></pre></div>
<p>这里，条目0和2没有使用平均排名6.5，它们被设成了6和7，因为数据中标签0位于标签2的前面。</p>
<p>你也可以按降序进行排名：</p>
<div class="sourceCode" id="cb93"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb93-1"><a href="#cb93-1"></a><span class="co"># Assign tie values the maximum rank in the group</span></span>
<span id="cb93-2"><a href="#cb93-2"></a>In [<span class="dv">218</span>]: obj.rank(ascending<span class="op">=</span><span class="va">False</span>, method<span class="op">=</span><span class="st">&#39;max&#39;</span>)</span>
<span id="cb93-3"><a href="#cb93-3"></a>Out[<span class="dv">218</span>]: </span>
<span id="cb93-4"><a href="#cb93-4"></a><span class="dv">0</span>    <span class="fl">2.0</span></span>
<span id="cb93-5"><a href="#cb93-5"></a><span class="dv">1</span>    <span class="fl">7.0</span></span>
<span id="cb93-6"><a href="#cb93-6"></a><span class="dv">2</span>    <span class="fl">2.0</span></span>
<span id="cb93-7"><a href="#cb93-7"></a><span class="dv">3</span>    <span class="fl">4.0</span></span>
<span id="cb93-8"><a href="#cb93-8"></a><span class="dv">4</span>    <span class="fl">5.0</span></span>
<span id="cb93-9"><a href="#cb93-9"></a><span class="dv">5</span>    <span class="fl">6.0</span></span>
<span id="cb93-10"><a href="#cb93-10"></a><span class="dv">6</span>    <span class="fl">4.0</span></span>
<span id="cb93-11"><a href="#cb93-11"></a>dtype: float64</span></code></pre></div>
<p>表5-6列出了所有用于破坏平级关系的method选项。DataFrame可以在行或列上计算排名：</p>
<div class="sourceCode" id="cb94"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb94-1"><a href="#cb94-1"></a>In [<span class="dv">219</span>]: frame <span class="op">=</span> pd.DataFrame({<span class="st">&#39;b&#39;</span>: [<span class="fl">4.3</span>, <span class="dv">7</span>, <span class="op">-</span><span class="dv">3</span>, <span class="dv">2</span>], <span class="st">&#39;a&#39;</span>: [<span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">0</span>, <span class="dv">1</span>],</span>
<span id="cb94-2"><a href="#cb94-2"></a>   .....:                       <span class="st">&#39;c&#39;</span>: [<span class="op">-</span><span class="dv">2</span>, <span class="dv">5</span>, <span class="dv">8</span>, <span class="op">-</span><span class="fl">2.5</span>]})</span>
<span id="cb94-3"><a href="#cb94-3"></a></span>
<span id="cb94-4"><a href="#cb94-4"></a>In [<span class="dv">220</span>]: frame</span>
<span id="cb94-5"><a href="#cb94-5"></a>Out[<span class="dv">220</span>]: </span>
<span id="cb94-6"><a href="#cb94-6"></a>   a    b    c</span>
<span id="cb94-7"><a href="#cb94-7"></a><span class="dv">0</span>  <span class="dv">0</span>  <span class="fl">4.3</span> <span class="op">-</span><span class="fl">2.0</span></span>
<span id="cb94-8"><a href="#cb94-8"></a><span class="dv">1</span>  <span class="dv">1</span>  <span class="fl">7.0</span>  <span class="fl">5.0</span></span>
<span id="cb94-9"><a href="#cb94-9"></a><span class="dv">2</span>  <span class="dv">0</span> <span class="op">-</span><span class="fl">3.0</span>  <span class="fl">8.0</span></span>
<span id="cb94-10"><a href="#cb94-10"></a><span class="dv">3</span>  <span class="dv">1</span>  <span class="fl">2.0</span> <span class="op">-</span><span class="fl">2.5</span></span>
<span id="cb94-11"><a href="#cb94-11"></a></span>
<span id="cb94-12"><a href="#cb94-12"></a>In [<span class="dv">221</span>]: frame.rank(axis<span class="op">=</span><span class="st">&#39;columns&#39;</span>)</span>
<span id="cb94-13"><a href="#cb94-13"></a>Out[<span class="dv">221</span>]: </span>
<span id="cb94-14"><a href="#cb94-14"></a>     a    b    c</span>
<span id="cb94-15"><a href="#cb94-15"></a><span class="dv">0</span>  <span class="fl">2.0</span>  <span class="fl">3.0</span>  <span class="fl">1.0</span></span>
<span id="cb94-16"><a href="#cb94-16"></a><span class="dv">1</span>  <span class="fl">1.0</span>  <span class="fl">3.0</span>  <span class="fl">2.0</span></span>
<span id="cb94-17"><a href="#cb94-17"></a><span class="dv">2</span>  <span class="fl">2.0</span>  <span class="fl">1.0</span>  <span class="fl">3.0</span></span>
<span id="cb94-18"><a href="#cb94-18"></a><span class="dv">3</span>  <span class="fl">2.0</span>  <span class="fl">3.0</span>  <span class="fl">1.0</span></span></code></pre></div>
<figure>
<img src="http://upload-images.jianshu.io/upload_images/7178691-7edfab5b4a147581.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="" /><figcaption>表5-6 排名时用于破坏平级关系的方法</figcaption>
</figure>
<h2 id="带有重复标签的轴索引">带有重复标签的轴索引</h2>
<p>直到目前为止，我所介绍的所有范例都有着唯一的轴标签（索引值）。虽然许多pandas函数（如reindex）都要求标签唯一，但这并不是强制性的。我们来看看下面这个简单的带有重复索引值的Series：</p>
<div class="sourceCode" id="cb95"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb95-1"><a href="#cb95-1"></a>In [<span class="dv">222</span>]: obj <span class="op">=</span> pd.Series(<span class="bu">range</span>(<span class="dv">5</span>), index<span class="op">=</span>[<span class="st">&#39;a&#39;</span>, <span class="st">&#39;a&#39;</span>, <span class="st">&#39;b&#39;</span>, <span class="st">&#39;b&#39;</span>, <span class="st">&#39;c&#39;</span>])</span>
<span id="cb95-2"><a href="#cb95-2"></a></span>
<span id="cb95-3"><a href="#cb95-3"></a>In [<span class="dv">223</span>]: obj</span>
<span id="cb95-4"><a href="#cb95-4"></a>Out[<span class="dv">223</span>]: </span>
<span id="cb95-5"><a href="#cb95-5"></a>a    <span class="dv">0</span></span>
<span id="cb95-6"><a href="#cb95-6"></a>a    <span class="dv">1</span></span>
<span id="cb95-7"><a href="#cb95-7"></a>b    <span class="dv">2</span></span>
<span id="cb95-8"><a href="#cb95-8"></a>b    <span class="dv">3</span></span>
<span id="cb95-9"><a href="#cb95-9"></a>c    <span class="dv">4</span></span>
<span id="cb95-10"><a href="#cb95-10"></a>dtype: int64</span></code></pre></div>
<p>索引的is_unique属性可以告诉你它的值是否是唯一的：</p>
<div class="sourceCode" id="cb96"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb96-1"><a href="#cb96-1"></a>In [<span class="dv">224</span>]: obj.index.is_unique</span>
<span id="cb96-2"><a href="#cb96-2"></a>Out[<span class="dv">224</span>]: <span class="va">False</span></span></code></pre></div>
<p>对于带有重复值的索引，数据选取的行为将会有些不同。如果某个索引对应多个值，则返回一个Series；而对应单个值的，则返回一个标量值：</p>
<div class="sourceCode" id="cb97"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb97-1"><a href="#cb97-1"></a>In [<span class="dv">225</span>]: obj[<span class="st">&#39;a&#39;</span>]</span>
<span id="cb97-2"><a href="#cb97-2"></a>Out[<span class="dv">225</span>]: </span>
<span id="cb97-3"><a href="#cb97-3"></a>a    <span class="dv">0</span></span>
<span id="cb97-4"><a href="#cb97-4"></a>a    <span class="dv">1</span></span>
<span id="cb97-5"><a href="#cb97-5"></a>dtype: int64</span>
<span id="cb97-6"><a href="#cb97-6"></a></span>
<span id="cb97-7"><a href="#cb97-7"></a>In [<span class="dv">226</span>]: obj[<span class="st">&#39;c&#39;</span>]</span>
<span id="cb97-8"><a href="#cb97-8"></a>Out[<span class="dv">226</span>]: <span class="dv">4</span></span></code></pre></div>
<p>这样会使代码变复杂，因为索引的输出类型会根据标签是否有重复发生变化。</p>
<p>对DataFrame的行进行索引时也是如此：</p>
<div class="sourceCode" id="cb98"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb98-1"><a href="#cb98-1"></a>In [<span class="dv">227</span>]: df <span class="op">=</span> pd.DataFrame(np.random.randn(<span class="dv">4</span>, <span class="dv">3</span>), index<span class="op">=</span>[<span class="st">&#39;a&#39;</span>, <span class="st">&#39;a&#39;</span>, <span class="st">&#39;b&#39;</span>, <span class="st">&#39;b&#39;</span>])</span>
<span id="cb98-2"><a href="#cb98-2"></a></span>
<span id="cb98-3"><a href="#cb98-3"></a>In [<span class="dv">228</span>]: df</span>
<span id="cb98-4"><a href="#cb98-4"></a>Out[<span class="dv">228</span>]: </span>
<span id="cb98-5"><a href="#cb98-5"></a>          <span class="dv">0</span>         <span class="dv">1</span>         <span class="dv">2</span></span>
<span id="cb98-6"><a href="#cb98-6"></a>a  <span class="fl">0.274992</span>  <span class="fl">0.228913</span>  <span class="fl">1.352917</span></span>
<span id="cb98-7"><a href="#cb98-7"></a>a  <span class="fl">0.886429</span> <span class="op">-</span><span class="fl">2.001637</span> <span class="op">-</span><span class="fl">0.371843</span></span>
<span id="cb98-8"><a href="#cb98-8"></a>b  <span class="fl">1.669025</span> <span class="op">-</span><span class="fl">0.438570</span> <span class="op">-</span><span class="fl">0.539741</span></span>
<span id="cb98-9"><a href="#cb98-9"></a>b  <span class="fl">0.476985</span>  <span class="fl">3.248944</span> <span class="op">-</span><span class="fl">1.021228</span></span>
<span id="cb98-10"><a href="#cb98-10"></a></span>
<span id="cb98-11"><a href="#cb98-11"></a>In [<span class="dv">229</span>]: df.loc[<span class="st">&#39;b&#39;</span>]</span>
<span id="cb98-12"><a href="#cb98-12"></a>Out[<span class="dv">229</span>]: </span>
<span id="cb98-13"><a href="#cb98-13"></a>          <span class="dv">0</span>         <span class="dv">1</span>         <span class="dv">2</span></span>
<span id="cb98-14"><a href="#cb98-14"></a>b  <span class="fl">1.669025</span> <span class="op">-</span><span class="fl">0.438570</span> <span class="op">-</span><span class="fl">0.539741</span></span>
<span id="cb98-15"><a href="#cb98-15"></a>b  <span class="fl">0.476985</span>  <span class="fl">3.248944</span> <span class="op">-</span><span class="fl">1.021228</span></span></code></pre></div>
<h1 id="汇总和计算描述统计">5.3 汇总和计算描述统计</h1>
<p>pandas对象拥有一组常用的数学和统计方法。它们大部分都属于约简和汇总统计，用于从Series中提取单个值（如sum或mean）或从DataFrame的行或列中提取一个Series。跟对应的NumPy数组方法相比，它们都是基于没有缺失数据的假设而构建的。看一个简单的DataFrame：</p>
<div class="sourceCode" id="cb99"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb99-1"><a href="#cb99-1"></a>In [<span class="dv">230</span>]: df <span class="op">=</span> pd.DataFrame([[<span class="fl">1.4</span>, np.nan], [<span class="fl">7.1</span>, <span class="op">-</span><span class="fl">4.5</span>],</span>
<span id="cb99-2"><a href="#cb99-2"></a>   .....:                    [np.nan, np.nan], [<span class="fl">0.75</span>, <span class="op">-</span><span class="fl">1.3</span>]],</span>
<span id="cb99-3"><a href="#cb99-3"></a>   .....:                   index<span class="op">=</span>[<span class="st">&#39;a&#39;</span>, <span class="st">&#39;b&#39;</span>, <span class="st">&#39;c&#39;</span>, <span class="st">&#39;d&#39;</span>],</span>
<span id="cb99-4"><a href="#cb99-4"></a>   .....:                   columns<span class="op">=</span>[<span class="st">&#39;one&#39;</span>, <span class="st">&#39;two&#39;</span>])</span>
<span id="cb99-5"><a href="#cb99-5"></a></span>
<span id="cb99-6"><a href="#cb99-6"></a>In [<span class="dv">231</span>]: df</span>
<span id="cb99-7"><a href="#cb99-7"></a>Out[<span class="dv">231</span>]: </span>
<span id="cb99-8"><a href="#cb99-8"></a>    one  two</span>
<span id="cb99-9"><a href="#cb99-9"></a>a  <span class="fl">1.40</span>  NaN</span>
<span id="cb99-10"><a href="#cb99-10"></a>b  <span class="fl">7.10</span> <span class="op">-</span><span class="fl">4.5</span></span>
<span id="cb99-11"><a href="#cb99-11"></a>c   NaN  NaN</span>
<span id="cb99-12"><a href="#cb99-12"></a>d  <span class="fl">0.75</span> <span class="op">-</span><span class="fl">1.3</span></span></code></pre></div>
<p>调用DataFrame的sum方法将会返回一个含有列的和的Series：</p>
<div class="sourceCode" id="cb100"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb100-1"><a href="#cb100-1"></a>In [<span class="dv">232</span>]: df.<span class="bu">sum</span>()</span>
<span id="cb100-2"><a href="#cb100-2"></a>Out[<span class="dv">232</span>]: </span>
<span id="cb100-3"><a href="#cb100-3"></a>one    <span class="fl">9.25</span></span>
<span id="cb100-4"><a href="#cb100-4"></a>two   <span class="op">-</span><span class="fl">5.80</span></span>
<span id="cb100-5"><a href="#cb100-5"></a>dtype: float64</span></code></pre></div>
<p>传入axis=’columns’或axis=1将会按行进行求和运算：</p>
<div class="sourceCode" id="cb101"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb101-1"><a href="#cb101-1"></a>In [<span class="dv">233</span>]: df.<span class="bu">sum</span>(axis<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb101-2"><a href="#cb101-2"></a>Out[<span class="dv">233</span>]:</span>
<span id="cb101-3"><a href="#cb101-3"></a>a    <span class="fl">1.40</span></span>
<span id="cb101-4"><a href="#cb101-4"></a>b    <span class="fl">2.60</span></span>
<span id="cb101-5"><a href="#cb101-5"></a>c     NaN</span>
<span id="cb101-6"><a href="#cb101-6"></a>d   <span class="op">-</span><span class="fl">0.55</span></span></code></pre></div>
<p>NA值会自动被排除，除非整个切片（这里指的是行或列）都是NA。通过skipna选项可以禁用该功能：</p>
<div class="sourceCode" id="cb102"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb102-1"><a href="#cb102-1"></a>In [<span class="dv">234</span>]: df.mean(axis<span class="op">=</span><span class="st">&#39;columns&#39;</span>, skipna<span class="op">=</span><span class="va">False</span>)</span>
<span id="cb102-2"><a href="#cb102-2"></a>Out[<span class="dv">234</span>]: </span>
<span id="cb102-3"><a href="#cb102-3"></a>a      NaN</span>
<span id="cb102-4"><a href="#cb102-4"></a>b    <span class="fl">1.300</span></span>
<span id="cb102-5"><a href="#cb102-5"></a>c      NaN</span>
<span id="cb102-6"><a href="#cb102-6"></a>d   <span class="op">-</span><span class="fl">0.275</span></span>
<span id="cb102-7"><a href="#cb102-7"></a>dtype: float64</span></code></pre></div>
<p>表5-7列出了这些约简方法的常用选项。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/7178691-af35e3809278410e.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" /></p>
<p>有些方法（如idxmin和idxmax）返回的是间接统计（比如达到最小值或最大值的索引）：</p>
<div class="sourceCode" id="cb103"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb103-1"><a href="#cb103-1"></a>In [<span class="dv">235</span>]: df.idxmax()</span>
<span id="cb103-2"><a href="#cb103-2"></a>Out[<span class="dv">235</span>]: </span>
<span id="cb103-3"><a href="#cb103-3"></a>one    b</span>
<span id="cb103-4"><a href="#cb103-4"></a>two    d</span>
<span id="cb103-5"><a href="#cb103-5"></a>dtype: <span class="bu">object</span></span></code></pre></div>
<p>另一些方法则是累计型的：</p>
<div class="sourceCode" id="cb104"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb104-1"><a href="#cb104-1"></a>In [<span class="dv">236</span>]: df.cumsum()</span>
<span id="cb104-2"><a href="#cb104-2"></a>Out[<span class="dv">236</span>]: </span>
<span id="cb104-3"><a href="#cb104-3"></a>    one  two</span>
<span id="cb104-4"><a href="#cb104-4"></a>a  <span class="fl">1.40</span>  NaN</span>
<span id="cb104-5"><a href="#cb104-5"></a>b  <span class="fl">8.50</span> <span class="op">-</span><span class="fl">4.5</span></span>
<span id="cb104-6"><a href="#cb104-6"></a>c   NaN  NaN</span>
<span id="cb104-7"><a href="#cb104-7"></a>d  <span class="fl">9.25</span> <span class="op">-</span><span class="fl">5.8</span></span></code></pre></div>
<p>还有一种方法，它既不是约简型也不是累计型。describe就是一个例子，它用于一次性产生多个汇总统计：</p>
<div class="sourceCode" id="cb105"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb105-1"><a href="#cb105-1"></a>In [<span class="dv">237</span>]: df.describe()</span>
<span id="cb105-2"><a href="#cb105-2"></a>Out[<span class="dv">237</span>]: </span>
<span id="cb105-3"><a href="#cb105-3"></a>            one       two</span>
<span id="cb105-4"><a href="#cb105-4"></a>count  <span class="fl">3.000000</span>  <span class="fl">2.000000</span></span>
<span id="cb105-5"><a href="#cb105-5"></a>mean   <span class="fl">3.083333</span> <span class="op">-</span><span class="fl">2.900000</span></span>
<span id="cb105-6"><a href="#cb105-6"></a>std    <span class="fl">3.493685</span>  <span class="fl">2.262742</span></span>
<span id="cb105-7"><a href="#cb105-7"></a><span class="bu">min</span>    <span class="fl">0.750000</span> <span class="op">-</span><span class="fl">4.500000</span></span>
<span id="cb105-8"><a href="#cb105-8"></a><span class="dv">25</span><span class="op">%</span>    <span class="fl">1.075000</span> <span class="op">-</span><span class="fl">3.700000</span></span>
<span id="cb105-9"><a href="#cb105-9"></a><span class="dv">50</span><span class="op">%</span>    <span class="fl">1.400000</span> <span class="op">-</span><span class="fl">2.900000</span></span>
<span id="cb105-10"><a href="#cb105-10"></a><span class="dv">75</span><span class="op">%</span>    <span class="fl">4.250000</span> <span class="op">-</span><span class="fl">2.100000</span></span>
<span id="cb105-11"><a href="#cb105-11"></a><span class="bu">max</span>    <span class="fl">7.100000</span> <span class="op">-</span><span class="fl">1.300000</span></span></code></pre></div>
<p>对于非数值型数据，describe会产生另外一种汇总统计：</p>
<div class="sourceCode" id="cb106"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb106-1"><a href="#cb106-1"></a>In [<span class="dv">238</span>]: obj <span class="op">=</span> pd.Series([<span class="st">&#39;a&#39;</span>, <span class="st">&#39;a&#39;</span>, <span class="st">&#39;b&#39;</span>, <span class="st">&#39;c&#39;</span>] <span class="op">*</span> <span class="dv">4</span>)</span>
<span id="cb106-2"><a href="#cb106-2"></a></span>
<span id="cb106-3"><a href="#cb106-3"></a>In [<span class="dv">239</span>]: obj.describe()</span>
<span id="cb106-4"><a href="#cb106-4"></a>Out[<span class="dv">239</span>]: </span>
<span id="cb106-5"><a href="#cb106-5"></a>count     <span class="dv">16</span></span>
<span id="cb106-6"><a href="#cb106-6"></a>unique     <span class="dv">3</span></span>
<span id="cb106-7"><a href="#cb106-7"></a>top        a</span>
<span id="cb106-8"><a href="#cb106-8"></a>freq       <span class="dv">8</span></span>
<span id="cb106-9"><a href="#cb106-9"></a>dtype: <span class="bu">object</span></span></code></pre></div>
<p>表5-8列出了所有与描述统计相关的方法。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/7178691-11fa967f658ac314.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" /></p>
<h2 id="相关系数与协方差">相关系数与协方差</h2>
<p>有些汇总统计（如相关系数和协方差）是通过参数对计算出来的。我们来看几个DataFrame，它们的数据来自Yahoo!Finance的股票价格和成交量，使用的是pandas-datareader包（可以用conda或pip安装）：</p>
<div class="sourceCode" id="cb107"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb107-1"><a href="#cb107-1"></a>conda install pandas<span class="op">-</span>datareader</span></code></pre></div>
<p>我使用pandas_datareader模块下载了一些股票数据：</p>
<div class="sourceCode" id="cb108"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb108-1"><a href="#cb108-1"></a><span class="im">import</span> pandas_datareader.data <span class="im">as</span> web</span>
<span id="cb108-2"><a href="#cb108-2"></a>all_data <span class="op">=</span> {ticker: web.get_data_yahoo(ticker)</span>
<span id="cb108-3"><a href="#cb108-3"></a>            <span class="cf">for</span> ticker <span class="kw">in</span> [<span class="st">&#39;AAPL&#39;</span>, <span class="st">&#39;IBM&#39;</span>, <span class="st">&#39;MSFT&#39;</span>, <span class="st">&#39;GOOG&#39;</span>]}</span>
<span id="cb108-4"><a href="#cb108-4"></a></span>
<span id="cb108-5"><a href="#cb108-5"></a>price <span class="op">=</span> pd.DataFrame({ticker: data[<span class="st">&#39;Adj Close&#39;</span>]</span>
<span id="cb108-6"><a href="#cb108-6"></a>                     <span class="cf">for</span> ticker, data <span class="kw">in</span> all_data.items()})</span>
<span id="cb108-7"><a href="#cb108-7"></a>volume <span class="op">=</span> pd.DataFrame({ticker: data[<span class="st">&#39;Volume&#39;</span>]</span>
<span id="cb108-8"><a href="#cb108-8"></a>                      <span class="cf">for</span> ticker, data <span class="kw">in</span> all_data.items()})</span></code></pre></div>
<blockquote>
<p>注意：此时Yahoo! Finance已经不存在了，因为2017年Yahoo!被Verizon收购了。参阅pandas-datareader文档，可以学习最新的功能。</p>
</blockquote>
<p>现在计算价格的百分数变化，时间序列的操作会在第11章介绍：</p>
<div class="sourceCode" id="cb109"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb109-1"><a href="#cb109-1"></a>In [<span class="dv">242</span>]: returns <span class="op">=</span> price.pct_change()</span>
<span id="cb109-2"><a href="#cb109-2"></a></span>
<span id="cb109-3"><a href="#cb109-3"></a>In [<span class="dv">243</span>]: returns.tail()</span>
<span id="cb109-4"><a href="#cb109-4"></a>Out[<span class="dv">243</span>]: </span>
<span id="cb109-5"><a href="#cb109-5"></a>                AAPL      GOOG       IBM      MSFT</span>
<span id="cb109-6"><a href="#cb109-6"></a>Date                                              </span>
<span id="cb109-7"><a href="#cb109-7"></a><span class="dv">2016</span><span class="op">-</span><span class="dv">10</span><span class="op">-</span><span class="dv">17</span> <span class="op">-</span><span class="fl">0.000680</span>  <span class="fl">0.001837</span>  <span class="fl">0.002072</span> <span class="op">-</span><span class="fl">0.003483</span></span>
<span id="cb109-8"><a href="#cb109-8"></a><span class="dv">2016</span><span class="op">-</span><span class="dv">10</span><span class="op">-</span><span class="dv">18</span> <span class="op">-</span><span class="fl">0.000681</span>  <span class="fl">0.019616</span> <span class="op">-</span><span class="fl">0.026168</span>  <span class="fl">0.007690</span></span>
<span id="cb109-9"><a href="#cb109-9"></a><span class="dv">2016</span><span class="op">-</span><span class="dv">10</span><span class="op">-</span><span class="dv">19</span> <span class="op">-</span><span class="fl">0.002979</span>  <span class="fl">0.007846</span>  <span class="fl">0.003583</span> <span class="op">-</span><span class="fl">0.002255</span></span>
<span id="cb109-10"><a href="#cb109-10"></a><span class="dv">2016</span><span class="op">-</span><span class="dv">10</span><span class="op">-</span><span class="dv">20</span> <span class="op">-</span><span class="fl">0.000512</span> <span class="op">-</span><span class="fl">0.005652</span>  <span class="fl">0.001719</span> <span class="op">-</span><span class="fl">0.004867</span></span>
<span id="cb109-11"><a href="#cb109-11"></a><span class="dv">2016</span><span class="op">-</span><span class="dv">10</span><span class="op">-</span><span class="dv">21</span> <span class="op">-</span><span class="fl">0.003930</span>  <span class="fl">0.003011</span> <span class="op">-</span><span class="fl">0.012474</span>  <span class="fl">0.042096</span></span></code></pre></div>
<p>Series的corr方法用于计算两个Series中重叠的、非NA的、按索引对齐的值的相关系数。与此类似，cov用于计算协方差：</p>
<div class="sourceCode" id="cb110"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb110-1"><a href="#cb110-1"></a>In [<span class="dv">244</span>]: returns[<span class="st">&#39;MSFT&#39;</span>].corr(returns[<span class="st">&#39;IBM&#39;</span>])</span>
<span id="cb110-2"><a href="#cb110-2"></a>Out[<span class="dv">244</span>]: <span class="fl">0.49976361144151144</span></span>
<span id="cb110-3"><a href="#cb110-3"></a></span>
<span id="cb110-4"><a href="#cb110-4"></a>In [<span class="dv">245</span>]: returns[<span class="st">&#39;MSFT&#39;</span>].cov(returns[<span class="st">&#39;IBM&#39;</span>])</span>
<span id="cb110-5"><a href="#cb110-5"></a>Out[<span class="dv">245</span>]: <span class="fl">8.8706554797035462e-05</span></span></code></pre></div>
<p>因为MSTF是一个合理的Python属性，我们还可以用更简洁的语法选择列：</p>
<div class="sourceCode" id="cb111"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb111-1"><a href="#cb111-1"></a>In [<span class="dv">246</span>]: returns.MSFT.corr(returns.IBM)</span>
<span id="cb111-2"><a href="#cb111-2"></a>Out[<span class="dv">246</span>]: <span class="fl">0.49976361144151144</span></span></code></pre></div>
<p>另一方面，DataFrame的corr和cov方法将以DataFrame的形式分别返回完整的相关系数或协方差矩阵：</p>
<div class="sourceCode" id="cb112"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb112-1"><a href="#cb112-1"></a>In [<span class="dv">247</span>]: returns.corr()</span>
<span id="cb112-2"><a href="#cb112-2"></a>Out[<span class="dv">247</span>]: </span>
<span id="cb112-3"><a href="#cb112-3"></a>          AAPL      GOOG       IBM      MSFT</span>
<span id="cb112-4"><a href="#cb112-4"></a>AAPL  <span class="fl">1.000000</span>  <span class="fl">0.407919</span>  <span class="fl">0.386817</span>  <span class="fl">0.389695</span></span>
<span id="cb112-5"><a href="#cb112-5"></a>GOOG  <span class="fl">0.407919</span>  <span class="fl">1.000000</span>  <span class="fl">0.405099</span>  <span class="fl">0.465919</span></span>
<span id="cb112-6"><a href="#cb112-6"></a>IBM   <span class="fl">0.386817</span>  <span class="fl">0.405099</span>  <span class="fl">1.000000</span>  <span class="fl">0.499764</span></span>
<span id="cb112-7"><a href="#cb112-7"></a>MSFT  <span class="fl">0.389695</span>  <span class="fl">0.465919</span>  <span class="fl">0.499764</span>  <span class="fl">1.000000</span></span>
<span id="cb112-8"><a href="#cb112-8"></a></span>
<span id="cb112-9"><a href="#cb112-9"></a>In [<span class="dv">248</span>]: returns.cov()</span>
<span id="cb112-10"><a href="#cb112-10"></a>Out[<span class="dv">248</span>]: </span>
<span id="cb112-11"><a href="#cb112-11"></a>          AAPL      GOOG       IBM      MSFT</span>
<span id="cb112-12"><a href="#cb112-12"></a>AAPL  <span class="fl">0.000277</span>  <span class="fl">0.000107</span>  <span class="fl">0.000078</span>  <span class="fl">0.000095</span></span>
<span id="cb112-13"><a href="#cb112-13"></a>GOOG  <span class="fl">0.000107</span>  <span class="fl">0.000251</span>  <span class="fl">0.000078</span>  <span class="fl">0.000108</span></span>
<span id="cb112-14"><a href="#cb112-14"></a>IBM   <span class="fl">0.000078</span>  <span class="fl">0.000078</span>  <span class="fl">0.000146</span>  <span class="fl">0.000089</span></span>
<span id="cb112-15"><a href="#cb112-15"></a>MSFT  <span class="fl">0.000095</span>  <span class="fl">0.000108</span>  <span class="fl">0.000089</span>  <span class="fl">0.000215</span></span></code></pre></div>
<p>利用DataFrame的corrwith方法，你可以计算其列或行跟另一个Series或DataFrame之间的相关系数。传入一个Series将会返回一个相关系数值Series（针对各列进行计算）：</p>
<div class="sourceCode" id="cb113"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb113-1"><a href="#cb113-1"></a>In [<span class="dv">249</span>]: returns.corrwith(returns.IBM)</span>
<span id="cb113-2"><a href="#cb113-2"></a>Out[<span class="dv">249</span>]: </span>
<span id="cb113-3"><a href="#cb113-3"></a>AAPL    <span class="fl">0.386817</span></span>
<span id="cb113-4"><a href="#cb113-4"></a>GOOG    <span class="fl">0.405099</span></span>
<span id="cb113-5"><a href="#cb113-5"></a>IBM     <span class="fl">1.000000</span></span>
<span id="cb113-6"><a href="#cb113-6"></a>MSFT    <span class="fl">0.499764</span></span>
<span id="cb113-7"><a href="#cb113-7"></a>dtype: float64</span></code></pre></div>
<p>传入一个DataFrame则会计算按列名配对的相关系数。这里，我计算百分比变化与成交量的相关系数：</p>
<div class="sourceCode" id="cb114"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb114-1"><a href="#cb114-1"></a>In [<span class="dv">250</span>]: returns.corrwith(volume)</span>
<span id="cb114-2"><a href="#cb114-2"></a>Out[<span class="dv">250</span>]: </span>
<span id="cb114-3"><a href="#cb114-3"></a>AAPL   <span class="op">-</span><span class="fl">0.075565</span></span>
<span id="cb114-4"><a href="#cb114-4"></a>GOOG   <span class="op">-</span><span class="fl">0.007067</span></span>
<span id="cb114-5"><a href="#cb114-5"></a>IBM    <span class="op">-</span><span class="fl">0.204849</span></span>
<span id="cb114-6"><a href="#cb114-6"></a>MSFT   <span class="op">-</span><span class="fl">0.092950</span></span>
<span id="cb114-7"><a href="#cb114-7"></a>dtype: float64</span></code></pre></div>
<p>传入axis=’columns’即可按行进行计算。无论如何，在计算相关系数之前，所有的数据项都会按标签对齐。</p>
<h2 id="唯一值值计数以及成员资格">唯一值、值计数以及成员资格</h2>
<p>还有一类方法可以从一维Series的值中抽取信息。看下面的例子：</p>
<div class="sourceCode" id="cb115"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb115-1"><a href="#cb115-1"></a>In [<span class="dv">251</span>]: obj <span class="op">=</span> pd.Series([<span class="st">&#39;c&#39;</span>, <span class="st">&#39;a&#39;</span>, <span class="st">&#39;d&#39;</span>, <span class="st">&#39;a&#39;</span>, <span class="st">&#39;a&#39;</span>, <span class="st">&#39;b&#39;</span>, <span class="st">&#39;b&#39;</span>, <span class="st">&#39;c&#39;</span>, <span class="st">&#39;c&#39;</span>])</span></code></pre></div>
<p>第一个函数是unique，它可以得到Series中的唯一值数组：</p>
<div class="sourceCode" id="cb116"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb116-1"><a href="#cb116-1"></a>In [<span class="dv">252</span>]: uniques <span class="op">=</span> obj.unique()</span>
<span id="cb116-2"><a href="#cb116-2"></a></span>
<span id="cb116-3"><a href="#cb116-3"></a>In [<span class="dv">253</span>]: uniques</span>
<span id="cb116-4"><a href="#cb116-4"></a>Out[<span class="dv">253</span>]: array([<span class="st">&#39;c&#39;</span>, <span class="st">&#39;a&#39;</span>, <span class="st">&#39;d&#39;</span>, <span class="st">&#39;b&#39;</span>], dtype<span class="op">=</span><span class="bu">object</span>)</span></code></pre></div>
<p>返回的唯一值是未排序的，如果需要的话，可以对结果再次进行排序（uniques.sort()）。相似的，value_counts用于计算一个Series中各值出现的频率：</p>
<div class="sourceCode" id="cb117"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb117-1"><a href="#cb117-1"></a>In [<span class="dv">254</span>]: obj.value_counts()</span>
<span id="cb117-2"><a href="#cb117-2"></a>Out[<span class="dv">254</span>]: </span>
<span id="cb117-3"><a href="#cb117-3"></a>c    <span class="dv">3</span></span>
<span id="cb117-4"><a href="#cb117-4"></a>a    <span class="dv">3</span></span>
<span id="cb117-5"><a href="#cb117-5"></a>b    <span class="dv">2</span></span>
<span id="cb117-6"><a href="#cb117-6"></a>d    <span class="dv">1</span></span>
<span id="cb117-7"><a href="#cb117-7"></a>dtype: int64</span></code></pre></div>
<p>为了便于查看，结果Series是按值频率降序排列的。value_counts还是一个顶级pandas方法，可用于任何数组或序列：</p>
<div class="sourceCode" id="cb118"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb118-1"><a href="#cb118-1"></a>In [<span class="dv">255</span>]: pd.value_counts(obj.values, sort<span class="op">=</span><span class="va">False</span>)</span>
<span id="cb118-2"><a href="#cb118-2"></a>Out[<span class="dv">255</span>]: </span>
<span id="cb118-3"><a href="#cb118-3"></a>a    <span class="dv">3</span></span>
<span id="cb118-4"><a href="#cb118-4"></a>b    <span class="dv">2</span></span>
<span id="cb118-5"><a href="#cb118-5"></a>c    <span class="dv">3</span></span>
<span id="cb118-6"><a href="#cb118-6"></a>d    <span class="dv">1</span></span>
<span id="cb118-7"><a href="#cb118-7"></a>dtype: int64</span></code></pre></div>
<p>isin用于判断矢量化集合的成员资格，可用于过滤Series中或DataFrame列中数据的子集：</p>
<div class="sourceCode" id="cb119"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb119-1"><a href="#cb119-1"></a>In [<span class="dv">256</span>]: obj</span>
<span id="cb119-2"><a href="#cb119-2"></a>Out[<span class="dv">256</span>]: </span>
<span id="cb119-3"><a href="#cb119-3"></a><span class="dv">0</span>    c</span>
<span id="cb119-4"><a href="#cb119-4"></a><span class="dv">1</span>    a</span>
<span id="cb119-5"><a href="#cb119-5"></a><span class="dv">2</span>    d</span>
<span id="cb119-6"><a href="#cb119-6"></a><span class="dv">3</span>    a</span>
<span id="cb119-7"><a href="#cb119-7"></a><span class="dv">4</span>    a</span>
<span id="cb119-8"><a href="#cb119-8"></a><span class="dv">5</span>    b</span>
<span id="cb119-9"><a href="#cb119-9"></a><span class="dv">6</span>    b</span>
<span id="cb119-10"><a href="#cb119-10"></a><span class="dv">7</span>    c</span>
<span id="cb119-11"><a href="#cb119-11"></a><span class="dv">8</span>    c</span>
<span id="cb119-12"><a href="#cb119-12"></a>dtype: <span class="bu">object</span></span>
<span id="cb119-13"><a href="#cb119-13"></a></span>
<span id="cb119-14"><a href="#cb119-14"></a>In [<span class="dv">257</span>]: mask <span class="op">=</span> obj.isin([<span class="st">&#39;b&#39;</span>, <span class="st">&#39;c&#39;</span>])</span>
<span id="cb119-15"><a href="#cb119-15"></a></span>
<span id="cb119-16"><a href="#cb119-16"></a>In [<span class="dv">258</span>]: mask</span>
<span id="cb119-17"><a href="#cb119-17"></a>Out[<span class="dv">258</span>]: </span>
<span id="cb119-18"><a href="#cb119-18"></a><span class="dv">0</span>     <span class="va">True</span></span>
<span id="cb119-19"><a href="#cb119-19"></a><span class="dv">1</span>    <span class="va">False</span></span>
<span id="cb119-20"><a href="#cb119-20"></a><span class="dv">2</span>    <span class="va">False</span></span>
<span id="cb119-21"><a href="#cb119-21"></a><span class="dv">3</span>    <span class="va">False</span></span>
<span id="cb119-22"><a href="#cb119-22"></a><span class="dv">4</span>    <span class="va">False</span></span>
<span id="cb119-23"><a href="#cb119-23"></a><span class="dv">5</span>     <span class="va">True</span></span>
<span id="cb119-24"><a href="#cb119-24"></a><span class="dv">6</span>     <span class="va">True</span></span>
<span id="cb119-25"><a href="#cb119-25"></a><span class="dv">7</span>     <span class="va">True</span></span>
<span id="cb119-26"><a href="#cb119-26"></a><span class="dv">8</span>     <span class="va">True</span></span>
<span id="cb119-27"><a href="#cb119-27"></a>dtype: <span class="bu">bool</span></span>
<span id="cb119-28"><a href="#cb119-28"></a></span>
<span id="cb119-29"><a href="#cb119-29"></a>In [<span class="dv">259</span>]: obj[mask]</span>
<span id="cb119-30"><a href="#cb119-30"></a>Out[<span class="dv">259</span>]: </span>
<span id="cb119-31"><a href="#cb119-31"></a><span class="dv">0</span>    c</span>
<span id="cb119-32"><a href="#cb119-32"></a><span class="dv">5</span>    b</span>
<span id="cb119-33"><a href="#cb119-33"></a><span class="dv">6</span>    b</span>
<span id="cb119-34"><a href="#cb119-34"></a><span class="dv">7</span>    c</span>
<span id="cb119-35"><a href="#cb119-35"></a><span class="dv">8</span>    c</span>
<span id="cb119-36"><a href="#cb119-36"></a>dtype: <span class="bu">object</span></span></code></pre></div>
<p>与isin类似的是Index.get_indexer方法，它可以给你一个索引数组，从可能包含重复值的数组到另一个不同值的数组：</p>
<div class="sourceCode" id="cb120"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb120-1"><a href="#cb120-1"></a>In [<span class="dv">260</span>]: to_match <span class="op">=</span> pd.Series([<span class="st">&#39;c&#39;</span>, <span class="st">&#39;a&#39;</span>, <span class="st">&#39;b&#39;</span>, <span class="st">&#39;b&#39;</span>, <span class="st">&#39;c&#39;</span>, <span class="st">&#39;a&#39;</span>])</span>
<span id="cb120-2"><a href="#cb120-2"></a></span>
<span id="cb120-3"><a href="#cb120-3"></a>In [<span class="dv">261</span>]: unique_vals <span class="op">=</span> pd.Series([<span class="st">&#39;c&#39;</span>, <span class="st">&#39;b&#39;</span>, <span class="st">&#39;a&#39;</span>])</span>
<span id="cb120-4"><a href="#cb120-4"></a></span>
<span id="cb120-5"><a href="#cb120-5"></a>In [<span class="dv">262</span>]: pd.Index(unique_vals).get_indexer(to_match)</span>
<span id="cb120-6"><a href="#cb120-6"></a>Out[<span class="dv">262</span>]: array([<span class="dv">0</span>, <span class="dv">2</span>, <span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">0</span>, <span class="dv">2</span>])</span></code></pre></div>
<p>表5-9给出了这几个方法的一些参考信息。</p>
<figure>
<img src="http://upload-images.jianshu.io/upload_images/7178691-b53c4a9d65a2db32.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="" /><figcaption>表5-9 唯一值、值计数、成员资格方法</figcaption>
</figure>
<p>有时，你可能希望得到DataFrame中多个相关列的一张柱状图。例如：</p>
<div class="sourceCode" id="cb121"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb121-1"><a href="#cb121-1"></a>In [<span class="dv">263</span>]: data <span class="op">=</span> pd.DataFrame({<span class="st">&#39;Qu1&#39;</span>: [<span class="dv">1</span>, <span class="dv">3</span>, <span class="dv">4</span>, <span class="dv">3</span>, <span class="dv">4</span>],</span>
<span id="cb121-2"><a href="#cb121-2"></a>   .....:                      <span class="st">&#39;Qu2&#39;</span>: [<span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>],</span>
<span id="cb121-3"><a href="#cb121-3"></a>   .....:                      <span class="st">&#39;Qu3&#39;</span>: [<span class="dv">1</span>, <span class="dv">5</span>, <span class="dv">2</span>, <span class="dv">4</span>, <span class="dv">4</span>]})</span>
<span id="cb121-4"><a href="#cb121-4"></a></span>
<span id="cb121-5"><a href="#cb121-5"></a>In [<span class="dv">264</span>]: data</span>
<span id="cb121-6"><a href="#cb121-6"></a>Out[<span class="dv">264</span>]: </span>
<span id="cb121-7"><a href="#cb121-7"></a>   Qu1  Qu2  Qu3</span>
<span id="cb121-8"><a href="#cb121-8"></a><span class="dv">0</span>    <span class="dv">1</span>    <span class="dv">2</span>    <span class="dv">1</span></span>
<span id="cb121-9"><a href="#cb121-9"></a><span class="dv">1</span>    <span class="dv">3</span>    <span class="dv">3</span>    <span class="dv">5</span></span>
<span id="cb121-10"><a href="#cb121-10"></a><span class="dv">2</span>    <span class="dv">4</span>    <span class="dv">1</span>    <span class="dv">2</span></span>
<span id="cb121-11"><a href="#cb121-11"></a><span class="dv">3</span>    <span class="dv">3</span>    <span class="dv">2</span>    <span class="dv">4</span></span>
<span id="cb121-12"><a href="#cb121-12"></a><span class="dv">4</span>    <span class="dv">4</span>    <span class="dv">3</span>    <span class="dv">4</span></span></code></pre></div>
<p>将pandas.value_counts传给该DataFrame的apply函数，就会出现：</p>
<div class="sourceCode" id="cb122"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb122-1"><a href="#cb122-1"></a>In [<span class="dv">265</span>]: result <span class="op">=</span> data.<span class="bu">apply</span>(pd.value_counts).fillna(<span class="dv">0</span>)</span>
<span id="cb122-2"><a href="#cb122-2"></a></span>
<span id="cb122-3"><a href="#cb122-3"></a>In [<span class="dv">266</span>]: result</span>
<span id="cb122-4"><a href="#cb122-4"></a>Out[<span class="dv">266</span>]: </span>
<span id="cb122-5"><a href="#cb122-5"></a>   Qu1  Qu2  Qu3</span>
<span id="cb122-6"><a href="#cb122-6"></a><span class="dv">1</span>  <span class="fl">1.0</span>  <span class="fl">1.0</span>  <span class="fl">1.0</span></span>
<span id="cb122-7"><a href="#cb122-7"></a><span class="dv">2</span>  <span class="fl">0.0</span>  <span class="fl">2.0</span>  <span class="fl">1.0</span></span>
<span id="cb122-8"><a href="#cb122-8"></a><span class="dv">3</span>  <span class="fl">2.0</span>  <span class="fl">2.0</span>  <span class="fl">0.0</span></span>
<span id="cb122-9"><a href="#cb122-9"></a><span class="dv">4</span>  <span class="fl">2.0</span>  <span class="fl">0.0</span>  <span class="fl">2.0</span></span>
<span id="cb122-10"><a href="#cb122-10"></a><span class="dv">5</span>  <span class="fl">0.0</span>  <span class="fl">0.0</span>  <span class="fl">1.0</span></span></code></pre></div>
<p>这里，结果中的行标签是所有列的唯一值。后面的频率值是每个列中这些值的相应计数。</p>
<h1 id="总结">5.4 总结</h1>
<p>在下一章，我们将讨论用pandas读取（或加载）和写入数据集的工具。</p>
<p>之后，我们将更深入地研究使用pandas进行数据清洗、规整、分析和可视化工具。</p>
