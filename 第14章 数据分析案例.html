<p>本书正文的最后一章，我们来看一些真实世界的数据集。对于每个数据集，我们会用之前介绍的方法，从原始数据中提取有意义的内容。展示的方法适用于其它数据集，也包括你的。本章包含了一些各种各样的案例数据集，可以用来练习。</p>
<p>案例数据集可以在Github仓库找到，见第一章。</p>
<p>#14.1 来自Bitly的USA.gov数据</p>
<p>2011年，URL缩短服务Bitly跟美国政府网站USA.gov合作，提供了一份从生成.gov或.mil短链接的用户那里收集来的匿名数据。在2011年，除实时数据之外，还可以下载文本文件形式的每小时快照。写作此书时（2017年），这项服务已经关闭，但我们保存一份数据用于本书的案例。</p>
<p>以每小时快照为例，文件中各行的格式为JSON（即JavaScript Object Notation，这是一种常用的Web数据格式）。例如，如果我们只读取某个文件中的第一行，那么所看到的结果应该是下面这样：</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1"></a>In [<span class="dv">5</span>]: path <span class="op">=</span> <span class="st">&#39;datasets/bitly_usagov/example.txt&#39;</span></span>
<span id="cb1-2"><a href="#cb1-2"></a></span>
<span id="cb1-3"><a href="#cb1-3"></a>In [<span class="dv">6</span>]: <span class="bu">open</span>(path).readline()</span>
<span id="cb1-4"><a href="#cb1-4"></a>Out[<span class="dv">6</span>]: <span class="st">&#39;{ &quot;a&quot;: &quot;Mozilla</span><span class="ch">\\</span><span class="st">/5.0 (Windows NT 6.1; WOW64) AppleWebKit</span><span class="ch">\\</span><span class="st">/535.11</span></span>
<span id="cb1-5"><a href="#cb1-5"></a><span class="st">(KHTML, like Gecko) Chrome</span><span class="ch">\\</span><span class="st">/17.0.963.78 Safari</span><span class="ch">\\</span><span class="st">/535.11&quot;, &quot;c&quot;: &quot;US&quot;, &quot;nk&quot;: 1,</span></span>
<span id="cb1-6"><a href="#cb1-6"></a><span class="st">&quot;tz&quot;: &quot;America</span><span class="ch">\\</span><span class="st">/New_York&quot;, &quot;gr&quot;: &quot;MA&quot;, &quot;g&quot;: &quot;A6qOVH&quot;, &quot;h&quot;: &quot;wfLQtf&quot;, &quot;l&quot;:</span></span>
<span id="cb1-7"><a href="#cb1-7"></a><span class="st">&quot;orofrog&quot;, &quot;al&quot;: &quot;en-US,en;q=0.8&quot;, &quot;hh&quot;: &quot;1.usa.gov&quot;, &quot;r&quot;:</span></span>
<span id="cb1-8"><a href="#cb1-8"></a><span class="st">&quot;http:</span><span class="ch">\\</span><span class="st">/</span><span class="ch">\\</span><span class="st">/www.facebook.com</span><span class="ch">\\</span><span class="st">/l</span><span class="ch">\\</span><span class="st">/7AQEFzjSi</span><span class="ch">\\</span><span class="st">/1.usa.gov</span><span class="ch">\\</span><span class="st">/wfLQtf&quot;, &quot;u&quot;:</span></span>
<span id="cb1-9"><a href="#cb1-9"></a><span class="st">&quot;http:</span><span class="ch">\\</span><span class="st">/</span><span class="ch">\\</span><span class="st">/www.ncbi.nlm.nih.gov</span><span class="ch">\\</span><span class="st">/pubmed</span><span class="ch">\\</span><span class="st">/22415991&quot;, &quot;t&quot;: 1331923247, &quot;hc&quot;:</span></span>
<span id="cb1-10"><a href="#cb1-10"></a><span class="st">1331822918, &quot;cy&quot;: &quot;Danvers&quot;, &quot;ll&quot;: [ 42.576698, -70.954903 ] }</span><span class="ch">\n</span><span class="st">&#39;</span></span></code></pre></div>
<p>Python有内置或第三方模块可以将JSON字符串转换成Python字典对象。这里，我将使用json模块及其loads函数逐行加载已经下载好的数据文件：</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1"></a><span class="im">import</span> json</span>
<span id="cb2-2"><a href="#cb2-2"></a>path <span class="op">=</span> <span class="st">&#39;datasets/bitly_usagov/example.txt&#39;</span></span>
<span id="cb2-3"><a href="#cb2-3"></a>records <span class="op">=</span> [json.loads(line) <span class="cf">for</span> line <span class="kw">in</span> <span class="bu">open</span>(path)]</span></code></pre></div>
<p>现在，records对象就成为一组Python字典了：</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1"></a>In [<span class="dv">18</span>]: records[<span class="dv">0</span>]</span>
<span id="cb3-2"><a href="#cb3-2"></a>Out[<span class="dv">18</span>]:</span>
<span id="cb3-3"><a href="#cb3-3"></a>{<span class="st">&#39;a&#39;</span>: <span class="st">&#39;Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/535.11 (KHTML, like Gecko)</span></span>
<span id="cb3-4"><a href="#cb3-4"></a><span class="st">Chrome/17.0.963.78 Safari/535.11&#39;</span>,</span>
<span id="cb3-5"><a href="#cb3-5"></a> <span class="st">&#39;al&#39;</span>: <span class="st">&#39;en-US,en;q=0.8&#39;</span>,</span>
<span id="cb3-6"><a href="#cb3-6"></a> <span class="st">&#39;c&#39;</span>: <span class="st">&#39;US&#39;</span>,</span>
<span id="cb3-7"><a href="#cb3-7"></a> <span class="st">&#39;cy&#39;</span>: <span class="st">&#39;Danvers&#39;</span>,</span>
<span id="cb3-8"><a href="#cb3-8"></a> <span class="st">&#39;g&#39;</span>: <span class="st">&#39;A6qOVH&#39;</span>,</span>
<span id="cb3-9"><a href="#cb3-9"></a> <span class="st">&#39;gr&#39;</span>: <span class="st">&#39;MA&#39;</span>,</span>
<span id="cb3-10"><a href="#cb3-10"></a> <span class="st">&#39;h&#39;</span>: <span class="st">&#39;wfLQtf&#39;</span>,</span>
<span id="cb3-11"><a href="#cb3-11"></a> <span class="st">&#39;hc&#39;</span>: <span class="dv">1331822918</span>,</span>
<span id="cb3-12"><a href="#cb3-12"></a> <span class="st">&#39;hh&#39;</span>: <span class="st">&#39;1.usa.gov&#39;</span>,</span>
<span id="cb3-13"><a href="#cb3-13"></a> <span class="st">&#39;l&#39;</span>: <span class="st">&#39;orofrog&#39;</span>,</span>
<span id="cb3-14"><a href="#cb3-14"></a> <span class="st">&#39;ll&#39;</span>: [<span class="fl">42.576698</span>, <span class="op">-</span><span class="fl">70.954903</span>],</span>
<span id="cb3-15"><a href="#cb3-15"></a> <span class="st">&#39;nk&#39;</span>: <span class="dv">1</span>,</span>
<span id="cb3-16"><a href="#cb3-16"></a> <span class="st">&#39;r&#39;</span>: <span class="st">&#39;http://www.facebook.com/l/7AQEFzjSi/1.usa.gov/wfLQtf&#39;</span>,</span>
<span id="cb3-17"><a href="#cb3-17"></a> <span class="st">&#39;t&#39;</span>: <span class="dv">1331923247</span>,</span>
<span id="cb3-18"><a href="#cb3-18"></a> <span class="st">&#39;tz&#39;</span>: <span class="st">&#39;America/New_York&#39;</span>,</span>
<span id="cb3-19"><a href="#cb3-19"></a> <span class="st">&#39;u&#39;</span>: <span class="st">&#39;http://www.ncbi.nlm.nih.gov/pubmed/22415991&#39;</span>}</span></code></pre></div>
<p>##用纯Python代码对时区进行计数</p>
<p>假设我们想要知道该数据集中最常出现的是哪个时区（即tz字段），得到答案的办法有很多。首先，我们用列表推导式取出一组时区：</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1"></a>In [<span class="dv">12</span>]: time_zones <span class="op">=</span> [rec[<span class="st">&#39;tz&#39;</span>] <span class="cf">for</span> rec <span class="kw">in</span> records]</span>
<span id="cb4-2"><a href="#cb4-2"></a><span class="op">---------------------------------------------------------------------------</span></span>
<span id="cb4-3"><a href="#cb4-3"></a><span class="pp">KeyError</span>                                  Traceback (most recent call last)</span>
<span id="cb4-4"><a href="#cb4-4"></a><span class="op">&lt;</span>ipython<span class="op">-</span><span class="bu">input</span><span class="op">-</span><span class="dv">12</span><span class="op">-</span>db4fbd348da9<span class="op">&gt;</span> <span class="kw">in</span> <span class="op">&lt;</span>module<span class="op">&gt;</span>()</span>
<span id="cb4-5"><a href="#cb4-5"></a><span class="op">----&gt;</span> <span class="dv">1</span> time_zones <span class="op">=</span> [rec[<span class="st">&#39;tz&#39;</span>] <span class="cf">for</span> rec <span class="kw">in</span> records]</span>
<span id="cb4-6"><a href="#cb4-6"></a><span class="op">&lt;</span>ipython<span class="op">-</span><span class="bu">input</span><span class="op">-</span><span class="dv">12</span><span class="op">-</span>db4fbd348da9<span class="op">&gt;</span> <span class="kw">in</span> <span class="op">&lt;</span>listcomp<span class="op">&gt;</span>(<span class="fl">.0</span>)</span>
<span id="cb4-7"><a href="#cb4-7"></a><span class="op">----&gt;</span> <span class="dv">1</span> time_zones <span class="op">=</span> [rec[<span class="st">&#39;tz&#39;</span>] <span class="cf">for</span> rec <span class="kw">in</span> records]</span>
<span id="cb4-8"><a href="#cb4-8"></a><span class="pp">KeyError</span>: <span class="st">&#39;tz&#39;</span></span></code></pre></div>
<p>晕！原来并不是所有记录都有时区字段。这个好办，只需在列表推导式末尾加上一个if ’tz’in rec判断即可：</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb5-1"><a href="#cb5-1"></a>In [<span class="dv">13</span>]: time_zones <span class="op">=</span> [rec[<span class="st">&#39;tz&#39;</span>] <span class="cf">for</span> rec <span class="kw">in</span> records <span class="cf">if</span> <span class="st">&#39;tz&#39;</span> <span class="kw">in</span> rec]</span>
<span id="cb5-2"><a href="#cb5-2"></a></span>
<span id="cb5-3"><a href="#cb5-3"></a>In [<span class="dv">14</span>]: time_zones[:<span class="dv">10</span>]</span>
<span id="cb5-4"><a href="#cb5-4"></a>Out[<span class="dv">14</span>]: </span>
<span id="cb5-5"><a href="#cb5-5"></a>[<span class="st">&#39;America/New_York&#39;</span>,</span>
<span id="cb5-6"><a href="#cb5-6"></a> <span class="st">&#39;America/Denver&#39;</span>,</span>
<span id="cb5-7"><a href="#cb5-7"></a> <span class="st">&#39;America/New_York&#39;</span>,</span>
<span id="cb5-8"><a href="#cb5-8"></a> <span class="st">&#39;America/Sao_Paulo&#39;</span>,</span>
<span id="cb5-9"><a href="#cb5-9"></a> <span class="st">&#39;America/New_York&#39;</span>,</span>
<span id="cb5-10"><a href="#cb5-10"></a> <span class="st">&#39;America/New_York&#39;</span>,</span>
<span id="cb5-11"><a href="#cb5-11"></a> <span class="st">&#39;Europe/Warsaw&#39;</span>,</span>
<span id="cb5-12"><a href="#cb5-12"></a> <span class="st">&#39;&#39;</span>,</span>
<span id="cb5-13"><a href="#cb5-13"></a> <span class="st">&#39;&#39;</span>,</span>
<span id="cb5-14"><a href="#cb5-14"></a> <span class="st">&#39;&#39;</span>]</span></code></pre></div>
<p>只看前10个时区，我们发现有些是未知的（即空的）。虽然可以将它们过滤掉，但现在暂时先留着。接下来，为了对时区进行计数，这里介绍两个办法：一个较难（只使用标准Python库），另一个较简单（使用pandas）。计数的办法之一是在遍历时区的过程中将计数值保存在字典中：</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb6-1"><a href="#cb6-1"></a><span class="kw">def</span> get_counts(sequence):</span>
<span id="cb6-2"><a href="#cb6-2"></a>    counts <span class="op">=</span> {}</span>
<span id="cb6-3"><a href="#cb6-3"></a>    <span class="cf">for</span> x <span class="kw">in</span> sequence:</span>
<span id="cb6-4"><a href="#cb6-4"></a>        <span class="cf">if</span> x <span class="kw">in</span> counts:</span>
<span id="cb6-5"><a href="#cb6-5"></a>            counts[x] <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb6-6"><a href="#cb6-6"></a>        <span class="cf">else</span>:</span>
<span id="cb6-7"><a href="#cb6-7"></a>            counts[x] <span class="op">=</span> <span class="dv">1</span></span>
<span id="cb6-8"><a href="#cb6-8"></a>    <span class="cf">return</span> counts</span></code></pre></div>
<p>如果使用Python标准库的更高级工具，那么你可能会将代码写得更简洁一些：</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb7-1"><a href="#cb7-1"></a><span class="im">from</span> collections <span class="im">import</span> defaultdict</span>
<span id="cb7-2"><a href="#cb7-2"></a></span>
<span id="cb7-3"><a href="#cb7-3"></a><span class="kw">def</span> get_counts2(sequence):</span>
<span id="cb7-4"><a href="#cb7-4"></a>    counts <span class="op">=</span> defaultdict(<span class="bu">int</span>) <span class="co"># values will initialize to 0</span></span>
<span id="cb7-5"><a href="#cb7-5"></a>    <span class="cf">for</span> x <span class="kw">in</span> sequence:</span>
<span id="cb7-6"><a href="#cb7-6"></a>        counts[x] <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb7-7"><a href="#cb7-7"></a>    <span class="cf">return</span> counts</span></code></pre></div>
<p>我将逻辑写到函数中是为了获得更高的复用性。要用它对时区进行处理，只需将time_zones传入即可：</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb8-1"><a href="#cb8-1"></a>In [<span class="dv">17</span>]: counts <span class="op">=</span> get_counts(time_zones)</span>
<span id="cb8-2"><a href="#cb8-2"></a></span>
<span id="cb8-3"><a href="#cb8-3"></a>In [<span class="dv">18</span>]: counts[<span class="st">&#39;America/New_York&#39;</span>]</span>
<span id="cb8-4"><a href="#cb8-4"></a>Out[<span class="dv">18</span>]: <span class="dv">1251</span></span>
<span id="cb8-5"><a href="#cb8-5"></a></span>
<span id="cb8-6"><a href="#cb8-6"></a>In [<span class="dv">19</span>]: <span class="bu">len</span>(time_zones)</span>
<span id="cb8-7"><a href="#cb8-7"></a>Out[<span class="dv">19</span>]: <span class="dv">3440</span></span></code></pre></div>
<p>如果想要得到前10位的时区及其计数值，我们需要用到一些有关字典的处理技巧：</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb9-1"><a href="#cb9-1"></a><span class="kw">def</span> top_counts(count_dict, n<span class="op">=</span><span class="dv">10</span>):</span>
<span id="cb9-2"><a href="#cb9-2"></a>    value_key_pairs <span class="op">=</span> [(count, tz) <span class="cf">for</span> tz, count <span class="kw">in</span> count_dict.items()]</span>
<span id="cb9-3"><a href="#cb9-3"></a>    value_key_pairs.sort()</span>
<span id="cb9-4"><a href="#cb9-4"></a>    <span class="cf">return</span> value_key_pairs[<span class="op">-</span>n:]</span></code></pre></div>
<p>然后有：</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb10-1"><a href="#cb10-1"></a>In [<span class="dv">21</span>]: top_counts(counts)</span>
<span id="cb10-2"><a href="#cb10-2"></a>Out[<span class="dv">21</span>]: </span>
<span id="cb10-3"><a href="#cb10-3"></a>[(<span class="dv">33</span>, <span class="st">&#39;America/Sao_Paulo&#39;</span>),</span>
<span id="cb10-4"><a href="#cb10-4"></a> (<span class="dv">35</span>, <span class="st">&#39;Europe/Madrid&#39;</span>),</span>
<span id="cb10-5"><a href="#cb10-5"></a>(<span class="dv">36</span>, <span class="st">&#39;Pacific/Honolulu&#39;</span>),</span>
<span id="cb10-6"><a href="#cb10-6"></a> (<span class="dv">37</span>, <span class="st">&#39;Asia/Tokyo&#39;</span>),</span>
<span id="cb10-7"><a href="#cb10-7"></a> (<span class="dv">74</span>, <span class="st">&#39;Europe/London&#39;</span>),</span>
<span id="cb10-8"><a href="#cb10-8"></a> (<span class="dv">191</span>, <span class="st">&#39;America/Denver&#39;</span>),</span>
<span id="cb10-9"><a href="#cb10-9"></a> (<span class="dv">382</span>, <span class="st">&#39;America/Los_Angeles&#39;</span>),</span>
<span id="cb10-10"><a href="#cb10-10"></a> (<span class="dv">400</span>, <span class="st">&#39;America/Chicago&#39;</span>),</span>
<span id="cb10-11"><a href="#cb10-11"></a> (<span class="dv">521</span>, <span class="st">&#39;&#39;</span>),</span>
<span id="cb10-12"><a href="#cb10-12"></a> (<span class="dv">1251</span>, <span class="st">&#39;America/New_York&#39;</span>)]</span></code></pre></div>
<p>如果你搜索Python的标准库，你能找到collections.Counter类，它可以使这项工作更简单：</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb11-1"><a href="#cb11-1"></a>In [<span class="dv">22</span>]: <span class="im">from</span> collections <span class="im">import</span> Counter</span>
<span id="cb11-2"><a href="#cb11-2"></a></span>
<span id="cb11-3"><a href="#cb11-3"></a>In [<span class="dv">23</span>]: counts <span class="op">=</span> Counter(time_zones)</span>
<span id="cb11-4"><a href="#cb11-4"></a></span>
<span id="cb11-5"><a href="#cb11-5"></a>In [<span class="dv">24</span>]: counts.most_common(<span class="dv">10</span>)</span>
<span id="cb11-6"><a href="#cb11-6"></a>Out[<span class="dv">24</span>]: </span>
<span id="cb11-7"><a href="#cb11-7"></a>[(<span class="st">&#39;America/New_York&#39;</span>, <span class="dv">1251</span>),</span>
<span id="cb11-8"><a href="#cb11-8"></a> (<span class="st">&#39;&#39;</span>, <span class="dv">521</span>),</span>
<span id="cb11-9"><a href="#cb11-9"></a> (<span class="st">&#39;America/Chicago&#39;</span>, <span class="dv">400</span>),</span>
<span id="cb11-10"><a href="#cb11-10"></a> (<span class="st">&#39;America/Los_Angeles&#39;</span>, <span class="dv">382</span>),</span>
<span id="cb11-11"><a href="#cb11-11"></a> (<span class="st">&#39;America/Denver&#39;</span>, <span class="dv">191</span>),</span>
<span id="cb11-12"><a href="#cb11-12"></a> (<span class="st">&#39;Europe/London&#39;</span>, <span class="dv">74</span>),</span>
<span id="cb11-13"><a href="#cb11-13"></a> (<span class="st">&#39;Asia/Tokyo&#39;</span>, <span class="dv">37</span>),</span>
<span id="cb11-14"><a href="#cb11-14"></a> (<span class="st">&#39;Pacific/Honolulu&#39;</span>, <span class="dv">36</span>),</span>
<span id="cb11-15"><a href="#cb11-15"></a> (<span class="st">&#39;Europe/Madrid&#39;</span>, <span class="dv">35</span>),</span>
<span id="cb11-16"><a href="#cb11-16"></a> (<span class="st">&#39;America/Sao_Paulo&#39;</span>, <span class="dv">33</span>)]</span></code></pre></div>
<h2 id="用pandas对时区进行计数">用pandas对时区进行计数</h2>
<p>从原始记录的集合创建DateFrame，与将记录列表传递到pandas.DataFrame一样简单：</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb12-1"><a href="#cb12-1"></a>In [<span class="dv">25</span>]: <span class="im">import</span> pandas <span class="im">as</span> pd</span>
<span id="cb12-2"><a href="#cb12-2"></a></span>
<span id="cb12-3"><a href="#cb12-3"></a>In [<span class="dv">26</span>]: frame <span class="op">=</span> pd.DataFrame(records)</span>
<span id="cb12-4"><a href="#cb12-4"></a></span>
<span id="cb12-5"><a href="#cb12-5"></a>In [<span class="dv">27</span>]: frame.info()</span>
<span id="cb12-6"><a href="#cb12-6"></a><span class="op">&lt;</span><span class="kw">class</span> <span class="st">&#39;pandas.core.frame.DataFrame&#39;</span><span class="op">&gt;</span></span>
<span id="cb12-7"><a href="#cb12-7"></a>RangeIndex: <span class="dv">3560</span> entries, <span class="dv">0</span> to <span class="dv">3559</span></span>
<span id="cb12-8"><a href="#cb12-8"></a>Data columns (total <span class="dv">18</span> columns):</span>
<span id="cb12-9"><a href="#cb12-9"></a>_heartbeat_    <span class="dv">120</span> non<span class="op">-</span>null float64</span>
<span id="cb12-10"><a href="#cb12-10"></a>a              <span class="dv">3440</span> non<span class="op">-</span>null <span class="bu">object</span></span>
<span id="cb12-11"><a href="#cb12-11"></a>al             <span class="dv">3094</span> non<span class="op">-</span>null <span class="bu">object</span></span>
<span id="cb12-12"><a href="#cb12-12"></a>c              <span class="dv">2919</span> non<span class="op">-</span>null <span class="bu">object</span></span>
<span id="cb12-13"><a href="#cb12-13"></a>cy             <span class="dv">2919</span> non<span class="op">-</span>null <span class="bu">object</span></span>
<span id="cb12-14"><a href="#cb12-14"></a>g              <span class="dv">3440</span> non<span class="op">-</span>null <span class="bu">object</span></span>
<span id="cb12-15"><a href="#cb12-15"></a>gr             <span class="dv">2919</span> non<span class="op">-</span>null <span class="bu">object</span></span>
<span id="cb12-16"><a href="#cb12-16"></a>h              <span class="dv">3440</span> non<span class="op">-</span>null <span class="bu">object</span></span>
<span id="cb12-17"><a href="#cb12-17"></a>hc             <span class="dv">3440</span> non<span class="op">-</span>null float64</span>
<span id="cb12-18"><a href="#cb12-18"></a>hh             <span class="dv">3440</span> non<span class="op">-</span>null <span class="bu">object</span></span>
<span id="cb12-19"><a href="#cb12-19"></a>kw             <span class="dv">93</span> non<span class="op">-</span>null <span class="bu">object</span></span>
<span id="cb12-20"><a href="#cb12-20"></a>l              <span class="dv">3440</span> non<span class="op">-</span>null <span class="bu">object</span></span>
<span id="cb12-21"><a href="#cb12-21"></a>ll             <span class="dv">2919</span> non<span class="op">-</span>null <span class="bu">object</span></span>
<span id="cb12-22"><a href="#cb12-22"></a>nk             <span class="dv">3440</span> non<span class="op">-</span>null float64</span>
<span id="cb12-23"><a href="#cb12-23"></a>r              <span class="dv">3440</span> non<span class="op">-</span>null <span class="bu">object</span></span>
<span id="cb12-24"><a href="#cb12-24"></a>t              <span class="dv">3440</span> non<span class="op">-</span>null float64</span>
<span id="cb12-25"><a href="#cb12-25"></a>tz             <span class="dv">3440</span> non<span class="op">-</span>null <span class="bu">object</span></span>
<span id="cb12-26"><a href="#cb12-26"></a>u              <span class="dv">3440</span> non<span class="op">-</span>null <span class="bu">object</span></span>
<span id="cb12-27"><a href="#cb12-27"></a>dtypes: float64(<span class="dv">4</span>), <span class="bu">object</span>(<span class="dv">14</span>)</span>
<span id="cb12-28"><a href="#cb12-28"></a>memory usage: <span class="fl">500.7</span><span class="op">+</span> KB</span>
<span id="cb12-29"><a href="#cb12-29"></a></span>
<span id="cb12-30"><a href="#cb12-30"></a>In [<span class="dv">28</span>]: frame[<span class="st">&#39;tz&#39;</span>][:<span class="dv">10</span>]</span>
<span id="cb12-31"><a href="#cb12-31"></a>Out[<span class="dv">28</span>]: </span>
<span id="cb12-32"><a href="#cb12-32"></a><span class="dv">0</span>     America<span class="op">/</span>New_York</span>
<span id="cb12-33"><a href="#cb12-33"></a><span class="dv">1</span>       America<span class="op">/</span>Denver</span>
<span id="cb12-34"><a href="#cb12-34"></a><span class="dv">2</span>     America<span class="op">/</span>New_York</span>
<span id="cb12-35"><a href="#cb12-35"></a><span class="dv">3</span>    America<span class="op">/</span>Sao_Paulo</span>
<span id="cb12-36"><a href="#cb12-36"></a><span class="dv">4</span>     America<span class="op">/</span>New_York</span>
<span id="cb12-37"><a href="#cb12-37"></a><span class="dv">5</span>     America<span class="op">/</span>New_York</span>
<span id="cb12-38"><a href="#cb12-38"></a><span class="dv">6</span>        Europe<span class="op">/</span>Warsaw</span>
<span id="cb12-39"><a href="#cb12-39"></a><span class="dv">7</span>                     </span>
<span id="cb12-40"><a href="#cb12-40"></a><span class="dv">8</span>                     </span>
<span id="cb12-41"><a href="#cb12-41"></a><span class="dv">9</span>                     </span>
<span id="cb12-42"><a href="#cb12-42"></a>Name: tz, dtype: <span class="bu">object</span></span></code></pre></div>
<p>这里frame的输出形式是摘要视图（summary view），主要用于较大的DataFrame对象。我们然后可以对Series使用value_counts方法：</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb13-1"><a href="#cb13-1"></a>In [<span class="dv">29</span>]: tz_counts <span class="op">=</span> frame[<span class="st">&#39;tz&#39;</span>].value_counts()</span>
<span id="cb13-2"><a href="#cb13-2"></a></span>
<span id="cb13-3"><a href="#cb13-3"></a>In [<span class="dv">30</span>]: tz_counts[:<span class="dv">10</span>]</span>
<span id="cb13-4"><a href="#cb13-4"></a>Out[<span class="dv">30</span>]: </span>
<span id="cb13-5"><a href="#cb13-5"></a>America<span class="op">/</span>New_York       <span class="dv">1251</span></span>
<span id="cb13-6"><a href="#cb13-6"></a>                        <span class="dv">521</span></span>
<span id="cb13-7"><a href="#cb13-7"></a>America<span class="op">/</span>Chicago         <span class="dv">400</span></span>
<span id="cb13-8"><a href="#cb13-8"></a>America<span class="op">/</span>Los_Angeles     <span class="dv">382</span></span>
<span id="cb13-9"><a href="#cb13-9"></a>America<span class="op">/</span>Denver          <span class="dv">191</span></span>
<span id="cb13-10"><a href="#cb13-10"></a>Europe<span class="op">/</span>London            <span class="dv">74</span></span>
<span id="cb13-11"><a href="#cb13-11"></a>Asia<span class="op">/</span>Tokyo               <span class="dv">37</span></span>
<span id="cb13-12"><a href="#cb13-12"></a>Pacific<span class="op">/</span>Honolulu         <span class="dv">36</span></span>
<span id="cb13-13"><a href="#cb13-13"></a>Europe<span class="op">/</span>Madrid            <span class="dv">35</span></span>
<span id="cb13-14"><a href="#cb13-14"></a>America<span class="op">/</span>Sao_Paulo        <span class="dv">33</span></span>
<span id="cb13-15"><a href="#cb13-15"></a>Name: tz, dtype: int64</span></code></pre></div>
<p>我们可以用matplotlib可视化这个数据。为此，我们先给记录中未知或缺失的时区填上一个替代值。fillna函数可以替换缺失值（NA），而未知值（空字符串）则可以通过布尔型数组索引加以替换：</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb14-1"><a href="#cb14-1"></a>In [<span class="dv">31</span>]: clean_tz <span class="op">=</span> frame[<span class="st">&#39;tz&#39;</span>].fillna(<span class="st">&#39;Missing&#39;</span>)</span>
<span id="cb14-2"><a href="#cb14-2"></a></span>
<span id="cb14-3"><a href="#cb14-3"></a>In [<span class="dv">32</span>]: clean_tz[clean_tz <span class="op">==</span> <span class="st">&#39;&#39;</span>] <span class="op">=</span> <span class="st">&#39;Unknown&#39;</span></span>
<span id="cb14-4"><a href="#cb14-4"></a></span>
<span id="cb14-5"><a href="#cb14-5"></a>In [<span class="dv">33</span>]: tz_counts <span class="op">=</span> clean_tz.value_counts()</span>
<span id="cb14-6"><a href="#cb14-6"></a></span>
<span id="cb14-7"><a href="#cb14-7"></a>In [<span class="dv">34</span>]: tz_counts[:<span class="dv">10</span>]</span>
<span id="cb14-8"><a href="#cb14-8"></a>Out[<span class="dv">34</span>]: </span>
<span id="cb14-9"><a href="#cb14-9"></a>America<span class="op">/</span>New_York       <span class="dv">1251</span></span>
<span id="cb14-10"><a href="#cb14-10"></a>Unknown                 <span class="dv">521</span></span>
<span id="cb14-11"><a href="#cb14-11"></a>America<span class="op">/</span>Chicago         <span class="dv">400</span></span>
<span id="cb14-12"><a href="#cb14-12"></a>America<span class="op">/</span>Los_Angeles     <span class="dv">382</span></span>
<span id="cb14-13"><a href="#cb14-13"></a>America<span class="op">/</span>Denver          <span class="dv">191</span></span>
<span id="cb14-14"><a href="#cb14-14"></a>Missing                 <span class="dv">120</span></span>
<span id="cb14-15"><a href="#cb14-15"></a>Europe<span class="op">/</span>London            <span class="dv">74</span></span>
<span id="cb14-16"><a href="#cb14-16"></a>Asia<span class="op">/</span>Tokyo               <span class="dv">37</span></span>
<span id="cb14-17"><a href="#cb14-17"></a>Pacific<span class="op">/</span>Honolulu         <span class="dv">36</span></span>
<span id="cb14-18"><a href="#cb14-18"></a>Europe<span class="op">/</span>Madrid            <span class="dv">35</span></span>
<span id="cb14-19"><a href="#cb14-19"></a>Name: tz, dtype: int64</span></code></pre></div>
<p>此时，我们可以用seaborn包创建水平柱状图（结果见图14-1）：</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb15-1"><a href="#cb15-1"></a>In [<span class="dv">36</span>]: <span class="im">import</span> seaborn <span class="im">as</span> sns</span>
<span id="cb15-2"><a href="#cb15-2"></a></span>
<span id="cb15-3"><a href="#cb15-3"></a>In [<span class="dv">37</span>]: subset <span class="op">=</span> tz_counts[:<span class="dv">10</span>]</span>
<span id="cb15-4"><a href="#cb15-4"></a></span>
<span id="cb15-5"><a href="#cb15-5"></a>In [<span class="dv">38</span>]: sns.barplot(y<span class="op">=</span>subset.index, x<span class="op">=</span>subset.values)</span></code></pre></div>
<figure>
<img src="http://upload-images.jianshu.io/upload_images/7178691-aa267c1d399a78f0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="" /><figcaption>图14-1 usa.gov示例数据中最常出现的时区</figcaption>
</figure>
<p>a字段含有执行URL短缩操作的浏览器、设备、应用程序的相关信息：</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb16-1"><a href="#cb16-1"></a>In [<span class="dv">39</span>]: frame[<span class="st">&#39;a&#39;</span>][<span class="dv">1</span>]</span>
<span id="cb16-2"><a href="#cb16-2"></a>Out[<span class="dv">39</span>]: <span class="st">&#39;GoogleMaps/RochesterNY&#39;</span></span>
<span id="cb16-3"><a href="#cb16-3"></a></span>
<span id="cb16-4"><a href="#cb16-4"></a>In [<span class="dv">40</span>]: frame[<span class="st">&#39;a&#39;</span>][<span class="dv">50</span>]</span>
<span id="cb16-5"><a href="#cb16-5"></a>Out[<span class="dv">40</span>]: <span class="st">&#39;Mozilla/5.0 (Windows NT 5.1; rv:10.0.2)</span></span>
<span id="cb16-6"><a href="#cb16-6"></a><span class="st">Gecko/20100101 Firefox/10.0.2&#39;</span></span>
<span id="cb16-7"><a href="#cb16-7"></a></span>
<span id="cb16-8"><a href="#cb16-8"></a>In [<span class="dv">41</span>]: frame[<span class="st">&#39;a&#39;</span>][<span class="dv">51</span>][:<span class="dv">50</span>]  <span class="co"># long line</span></span>
<span id="cb16-9"><a href="#cb16-9"></a>Out[<span class="dv">41</span>]: <span class="st">&#39;Mozilla/5.0 (Linux; U; Android 2.2.2; en-us; LG-P9&#39;</span></span></code></pre></div>
<p>将这些“agent”字符串中的所有信息都解析出来是一件挺郁闷的工作。一种策略是将这种字符串的第一节（与浏览器大致对应）分离出来并得到另外一份用户行为摘要：</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb17-1"><a href="#cb17-1"></a>In [<span class="dv">42</span>]: results <span class="op">=</span> pd.Series([x.split()[<span class="dv">0</span>] <span class="cf">for</span> x <span class="kw">in</span> frame.a.dropna()])</span>
<span id="cb17-2"><a href="#cb17-2"></a></span>
<span id="cb17-3"><a href="#cb17-3"></a>In [<span class="dv">43</span>]: results[:<span class="dv">5</span>]</span>
<span id="cb17-4"><a href="#cb17-4"></a>Out[<span class="dv">43</span>]: </span>
<span id="cb17-5"><a href="#cb17-5"></a><span class="dv">0</span>               Mozilla<span class="op">/</span><span class="fl">5.0</span></span>
<span id="cb17-6"><a href="#cb17-6"></a><span class="dv">1</span>    GoogleMaps<span class="op">/</span>RochesterNY</span>
<span id="cb17-7"><a href="#cb17-7"></a><span class="dv">2</span>               Mozilla<span class="op">/</span><span class="fl">4.0</span></span>
<span id="cb17-8"><a href="#cb17-8"></a><span class="dv">3</span>               Mozilla<span class="op">/</span><span class="fl">5.0</span></span>
<span id="cb17-9"><a href="#cb17-9"></a><span class="dv">4</span>               Mozilla<span class="op">/</span><span class="fl">5.0</span></span>
<span id="cb17-10"><a href="#cb17-10"></a>dtype: <span class="bu">object</span></span>
<span id="cb17-11"><a href="#cb17-11"></a></span>
<span id="cb17-12"><a href="#cb17-12"></a>In [<span class="dv">44</span>]: results.value_counts()[:<span class="dv">8</span>]</span>
<span id="cb17-13"><a href="#cb17-13"></a>Out[<span class="dv">44</span>]: </span>
<span id="cb17-14"><a href="#cb17-14"></a>Mozilla<span class="op">/</span><span class="fl">5.0</span>                 <span class="dv">2594</span></span>
<span id="cb17-15"><a href="#cb17-15"></a>Mozilla<span class="op">/</span><span class="fl">4.0</span>                  <span class="dv">601</span></span>
<span id="cb17-16"><a href="#cb17-16"></a>GoogleMaps<span class="op">/</span>RochesterNY       <span class="dv">121</span></span>
<span id="cb17-17"><a href="#cb17-17"></a>Opera<span class="op">/</span><span class="fl">9.80</span>                    <span class="dv">34</span></span>
<span id="cb17-18"><a href="#cb17-18"></a>TEST_INTERNET_AGENT           <span class="dv">24</span></span>
<span id="cb17-19"><a href="#cb17-19"></a>GoogleProducer                <span class="dv">21</span></span>
<span id="cb17-20"><a href="#cb17-20"></a>Mozilla<span class="op">/</span><span class="fl">6.0</span>                    <span class="dv">5</span></span>
<span id="cb17-21"><a href="#cb17-21"></a>BlackBerry8520<span class="op">/</span><span class="fl">5.0.0.681</span>       <span class="dv">4</span></span>
<span id="cb17-22"><a href="#cb17-22"></a>dtype: int64</span></code></pre></div>
<p>现在，假设你想按Windows和非Windows用户对时区统计信息进行分解。为了简单起见，我们假定只要agent字符串中含有“Windows”就认为该用户为Windows用户。由于有的agent缺失，所以首先将它们从数据中移除：</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb18-1"><a href="#cb18-1"></a>In [<span class="dv">45</span>]: cframe <span class="op">=</span> frame[frame.a.notnull()]</span></code></pre></div>
<p>然后计算出各行是否含有Windows的值：</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb19-1"><a href="#cb19-1"></a>In [<span class="dv">47</span>]: cframe[<span class="st">&#39;os&#39;</span>] <span class="op">=</span> np.where(cframe[<span class="st">&#39;a&#39;</span>].<span class="bu">str</span>.contains(<span class="st">&#39;Windows&#39;</span>),</span>
<span id="cb19-2"><a href="#cb19-2"></a>   ....:                         <span class="st">&#39;Windows&#39;</span>, <span class="st">&#39;Not Windows&#39;</span>)</span>
<span id="cb19-3"><a href="#cb19-3"></a></span>
<span id="cb19-4"><a href="#cb19-4"></a>In [<span class="dv">48</span>]: cframe[<span class="st">&#39;os&#39;</span>][:<span class="dv">5</span>]</span>
<span id="cb19-5"><a href="#cb19-5"></a>Out[<span class="dv">48</span>]: </span>
<span id="cb19-6"><a href="#cb19-6"></a><span class="dv">0</span>        Windows</span>
<span id="cb19-7"><a href="#cb19-7"></a><span class="dv">1</span>    Not Windows</span>
<span id="cb19-8"><a href="#cb19-8"></a><span class="dv">2</span>        Windows</span>
<span id="cb19-9"><a href="#cb19-9"></a><span class="dv">3</span>    Not Windows</span>
<span id="cb19-10"><a href="#cb19-10"></a><span class="dv">4</span>        Windows</span>
<span id="cb19-11"><a href="#cb19-11"></a>Name: os, dtype: <span class="bu">object</span></span></code></pre></div>
<p>接下来就可以根据时区和新得到的操作系统列表对数据进行分组了：</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb20-1"><a href="#cb20-1"></a>In [<span class="dv">49</span>]: by_tz_os <span class="op">=</span> cframe.groupby([<span class="st">&#39;tz&#39;</span>, <span class="st">&#39;os&#39;</span>])</span></code></pre></div>
<p>分组计数，类似于value_counts函数，可以用size来计算。并利用unstack对计数结果进行重塑：</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb21-1"><a href="#cb21-1"></a>In [<span class="dv">50</span>]: agg_counts <span class="op">=</span> by_tz_os.size().unstack().fillna(<span class="dv">0</span>)</span>
<span id="cb21-2"><a href="#cb21-2"></a></span>
<span id="cb21-3"><a href="#cb21-3"></a>In [<span class="dv">51</span>]: agg_counts[:<span class="dv">10</span>]</span>
<span id="cb21-4"><a href="#cb21-4"></a>Out[<span class="dv">51</span>]: </span>
<span id="cb21-5"><a href="#cb21-5"></a>os                              Not Windows  Windows</span>
<span id="cb21-6"><a href="#cb21-6"></a>tz                                                  </span>
<span id="cb21-7"><a href="#cb21-7"></a>                                      <span class="fl">245.0</span>    <span class="fl">276.0</span></span>
<span id="cb21-8"><a href="#cb21-8"></a>Africa<span class="op">/</span>Cairo                            <span class="fl">0.0</span>      <span class="fl">3.0</span></span>
<span id="cb21-9"><a href="#cb21-9"></a>Africa<span class="op">/</span>Casablanca                       <span class="fl">0.0</span>      <span class="fl">1.0</span></span>
<span id="cb21-10"><a href="#cb21-10"></a>Africa<span class="op">/</span>Ceuta                            <span class="fl">0.0</span>      <span class="fl">2.0</span></span>
<span id="cb21-11"><a href="#cb21-11"></a>Africa<span class="op">/</span>Johannesburg                     <span class="fl">0.0</span>      <span class="fl">1.0</span></span>
<span id="cb21-12"><a href="#cb21-12"></a>Africa<span class="op">/</span>Lusaka                           <span class="fl">0.0</span>      <span class="fl">1.0</span></span>
<span id="cb21-13"><a href="#cb21-13"></a>America<span class="op">/</span>Anchorage                       <span class="fl">4.0</span>      <span class="fl">1.0</span></span>
<span id="cb21-14"><a href="#cb21-14"></a>America<span class="op">/</span>Argentina<span class="op">/</span>Buenos_Aires          <span class="fl">1.0</span>      <span class="fl">0.0</span></span>
<span id="cb21-15"><a href="#cb21-15"></a>America<span class="op">/</span>Argentina<span class="op">/</span>Cordoba               <span class="fl">0.0</span>      <span class="fl">1.0</span></span>
<span id="cb21-16"><a href="#cb21-16"></a>America<span class="op">/</span>Argentina<span class="op">/</span>Mendoza               <span class="fl">0.0</span>      <span class="fl">1.0</span></span></code></pre></div>
<p>最后，我们来选取最常出现的时区。为了达到这个目的，我根据agg_counts中的行数构造了一个间接索引数组：</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb22-1"><a href="#cb22-1"></a><span class="co"># Use to sort in ascending order</span></span>
<span id="cb22-2"><a href="#cb22-2"></a>In [<span class="dv">52</span>]: indexer <span class="op">=</span> agg_counts.<span class="bu">sum</span>(<span class="dv">1</span>).argsort()</span>
<span id="cb22-3"><a href="#cb22-3"></a></span>
<span id="cb22-4"><a href="#cb22-4"></a>In [<span class="dv">53</span>]: indexer[:<span class="dv">10</span>]</span>
<span id="cb22-5"><a href="#cb22-5"></a>Out[<span class="dv">53</span>]: </span>
<span id="cb22-6"><a href="#cb22-6"></a>tz</span>
<span id="cb22-7"><a href="#cb22-7"></a>                                  <span class="dv">24</span></span>
<span id="cb22-8"><a href="#cb22-8"></a>Africa<span class="op">/</span>Cairo                      <span class="dv">20</span></span>
<span id="cb22-9"><a href="#cb22-9"></a>Africa<span class="op">/</span>Casablanca                 <span class="dv">21</span></span>
<span id="cb22-10"><a href="#cb22-10"></a>Africa<span class="op">/</span>Ceuta                      <span class="dv">92</span></span>
<span id="cb22-11"><a href="#cb22-11"></a>Africa<span class="op">/</span>Johannesburg               <span class="dv">87</span></span>
<span id="cb22-12"><a href="#cb22-12"></a>Africa<span class="op">/</span>Lusaka                     <span class="dv">53</span></span>
<span id="cb22-13"><a href="#cb22-13"></a>America<span class="op">/</span>Anchorage                 <span class="dv">54</span></span>
<span id="cb22-14"><a href="#cb22-14"></a>America<span class="op">/</span>Argentina<span class="op">/</span>Buenos_Aires    <span class="dv">57</span></span>
<span id="cb22-15"><a href="#cb22-15"></a>America<span class="op">/</span>Argentina<span class="op">/</span>Cordoba         <span class="dv">26</span></span>
<span id="cb22-16"><a href="#cb22-16"></a>America<span class="op">/</span>Argentina<span class="op">/</span>Mendoza         <span class="dv">55</span></span>
<span id="cb22-17"><a href="#cb22-17"></a>dtype: int64</span></code></pre></div>
<p>然后我通过take按照这个顺序截取了最后10行最大值：</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb23-1"><a href="#cb23-1"></a>In [<span class="dv">54</span>]: count_subset <span class="op">=</span> agg_counts.take(indexer[<span class="op">-</span><span class="dv">10</span>:])</span>
<span id="cb23-2"><a href="#cb23-2"></a></span>
<span id="cb23-3"><a href="#cb23-3"></a>In [<span class="dv">55</span>]: count_subset</span>
<span id="cb23-4"><a href="#cb23-4"></a>Out[<span class="dv">55</span>]: </span>
<span id="cb23-5"><a href="#cb23-5"></a>os                   Not Windows  Windows</span>
<span id="cb23-6"><a href="#cb23-6"></a>tz                                       </span>
<span id="cb23-7"><a href="#cb23-7"></a>America<span class="op">/</span>Sao_Paulo           <span class="fl">13.0</span>     <span class="fl">20.0</span></span>
<span id="cb23-8"><a href="#cb23-8"></a>Europe<span class="op">/</span>Madrid               <span class="fl">16.0</span>     <span class="fl">19.0</span></span>
<span id="cb23-9"><a href="#cb23-9"></a>Pacific<span class="op">/</span>Honolulu             <span class="fl">0.0</span>     <span class="fl">36.0</span></span>
<span id="cb23-10"><a href="#cb23-10"></a>Asia<span class="op">/</span>Tokyo                   <span class="fl">2.0</span>     <span class="fl">35.0</span></span>
<span id="cb23-11"><a href="#cb23-11"></a>Europe<span class="op">/</span>London               <span class="fl">43.0</span>     <span class="fl">31.0</span></span>
<span id="cb23-12"><a href="#cb23-12"></a>America<span class="op">/</span>Denver             <span class="fl">132.0</span>     <span class="fl">59.0</span></span>
<span id="cb23-13"><a href="#cb23-13"></a>America<span class="op">/</span>Los_Angeles        <span class="fl">130.0</span>    <span class="fl">252.0</span></span>
<span id="cb23-14"><a href="#cb23-14"></a>America<span class="op">/</span>Chicago            <span class="fl">115.0</span>    <span class="fl">285.0</span></span>
<span id="cb23-15"><a href="#cb23-15"></a>                           <span class="fl">245.0</span>    <span class="fl">276.0</span></span>
<span id="cb23-16"><a href="#cb23-16"></a>America<span class="op">/</span>New_York           <span class="fl">339.0</span>    <span class="fl">912.0</span></span></code></pre></div>
<p>pandas有一个简便方法nlargest，可以做同样的工作：</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb24-1"><a href="#cb24-1"></a>In [<span class="dv">56</span>]: agg_counts.<span class="bu">sum</span>(<span class="dv">1</span>).nlargest(<span class="dv">10</span>)</span>
<span id="cb24-2"><a href="#cb24-2"></a>Out[<span class="dv">56</span>]: </span>
<span id="cb24-3"><a href="#cb24-3"></a>tz</span>
<span id="cb24-4"><a href="#cb24-4"></a>America<span class="op">/</span>New_York       <span class="fl">1251.0</span></span>
<span id="cb24-5"><a href="#cb24-5"></a>                        <span class="fl">521.0</span></span>
<span id="cb24-6"><a href="#cb24-6"></a>America<span class="op">/</span>Chicago         <span class="fl">400.0</span></span>
<span id="cb24-7"><a href="#cb24-7"></a>America<span class="op">/</span>Los_Angeles     <span class="fl">382.0</span></span>
<span id="cb24-8"><a href="#cb24-8"></a>America<span class="op">/</span>Denver          <span class="fl">191.0</span></span>
<span id="cb24-9"><a href="#cb24-9"></a>Europe<span class="op">/</span>London            <span class="fl">74.0</span></span>
<span id="cb24-10"><a href="#cb24-10"></a>Asia<span class="op">/</span>Tokyo               <span class="fl">37.0</span></span>
<span id="cb24-11"><a href="#cb24-11"></a>Pacific<span class="op">/</span>Honolulu         <span class="fl">36.0</span></span>
<span id="cb24-12"><a href="#cb24-12"></a>Europe<span class="op">/</span>Madrid            <span class="fl">35.0</span></span>
<span id="cb24-13"><a href="#cb24-13"></a>America<span class="op">/</span>Sao_Paulo        <span class="fl">33.0</span></span>
<span id="cb24-14"><a href="#cb24-14"></a>dtype: float64</span></code></pre></div>
<p>然后，如这段代码所示，可以用柱状图表示。我传递一个额外参数到seaborn的barpolt函数，来画一个堆积条形图（见图14-2）：</p>
<div class="sourceCode" id="cb25"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb25-1"><a href="#cb25-1"></a><span class="co"># Rearrange the data for plotting</span></span>
<span id="cb25-2"><a href="#cb25-2"></a>In [<span class="dv">58</span>]: count_subset <span class="op">=</span> count_subset.stack()</span>
<span id="cb25-3"><a href="#cb25-3"></a></span>
<span id="cb25-4"><a href="#cb25-4"></a>In [<span class="dv">59</span>]: count_subset.name <span class="op">=</span> <span class="st">&#39;total&#39;</span></span>
<span id="cb25-5"><a href="#cb25-5"></a></span>
<span id="cb25-6"><a href="#cb25-6"></a>In [<span class="dv">60</span>]: count_subset <span class="op">=</span> count_subset.reset_index()</span>
<span id="cb25-7"><a href="#cb25-7"></a></span>
<span id="cb25-8"><a href="#cb25-8"></a>In [<span class="dv">61</span>]: count_subset[:<span class="dv">10</span>]</span>
<span id="cb25-9"><a href="#cb25-9"></a>Out[<span class="dv">61</span>]: </span>
<span id="cb25-10"><a href="#cb25-10"></a>                  tz           os  total</span>
<span id="cb25-11"><a href="#cb25-11"></a><span class="dv">0</span>  America<span class="op">/</span>Sao_Paulo  Not Windows   <span class="fl">13.0</span></span>
<span id="cb25-12"><a href="#cb25-12"></a><span class="dv">1</span>  America<span class="op">/</span>Sao_Paulo      Windows   <span class="fl">20.0</span></span>
<span id="cb25-13"><a href="#cb25-13"></a><span class="dv">2</span>      Europe<span class="op">/</span>Madrid  Not Windows   <span class="fl">16.0</span></span>
<span id="cb25-14"><a href="#cb25-14"></a><span class="dv">3</span>      Europe<span class="op">/</span>Madrid      Windows   <span class="fl">19.0</span></span>
<span id="cb25-15"><a href="#cb25-15"></a><span class="dv">4</span>   Pacific<span class="op">/</span>Honolulu  Not Windows    <span class="fl">0.0</span></span>
<span id="cb25-16"><a href="#cb25-16"></a><span class="dv">5</span>   Pacific<span class="op">/</span>Honolulu      Windows   <span class="fl">36.0</span></span>
<span id="cb25-17"><a href="#cb25-17"></a><span class="dv">6</span>         Asia<span class="op">/</span>Tokyo  Not Windows    <span class="fl">2.0</span></span>
<span id="cb25-18"><a href="#cb25-18"></a><span class="dv">7</span>         Asia<span class="op">/</span>Tokyo      Windows   <span class="fl">35.0</span></span>
<span id="cb25-19"><a href="#cb25-19"></a><span class="dv">8</span>      Europe<span class="op">/</span>London  Not Windows   <span class="fl">43.0</span></span>
<span id="cb25-20"><a href="#cb25-20"></a><span class="dv">9</span>      Europe<span class="op">/</span>London      Windows   <span class="fl">31.0</span></span>
<span id="cb25-21"><a href="#cb25-21"></a></span>
<span id="cb25-22"><a href="#cb25-22"></a>In [<span class="dv">62</span>]: sns.barplot(x<span class="op">=</span><span class="st">&#39;total&#39;</span>, y<span class="op">=</span><span class="st">&#39;tz&#39;</span>, hue<span class="op">=</span><span class="st">&#39;os&#39;</span>,  data<span class="op">=</span>count_subset)</span></code></pre></div>
<figure>
<img src="http://upload-images.jianshu.io/upload_images/7178691-053612a5655b68d9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="" /><figcaption>图14-2 最常出现时区的Windows和非Windows用户</figcaption>
</figure>
<p>这张图不容易看出Windows用户在小分组中的相对比例，因此标准化分组百分比之和为1：</p>
<div class="sourceCode" id="cb26"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb26-1"><a href="#cb26-1"></a><span class="kw">def</span> norm_total(group):</span>
<span id="cb26-2"><a href="#cb26-2"></a>    group[<span class="st">&#39;normed_total&#39;</span>] <span class="op">=</span> group.total <span class="op">/</span> group.total.<span class="bu">sum</span>()</span>
<span id="cb26-3"><a href="#cb26-3"></a>    <span class="cf">return</span> group</span>
<span id="cb26-4"><a href="#cb26-4"></a></span>
<span id="cb26-5"><a href="#cb26-5"></a>results <span class="op">=</span> count_subset.groupby(<span class="st">&#39;tz&#39;</span>).<span class="bu">apply</span>(norm_total)</span></code></pre></div>
<p>再次画图，见图14-3：</p>
<div class="sourceCode" id="cb27"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb27-1"><a href="#cb27-1"></a>In [<span class="dv">65</span>]: sns.barplot(x<span class="op">=</span><span class="st">&#39;normed_total&#39;</span>, y<span class="op">=</span><span class="st">&#39;tz&#39;</span>, hue<span class="op">=</span><span class="st">&#39;os&#39;</span>,  data<span class="op">=</span>results)</span></code></pre></div>
<figure>
<img src="http://upload-images.jianshu.io/upload_images/7178691-60ee355801daf412.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="" /><figcaption>图14-3 最常出现时区的Windows和非Windows用户的百分比</figcaption>
</figure>
<p>我们还可以用groupby的transform方法，更高效的计算标准化的和：</p>
<div class="sourceCode" id="cb28"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb28-1"><a href="#cb28-1"></a>In [<span class="dv">66</span>]: g <span class="op">=</span> count_subset.groupby(<span class="st">&#39;tz&#39;</span>)</span>
<span id="cb28-2"><a href="#cb28-2"></a></span>
<span id="cb28-3"><a href="#cb28-3"></a>In [<span class="dv">67</span>]: results2 <span class="op">=</span> count_subset.total <span class="op">/</span> g.total.transform(<span class="st">&#39;sum&#39;</span>)</span></code></pre></div>
<h1 id="movielens-1m数据集">14.2 MovieLens 1M数据集</h1>
<p>GroupLens Research（http://www.grouplens.org/node/73）采集了一组从20世纪90年末到21世纪初由MovieLens用户提供的电影评分数据。这些数据中包括电影评分、电影元数据（风格类型和年代）以及关于用户的人口统计学数据（年龄、邮编、性别和职业等）。基于机器学习算法的推荐系统一般都会对此类数据感兴趣。虽然我不会在本书中详细介绍机器学习技术，但我会告诉你如何对这种数据进行切片切块以满足实际需求。</p>
<p>MovieLens 1M数据集含有来自6000名用户对4000部电影的100万条评分数据。它分为三个表：评分、用户信息和电影信息。将该数据从zip文件中解压出来之后，可以通过pandas.read_table将各个表分别读到一个pandas DataFrame对象中：</p>
<div class="sourceCode" id="cb29"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb29-1"><a href="#cb29-1"></a><span class="im">import</span> pandas <span class="im">as</span> pd</span>
<span id="cb29-2"><a href="#cb29-2"></a></span>
<span id="cb29-3"><a href="#cb29-3"></a><span class="co"># Make display smaller</span></span>
<span id="cb29-4"><a href="#cb29-4"></a>pd.options.display.max_rows <span class="op">=</span> <span class="dv">10</span></span>
<span id="cb29-5"><a href="#cb29-5"></a></span>
<span id="cb29-6"><a href="#cb29-6"></a>unames <span class="op">=</span> [<span class="st">&#39;user_id&#39;</span>, <span class="st">&#39;gender&#39;</span>, <span class="st">&#39;age&#39;</span>, <span class="st">&#39;occupation&#39;</span>, <span class="st">&#39;zip&#39;</span>]</span>
<span id="cb29-7"><a href="#cb29-7"></a>users <span class="op">=</span> pd.read_table(<span class="st">&#39;datasets/movielens/users.dat&#39;</span>, sep<span class="op">=</span><span class="st">&#39;::&#39;</span>,</span>
<span id="cb29-8"><a href="#cb29-8"></a>                      header<span class="op">=</span><span class="va">None</span>, names<span class="op">=</span>unames)</span>
<span id="cb29-9"><a href="#cb29-9"></a></span>
<span id="cb29-10"><a href="#cb29-10"></a>rnames <span class="op">=</span> [<span class="st">&#39;user_id&#39;</span>, <span class="st">&#39;movie_id&#39;</span>, <span class="st">&#39;rating&#39;</span>, <span class="st">&#39;timestamp&#39;</span>]</span>
<span id="cb29-11"><a href="#cb29-11"></a>ratings <span class="op">=</span> pd.read_table(<span class="st">&#39;datasets/movielens/ratings.dat&#39;</span>, sep<span class="op">=</span><span class="st">&#39;::&#39;</span>,</span>
<span id="cb29-12"><a href="#cb29-12"></a>                        header<span class="op">=</span><span class="va">None</span>, names<span class="op">=</span>rnames)</span>
<span id="cb29-13"><a href="#cb29-13"></a>mnames <span class="op">=</span> [<span class="st">&#39;movie_id&#39;</span>, <span class="st">&#39;title&#39;</span>, <span class="st">&#39;genres&#39;</span>]</span>
<span id="cb29-14"><a href="#cb29-14"></a>movies <span class="op">=</span> pd.read_table(<span class="st">&#39;datasets/movielens/movies.dat&#39;</span>, sep<span class="op">=</span><span class="st">&#39;::&#39;</span>,</span>
<span id="cb29-15"><a href="#cb29-15"></a>                       header<span class="op">=</span><span class="va">None</span>, names<span class="op">=</span>mnames)</span></code></pre></div>
<p>利用Python的切片语法，通过查看每个DataFrame的前几行即可验证数据加载工作是否一切顺利：</p>
<div class="sourceCode" id="cb30"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb30-1"><a href="#cb30-1"></a>In [<span class="dv">69</span>]: users[:<span class="dv">5</span>]</span>
<span id="cb30-2"><a href="#cb30-2"></a>Out[<span class="dv">69</span>]: </span>
<span id="cb30-3"><a href="#cb30-3"></a>   user_id gender  age  occupation    <span class="bu">zip</span></span>
<span id="cb30-4"><a href="#cb30-4"></a><span class="dv">0</span>        <span class="dv">1</span>      F    <span class="dv">1</span>          <span class="dv">10</span>  <span class="dv">48067</span></span>
<span id="cb30-5"><a href="#cb30-5"></a><span class="dv">1</span>        <span class="dv">2</span>      M   <span class="dv">56</span>          <span class="dv">16</span>  <span class="dv">70072</span></span>
<span id="cb30-6"><a href="#cb30-6"></a><span class="dv">2</span>        <span class="dv">3</span>      M   <span class="dv">25</span>          <span class="dv">15</span>  <span class="dv">55117</span></span>
<span id="cb30-7"><a href="#cb30-7"></a><span class="dv">3</span>        <span class="dv">4</span>      M   <span class="dv">45</span>           <span class="dv">7</span>  02460</span>
<span id="cb30-8"><a href="#cb30-8"></a><span class="dv">4</span>        <span class="dv">5</span>      M   <span class="dv">25</span>          <span class="dv">20</span>  <span class="dv">55455</span></span>
<span id="cb30-9"><a href="#cb30-9"></a></span>
<span id="cb30-10"><a href="#cb30-10"></a>In [<span class="dv">70</span>]: ratings[:<span class="dv">5</span>]</span>
<span id="cb30-11"><a href="#cb30-11"></a>Out[<span class="dv">70</span>]: </span>
<span id="cb30-12"><a href="#cb30-12"></a>   user_id  movie_id  rating  timestamp</span>
<span id="cb30-13"><a href="#cb30-13"></a><span class="dv">0</span>        <span class="dv">1</span>      <span class="dv">1193</span>       <span class="dv">5</span>  <span class="dv">978300760</span></span>
<span id="cb30-14"><a href="#cb30-14"></a><span class="dv">1</span>        <span class="dv">1</span>       <span class="dv">661</span>       <span class="dv">3</span>  <span class="dv">978302109</span></span>
<span id="cb30-15"><a href="#cb30-15"></a><span class="dv">2</span>        <span class="dv">1</span>       <span class="dv">914</span>       <span class="dv">3</span>  <span class="dv">978301968</span></span>
<span id="cb30-16"><a href="#cb30-16"></a><span class="dv">3</span>        <span class="dv">1</span>      <span class="dv">3408</span>       <span class="dv">4</span>  <span class="dv">978300275</span></span>
<span id="cb30-17"><a href="#cb30-17"></a><span class="dv">4</span>        <span class="dv">1</span>      <span class="dv">2355</span>       <span class="dv">5</span>  <span class="dv">978824291</span></span>
<span id="cb30-18"><a href="#cb30-18"></a></span>
<span id="cb30-19"><a href="#cb30-19"></a>In [<span class="dv">71</span>]: movies[:<span class="dv">5</span>]</span>
<span id="cb30-20"><a href="#cb30-20"></a>Out[<span class="dv">71</span>]: </span>
<span id="cb30-21"><a href="#cb30-21"></a>   movie_id                               title                        genres</span>
<span id="cb30-22"><a href="#cb30-22"></a><span class="dv">0</span>         <span class="dv">1</span>                    Toy Story (<span class="dv">1995</span>)   Animation<span class="op">|</span>Children<span class="st">&#39;s|Comedy</span></span>
<span id="cb30-23"><a href="#cb30-23"></a><span class="st">1         2                      Jumanji (1995)  Adventure|Children&#39;</span>s<span class="op">|</span>Fantasy</span>
<span id="cb30-24"><a href="#cb30-24"></a><span class="dv">2</span>         <span class="dv">3</span>             Grumpier Old Men (<span class="dv">1995</span>)                Comedy<span class="op">|</span>Romance</span>
<span id="cb30-25"><a href="#cb30-25"></a><span class="dv">3</span>         <span class="dv">4</span>            Waiting to Exhale (<span class="dv">1995</span>)                  Comedy<span class="op">|</span>Drama</span>
<span id="cb30-26"><a href="#cb30-26"></a><span class="dv">4</span>         <span class="dv">5</span>  Father of the Bride Part II (<span class="dv">1995</span>)                        Comedy</span>
<span id="cb30-27"><a href="#cb30-27"></a></span>
<span id="cb30-28"><a href="#cb30-28"></a>In [<span class="dv">72</span>]: ratings</span>
<span id="cb30-29"><a href="#cb30-29"></a>Out[<span class="dv">72</span>]: </span>
<span id="cb30-30"><a href="#cb30-30"></a>         user_id  movie_id  rating  timestamp</span>
<span id="cb30-31"><a href="#cb30-31"></a><span class="dv">0</span>              <span class="dv">1</span>      <span class="dv">1193</span>       <span class="dv">5</span>  <span class="dv">978300760</span></span>
<span id="cb30-32"><a href="#cb30-32"></a><span class="dv">1</span>              <span class="dv">1</span>       <span class="dv">661</span>       <span class="dv">3</span>  <span class="dv">978302109</span></span>
<span id="cb30-33"><a href="#cb30-33"></a><span class="dv">2</span>              <span class="dv">1</span>       <span class="dv">914</span>       <span class="dv">3</span>  <span class="dv">978301968</span></span>
<span id="cb30-34"><a href="#cb30-34"></a><span class="dv">3</span>              <span class="dv">1</span>      <span class="dv">3408</span>       <span class="dv">4</span>  <span class="dv">978300275</span></span>
<span id="cb30-35"><a href="#cb30-35"></a><span class="dv">4</span>              <span class="dv">1</span>      <span class="dv">2355</span>       <span class="dv">5</span>  <span class="dv">978824291</span></span>
<span id="cb30-36"><a href="#cb30-36"></a>...          ...       ...     ...        ...</span>
<span id="cb30-37"><a href="#cb30-37"></a><span class="dv">1000204</span>     <span class="dv">6040</span>      <span class="dv">1091</span>       <span class="dv">1</span>  <span class="dv">956716541</span></span>
<span id="cb30-38"><a href="#cb30-38"></a><span class="dv">1000205</span>     <span class="dv">6040</span>      <span class="dv">1094</span>       <span class="dv">5</span>  <span class="dv">956704887</span></span>
<span id="cb30-39"><a href="#cb30-39"></a><span class="dv">1000206</span>     <span class="dv">6040</span>       <span class="dv">562</span>       <span class="dv">5</span>  <span class="dv">956704746</span></span>
<span id="cb30-40"><a href="#cb30-40"></a><span class="dv">1000207</span>     <span class="dv">6040</span>      <span class="dv">1096</span>       <span class="dv">4</span>  <span class="dv">956715648</span></span>
<span id="cb30-41"><a href="#cb30-41"></a><span class="dv">1000208</span>     <span class="dv">6040</span>      <span class="dv">1097</span>       <span class="dv">4</span>  <span class="dv">956715569</span></span>
<span id="cb30-42"><a href="#cb30-42"></a>[<span class="dv">1000209</span> rows x <span class="dv">4</span> columns]</span></code></pre></div>
<p>注意，其中的年龄和职业是以编码形式给出的，它们的具体含义请参考该数据集的README文件。分析散布在三个表中的数据可不是一件轻松的事情。假设我们想要根据性别和年龄计算某部电影的平均得分，如果将所有数据都合并到一个表中的话问题就简单多了。我们先用pandas的merge函数将ratings跟users合并到一起，然后再将movies也合并进去。pandas会根据列名的重叠情况推断出哪些列是合并（或连接）键：</p>
<div class="sourceCode" id="cb31"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb31-1"><a href="#cb31-1"></a>In [<span class="dv">73</span>]: data <span class="op">=</span> pd.merge(pd.merge(ratings, users), movies)</span>
<span id="cb31-2"><a href="#cb31-2"></a></span>
<span id="cb31-3"><a href="#cb31-3"></a>In [<span class="dv">74</span>]: data</span>
<span id="cb31-4"><a href="#cb31-4"></a>Out[<span class="dv">74</span>]: </span>
<span id="cb31-5"><a href="#cb31-5"></a>         user_id  movie_id  rating  timestamp gender  age  occupation    <span class="bu">zip</span>  <span class="op">\</span></span>
<span id="cb31-6"><a href="#cb31-6"></a><span class="dv">0</span>              <span class="dv">1</span>      <span class="dv">1193</span>       <span class="dv">5</span>  <span class="dv">978300760</span>      F    <span class="dv">1</span>          <span class="dv">10</span>  <span class="dv">48067</span>   </span>
<span id="cb31-7"><a href="#cb31-7"></a><span class="dv">1</span>              <span class="dv">2</span>      <span class="dv">1193</span>       <span class="dv">5</span>  <span class="dv">978298413</span>      M   <span class="dv">56</span>          <span class="dv">16</span>  <span class="dv">70072</span>   </span>
<span id="cb31-8"><a href="#cb31-8"></a><span class="dv">2</span>             <span class="dv">12</span>      <span class="dv">1193</span>       <span class="dv">4</span>  <span class="dv">978220179</span>      M   <span class="dv">25</span>          <span class="dv">12</span>  <span class="dv">32793</span>   </span>
<span id="cb31-9"><a href="#cb31-9"></a><span class="dv">3</span>             <span class="dv">15</span>      <span class="dv">1193</span>       <span class="dv">4</span>  <span class="dv">978199279</span>      M   <span class="dv">25</span>           <span class="dv">7</span>  <span class="dv">22903</span>   </span>
<span id="cb31-10"><a href="#cb31-10"></a><span class="dv">4</span>             <span class="dv">17</span>      <span class="dv">1193</span>       <span class="dv">5</span>  <span class="dv">978158471</span>      M   <span class="dv">50</span>           <span class="dv">1</span>  <span class="dv">95350</span>   </span>
<span id="cb31-11"><a href="#cb31-11"></a>...          ...       ...     ...        ...    ...  ...         ...    ...   </span>
<span id="cb31-12"><a href="#cb31-12"></a><span class="dv">1000204</span>     <span class="dv">5949</span>      <span class="dv">2198</span>       <span class="dv">5</span>  <span class="dv">958846401</span>      M   <span class="dv">18</span>          <span class="dv">17</span>  <span class="dv">47901</span></span>
<span id="cb31-13"><a href="#cb31-13"></a><span class="dv">1000205</span>     <span class="dv">5675</span>      <span class="dv">2703</span>       <span class="dv">3</span>  <span class="dv">976029116</span>      M   <span class="dv">35</span>          <span class="dv">14</span>  <span class="dv">30030</span>   </span>
<span id="cb31-14"><a href="#cb31-14"></a><span class="dv">1000206</span>     <span class="dv">5780</span>      <span class="dv">2845</span>       <span class="dv">1</span>  <span class="dv">958153068</span>      M   <span class="dv">18</span>          <span class="dv">17</span>  <span class="dv">92886</span>   </span>
<span id="cb31-15"><a href="#cb31-15"></a><span class="dv">1000207</span>     <span class="dv">5851</span>      <span class="dv">3607</span>       <span class="dv">5</span>  <span class="dv">957756608</span>      F   <span class="dv">18</span>          <span class="dv">20</span>  <span class="dv">55410</span>   </span>
<span id="cb31-16"><a href="#cb31-16"></a><span class="dv">1000208</span>     <span class="dv">5938</span>      <span class="dv">2909</span>       <span class="dv">4</span>  <span class="dv">957273353</span>      M   <span class="dv">25</span>           <span class="dv">1</span>  <span class="dv">35401</span>   </span>
<span id="cb31-17"><a href="#cb31-17"></a>                                               title                genres  </span>
<span id="cb31-18"><a href="#cb31-18"></a><span class="dv">0</span>             One Flew Over the Cuckoo<span class="st">&#39;s Nest (1975)                 Drama  </span></span>
<span id="cb31-19"><a href="#cb31-19"></a><span class="st">1             One Flew Over the Cuckoo&#39;</span>s Nest (<span class="dv">1975</span>)                 Drama  </span>
<span id="cb31-20"><a href="#cb31-20"></a><span class="dv">2</span>             One Flew Over the Cuckoo<span class="st">&#39;s Nest (1975)                 Drama  </span></span>
<span id="cb31-21"><a href="#cb31-21"></a><span class="st">3             One Flew Over the Cuckoo&#39;</span>s Nest (<span class="dv">1975</span>)                 Drama  </span>
<span id="cb31-22"><a href="#cb31-22"></a><span class="dv">4</span>             One Flew Over the Cuckoo<span class="st">&#39;s Nest (1975)                 Drama  </span></span>
<span id="cb31-23"><a href="#cb31-23"></a><span class="st">...                                              ...                   ...  </span></span>
<span id="cb31-24"><a href="#cb31-24"></a><span class="st">1000204                           Modulations (1998)           Documentary  </span></span>
<span id="cb31-25"><a href="#cb31-25"></a><span class="st">1000205                        Broken Vessels (1998)                 Drama  </span></span>
<span id="cb31-26"><a href="#cb31-26"></a><span class="st">1000206                            White Boys (1999)                 Drama  </span></span>
<span id="cb31-27"><a href="#cb31-27"></a><span class="st">1000207                     One Little Indian (1973)  Comedy|Drama|Western  </span></span>
<span id="cb31-28"><a href="#cb31-28"></a><span class="st">1000208  Five Wives, Three Secretaries and Me (1998)           Documentary  </span></span>
<span id="cb31-29"><a href="#cb31-29"></a><span class="st">[1000209 rows x 10 columns]</span></span>
<span id="cb31-30"><a href="#cb31-30"></a></span>
<span id="cb31-31"><a href="#cb31-31"></a><span class="st">In [75]: data.iloc[0]</span></span>
<span id="cb31-32"><a href="#cb31-32"></a><span class="st">Out[75]: </span></span>
<span id="cb31-33"><a href="#cb31-33"></a><span class="st">user_id                                            1</span></span>
<span id="cb31-34"><a href="#cb31-34"></a><span class="st">movie_id                                        1193</span></span>
<span id="cb31-35"><a href="#cb31-35"></a><span class="st">rating                                             5</span></span>
<span id="cb31-36"><a href="#cb31-36"></a><span class="st">timestamp                                  978300760</span></span>
<span id="cb31-37"><a href="#cb31-37"></a><span class="st">gender                                             F</span></span>
<span id="cb31-38"><a href="#cb31-38"></a><span class="st">age                                                1</span></span>
<span id="cb31-39"><a href="#cb31-39"></a><span class="st">occupation                                        10</span></span>
<span id="cb31-40"><a href="#cb31-40"></a><span class="st">zip                                            48067</span></span>
<span id="cb31-41"><a href="#cb31-41"></a><span class="st">title         One Flew Over the Cuckoo&#39;</span>s Nest (<span class="dv">1975</span>)</span>
<span id="cb31-42"><a href="#cb31-42"></a>genres                                         Drama</span>
<span id="cb31-43"><a href="#cb31-43"></a>Name: <span class="dv">0</span>, dtype: <span class="bu">object</span></span></code></pre></div>
<p>为了按性别计算每部电影的平均得分，我们可以使用pivot_table方法：</p>
<div class="sourceCode" id="cb32"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb32-1"><a href="#cb32-1"></a>In [<span class="dv">76</span>]: mean_ratings <span class="op">=</span> data.pivot_table(<span class="st">&#39;rating&#39;</span>, index<span class="op">=</span><span class="st">&#39;title&#39;</span>,</span>
<span id="cb32-2"><a href="#cb32-2"></a>   ....:                                 columns<span class="op">=</span><span class="st">&#39;gender&#39;</span>, aggfunc<span class="op">=</span><span class="st">&#39;mean&#39;</span>)</span>
<span id="cb32-3"><a href="#cb32-3"></a></span>
<span id="cb32-4"><a href="#cb32-4"></a>In [<span class="dv">77</span>]: mean_ratings[:<span class="dv">5</span>]</span>
<span id="cb32-5"><a href="#cb32-5"></a>Out[<span class="dv">77</span>]: </span>
<span id="cb32-6"><a href="#cb32-6"></a>gender                                F         M</span>
<span id="cb32-7"><a href="#cb32-7"></a>title                                            </span>
<span id="cb32-8"><a href="#cb32-8"></a>$<span class="dv">1</span>,<span class="dv">000</span>,<span class="dv">000</span> Duck (<span class="dv">1971</span>)         <span class="fl">3.375000</span>  <span class="fl">2.761905</span></span>
<span id="cb32-9"><a href="#cb32-9"></a><span class="co">&#39;Night Mother (1986)           3.388889  3.352941</span></span>
<span id="cb32-10"><a href="#cb32-10"></a><span class="co">&#39;</span>Til There Was You (<span class="dv">1997</span>)      <span class="fl">2.675676</span>  <span class="fl">2.733333</span></span>
<span id="cb32-11"><a href="#cb32-11"></a><span class="co">&#39;burbs, The (1989)             2.793478  2.962085</span></span>
<span id="cb32-12"><a href="#cb32-12"></a><span class="co">...And Justice for All (1979)  3.828571  3.689024</span></span></code></pre></div>
<p>该操作产生了另一个DataFrame，其内容为电影平均得分，行标为电影名称（索引），列标为性别。现在，我打算过滤掉评分数据不够250条的电影（随便选的一个数字）。为了达到这个目的，我先对title进行分组，然后利用size()得到一个含有各电影分组大小的Series对象：</p>
<div class="sourceCode" id="cb33"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb33-1"><a href="#cb33-1"></a>In [<span class="dv">78</span>]: ratings_by_title <span class="op">=</span> data.groupby(<span class="st">&#39;title&#39;</span>).size()</span>
<span id="cb33-2"><a href="#cb33-2"></a></span>
<span id="cb33-3"><a href="#cb33-3"></a>In [<span class="dv">79</span>]: ratings_by_title[:<span class="dv">10</span>]</span>
<span id="cb33-4"><a href="#cb33-4"></a>Out[<span class="dv">79</span>]: </span>
<span id="cb33-5"><a href="#cb33-5"></a>title</span>
<span id="cb33-6"><a href="#cb33-6"></a>$<span class="dv">1</span>,<span class="dv">000</span>,<span class="dv">000</span> Duck (<span class="dv">1971</span>)                <span class="dv">37</span></span>
<span id="cb33-7"><a href="#cb33-7"></a><span class="co">&#39;Night Mother (1986)                  70</span></span>
<span id="cb33-8"><a href="#cb33-8"></a><span class="co">&#39;</span>Til There Was You (<span class="dv">1997</span>)             <span class="dv">52</span></span>
<span id="cb33-9"><a href="#cb33-9"></a><span class="co">&#39;burbs, The (1989)                   303</span></span>
<span id="cb33-10"><a href="#cb33-10"></a><span class="co">...And Justice for All (1979)        199</span></span>
<span id="cb33-11"><a href="#cb33-11"></a><span class="co">1-900 (1994)                           2</span></span>
<span id="cb33-12"><a href="#cb33-12"></a><span class="co">10 Things I Hate About You (1999)    700</span></span>
<span id="cb33-13"><a href="#cb33-13"></a><span class="co">101 Dalmatians (1961)                565</span></span>
<span id="cb33-14"><a href="#cb33-14"></a><span class="co">101 Dalmatians (1996)                364</span></span>
<span id="cb33-15"><a href="#cb33-15"></a><span class="co">12 Angry Men (1957)                  616</span></span>
<span id="cb33-16"><a href="#cb33-16"></a><span class="co">dtype: int64</span></span>
<span id="cb33-17"><a href="#cb33-17"></a></span>
<span id="cb33-18"><a href="#cb33-18"></a><span class="co">In [80]: active_titles = ratings_by_title.index[ratings_by_title &gt;= 250]</span></span>
<span id="cb33-19"><a href="#cb33-19"></a></span>
<span id="cb33-20"><a href="#cb33-20"></a><span class="co">In [81]: active_titles</span></span>
<span id="cb33-21"><a href="#cb33-21"></a><span class="co">Out[81]: </span></span>
<span id="cb33-22"><a href="#cb33-22"></a><span class="co">Index([&#39;</span><span class="st">&#39;burbs, The (1989)&#39;</span>, <span class="st">&#39;10 Things I Hate About You (1999)&#39;</span>,</span>
<span id="cb33-23"><a href="#cb33-23"></a>       <span class="co">&#39;101 Dalmatians (1961)&#39;</span>, <span class="st">&#39;101 Dalmatians (1996)&#39;</span>, <span class="st">&#39;12 Angry Men (1957)&#39;</span>,</span>
<span id="cb33-24"><a href="#cb33-24"></a>       <span class="co">&#39;13th Warrior, The (1999)&#39;</span>, <span class="st">&#39;2 Days in the Valley (1996)&#39;</span>,</span>
<span id="cb33-25"><a href="#cb33-25"></a>       <span class="co">&#39;20,000 Leagues Under the Sea (1954)&#39;</span>, <span class="st">&#39;2001: A Space Odyssey (1968)&#39;</span>,</span>
<span id="cb33-26"><a href="#cb33-26"></a>       <span class="co">&#39;2010 (1984)&#39;</span>,</span>
<span id="cb33-27"><a href="#cb33-27"></a>       ...</span>
<span id="cb33-28"><a href="#cb33-28"></a><span class="co">&#39;X-Men (2000)&#39;</span>, <span class="st">&#39;Year of Living Dangerously (1982)&#39;</span>,</span>
<span id="cb33-29"><a href="#cb33-29"></a>       <span class="co">&#39;Yellow Submarine (1968)&#39;</span>, <span class="st">&#39;You&#39;</span>ve Got Mail (<span class="dv">1998</span>)<span class="st">&#39;,</span></span>
<span id="cb33-30"><a href="#cb33-30"></a><span class="st">       &#39;</span>Young Frankenstein (<span class="dv">1974</span>)<span class="st">&#39;, &#39;</span>Young Guns (<span class="dv">1988</span>)<span class="st">&#39;,</span></span>
<span id="cb33-31"><a href="#cb33-31"></a><span class="st">       &#39;</span>Young Guns II (<span class="dv">1990</span>)<span class="st">&#39;, &#39;</span>Young Sherlock Holmes (<span class="dv">1985</span>)<span class="st">&#39;,</span></span>
<span id="cb33-32"><a href="#cb33-32"></a><span class="st">       &#39;</span>Zero Effect (<span class="dv">1998</span>)<span class="st">&#39;, &#39;</span>eXistenZ (<span class="dv">1999</span>)<span class="st">&#39;],</span></span>
<span id="cb33-33"><a href="#cb33-33"></a><span class="st">      dtype=&#39;</span><span class="bu">object</span><span class="st">&#39;, name=&#39;</span>title<span class="st">&#39;, length=1216)</span></span></code></pre></div>
<p>标题索引中含有评分数据大于250条的电影名称，然后我们就可以据此从前面的mean_ratings中选取所需的行了：</p>
<div class="sourceCode" id="cb34"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb34-1"><a href="#cb34-1"></a><span class="co"># Select rows on the index</span></span>
<span id="cb34-2"><a href="#cb34-2"></a>In [<span class="dv">82</span>]: mean_ratings <span class="op">=</span> mean_ratings.loc[active_titles]</span>
<span id="cb34-3"><a href="#cb34-3"></a></span>
<span id="cb34-4"><a href="#cb34-4"></a>In [<span class="dv">83</span>]: mean_ratings</span>
<span id="cb34-5"><a href="#cb34-5"></a>Out[<span class="dv">83</span>]: </span>
<span id="cb34-6"><a href="#cb34-6"></a>gender                                    F         M</span>
<span id="cb34-7"><a href="#cb34-7"></a>title                                                </span>
<span id="cb34-8"><a href="#cb34-8"></a><span class="co">&#39;burbs, The (1989)                 2.793478  2.962085</span></span>
<span id="cb34-9"><a href="#cb34-9"></a><span class="co">10 Things I Hate About You (1999)  3.646552  3.311966</span></span>
<span id="cb34-10"><a href="#cb34-10"></a><span class="co">101 Dalmatians (1961)              3.791444  3.500000</span></span>
<span id="cb34-11"><a href="#cb34-11"></a><span class="co">101 Dalmatians (1996)              3.240000  2.911215</span></span>
<span id="cb34-12"><a href="#cb34-12"></a><span class="co">12 Angry Men (1957)                4.184397  4.328421</span></span>
<span id="cb34-13"><a href="#cb34-13"></a><span class="co">...                                     ...       ...</span></span>
<span id="cb34-14"><a href="#cb34-14"></a><span class="co">Young Guns (1988)                  3.371795  3.425620</span></span>
<span id="cb34-15"><a href="#cb34-15"></a><span class="co">Young Guns II (1990)               2.934783  2.904025</span></span>
<span id="cb34-16"><a href="#cb34-16"></a><span class="co">Young Sherlock Holmes (1985)       3.514706  3.363344</span></span>
<span id="cb34-17"><a href="#cb34-17"></a><span class="co">Zero Effect (1998)                 3.864407  3.723140</span></span>
<span id="cb34-18"><a href="#cb34-18"></a><span class="co">eXistenZ (1999)                    3.098592  3.289086</span></span>
<span id="cb34-19"><a href="#cb34-19"></a><span class="co">[1216 rows x 2 columns]</span></span></code></pre></div>
<p>为了了解女性观众最喜欢的电影，我们可以对F列降序排列：</p>
<div class="sourceCode" id="cb35"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb35-1"><a href="#cb35-1"></a>In [<span class="dv">85</span>]: top_female_ratings <span class="op">=</span> mean_ratings.sort_values(by<span class="op">=</span><span class="st">&#39;F&#39;</span>, ascending<span class="op">=</span><span class="va">False</span>)</span>
<span id="cb35-2"><a href="#cb35-2"></a></span>
<span id="cb35-3"><a href="#cb35-3"></a>In [<span class="dv">86</span>]: top_female_ratings[:<span class="dv">10</span>]</span>
<span id="cb35-4"><a href="#cb35-4"></a>Out[<span class="dv">86</span>]: </span>
<span id="cb35-5"><a href="#cb35-5"></a>gender                                                     F         M</span>
<span id="cb35-6"><a href="#cb35-6"></a>title                                                                 </span>
<span id="cb35-7"><a href="#cb35-7"></a>Close Shave, A (<span class="dv">1995</span>)                               <span class="fl">4.644444</span>  <span class="fl">4.473795</span></span>
<span id="cb35-8"><a href="#cb35-8"></a>Wrong Trousers, The (<span class="dv">1993</span>)                          <span class="fl">4.588235</span>  <span class="fl">4.478261</span></span>
<span id="cb35-9"><a href="#cb35-9"></a>Sunset Blvd. (a.k.a. Sunset Boulevard) (<span class="dv">1950</span>)       <span class="fl">4.572650</span>  <span class="fl">4.464589</span></span>
<span id="cb35-10"><a href="#cb35-10"></a>Wallace <span class="op">&amp;</span> Gromit: The Best of Aardman Animation...  <span class="fl">4.563107</span>  <span class="fl">4.385075</span></span>
<span id="cb35-11"><a href="#cb35-11"></a>Schindler<span class="st">&#39;s List (1993)                             4.562602  4.491415</span></span>
<span id="cb35-12"><a href="#cb35-12"></a><span class="st">Shawshank Redemption, The (1994)                    4.539075  4.560625</span></span>
<span id="cb35-13"><a href="#cb35-13"></a><span class="st">Grand Day Out, A (1992)                             4.537879  4.293255</span></span>
<span id="cb35-14"><a href="#cb35-14"></a><span class="st">To Kill a Mockingbird (1962)                        4.536667  4.372611</span></span>
<span id="cb35-15"><a href="#cb35-15"></a><span class="st">Creature Comforts (1990)                            4.513889  4.272277</span></span>
<span id="cb35-16"><a href="#cb35-16"></a><span class="st">Usual Suspects, The (1995)                          4.513317  4.518248</span></span></code></pre></div>
<h2 id="计算评分分歧">计算评分分歧</h2>
<p>假设我们想要找出男性和女性观众分歧最大的电影。一个办法是给mean_ratings加上一个用于存放平均得分之差的列，并对其进行排序：</p>
<div class="sourceCode" id="cb36"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb36-1"><a href="#cb36-1"></a>In [<span class="dv">87</span>]: mean_ratings[<span class="st">&#39;diff&#39;</span>] <span class="op">=</span> mean_ratings[<span class="st">&#39;M&#39;</span>] <span class="op">-</span> mean_ratings[<span class="st">&#39;F&#39;</span>]</span></code></pre></div>
<p>按“diff”排序即可得到分歧最大且女性观众更喜欢的电影：</p>
<div class="sourceCode" id="cb37"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb37-1"><a href="#cb37-1"></a>In [<span class="dv">88</span>]: sorted_by_diff <span class="op">=</span> mean_ratings.sort_values(by<span class="op">=</span><span class="st">&#39;diff&#39;</span>)</span>
<span id="cb37-2"><a href="#cb37-2"></a></span>
<span id="cb37-3"><a href="#cb37-3"></a>In [<span class="dv">89</span>]: sorted_by_diff[:<span class="dv">10</span>]</span>
<span id="cb37-4"><a href="#cb37-4"></a>Out[<span class="dv">89</span>]: </span>
<span id="cb37-5"><a href="#cb37-5"></a>gender                                        F         M      diff</span>
<span id="cb37-6"><a href="#cb37-6"></a>title                                                              </span>
<span id="cb37-7"><a href="#cb37-7"></a>Dirty Dancing (<span class="dv">1987</span>)                   <span class="fl">3.790378</span>  <span class="fl">2.959596</span> <span class="op">-</span><span class="fl">0.830782</span></span>
<span id="cb37-8"><a href="#cb37-8"></a>Jumpin<span class="st">&#39; Jack Flash (1986)              3.254717  2.578358 -0.676359</span></span>
<span id="cb37-9"><a href="#cb37-9"></a><span class="st">Grease (1978)                          3.975265  3.367041 -0.608224</span></span>
<span id="cb37-10"><a href="#cb37-10"></a><span class="st">Little Women (1994)                    3.870588  3.321739 -0.548849</span></span>
<span id="cb37-11"><a href="#cb37-11"></a><span class="st">Steel Magnolias (1989)                 3.901734  3.365957 -0.535777</span></span>
<span id="cb37-12"><a href="#cb37-12"></a><span class="st">Anastasia (1997)                       3.800000  3.281609 -0.518391</span></span>
<span id="cb37-13"><a href="#cb37-13"></a><span class="st">Rocky Horror Picture Show, The (1975)  3.673016  3.160131 -0.512885</span></span>
<span id="cb37-14"><a href="#cb37-14"></a><span class="st">Color Purple, The (1985)               4.158192  3.659341 -0.498851</span></span>
<span id="cb37-15"><a href="#cb37-15"></a><span class="st">Age of Innocence, The (1993)           3.827068  3.339506 -0.487561</span></span>
<span id="cb37-16"><a href="#cb37-16"></a><span class="st">Free Willy (1993)                      2.921348  2.438776 -0.482573</span></span></code></pre></div>
<p>对排序结果反序并取出前10行，得到的则是男性观众更喜欢的电影：</p>
<div class="sourceCode" id="cb38"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb38-1"><a href="#cb38-1"></a><span class="co"># Reverse order of rows, take first 10 rows</span></span>
<span id="cb38-2"><a href="#cb38-2"></a>In [<span class="dv">90</span>]: sorted_by_diff[::<span class="op">-</span><span class="dv">1</span>][:<span class="dv">10</span>]</span>
<span id="cb38-3"><a href="#cb38-3"></a>Out[<span class="dv">90</span>]: </span>
<span id="cb38-4"><a href="#cb38-4"></a>gender                                         F         M      diff</span>
<span id="cb38-5"><a href="#cb38-5"></a>title                                                               </span>
<span id="cb38-6"><a href="#cb38-6"></a>Good, The Bad <span class="kw">and</span> The Ugly, The (<span class="dv">1966</span>)  <span class="fl">3.494949</span>  <span class="fl">4.221300</span>  <span class="fl">0.726351</span></span>
<span id="cb38-7"><a href="#cb38-7"></a>Kentucky Fried Movie, The (<span class="dv">1977</span>)        <span class="fl">2.878788</span>  <span class="fl">3.555147</span>  <span class="fl">0.676359</span></span>
<span id="cb38-8"><a href="#cb38-8"></a>Dumb <span class="op">&amp;</span> Dumber (<span class="dv">1994</span>)                    <span class="fl">2.697987</span>  <span class="fl">3.336595</span>  <span class="fl">0.638608</span></span>
<span id="cb38-9"><a href="#cb38-9"></a>Longest Day, The (<span class="dv">1962</span>)                 <span class="fl">3.411765</span>  <span class="fl">4.031447</span>  <span class="fl">0.619682</span></span>
<span id="cb38-10"><a href="#cb38-10"></a>Cable Guy, The (<span class="dv">1996</span>)                   <span class="fl">2.250000</span>  <span class="fl">2.863787</span>  <span class="fl">0.613787</span></span>
<span id="cb38-11"><a href="#cb38-11"></a>Evil Dead II (Dead By Dawn) (<span class="dv">1987</span>)      <span class="fl">3.297297</span>  <span class="fl">3.909283</span>  <span class="fl">0.611985</span></span>
<span id="cb38-12"><a href="#cb38-12"></a>Hidden, The (<span class="dv">1987</span>)                      <span class="fl">3.137931</span>  <span class="fl">3.745098</span>  <span class="fl">0.607167</span></span>
<span id="cb38-13"><a href="#cb38-13"></a>Rocky III (<span class="dv">1982</span>)                        <span class="fl">2.361702</span>  <span class="fl">2.943503</span>  <span class="fl">0.581801</span></span>
<span id="cb38-14"><a href="#cb38-14"></a>Caddyshack (<span class="dv">1980</span>)                       <span class="fl">3.396135</span>  <span class="fl">3.969737</span>  <span class="fl">0.573602</span></span>
<span id="cb38-15"><a href="#cb38-15"></a>For a Few Dollars More (<span class="dv">1965</span>)           <span class="fl">3.409091</span>  <span class="fl">3.953795</span>  <span class="fl">0.544704</span></span></code></pre></div>
<p>如果只是想要找出分歧最大的电影（不考虑性别因素），则可以计算得分数据的方差或标准差：</p>
<div class="sourceCode" id="cb39"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb39-1"><a href="#cb39-1"></a><span class="co"># Standard deviation of rating grouped by title</span></span>
<span id="cb39-2"><a href="#cb39-2"></a>In [<span class="dv">91</span>]: rating_std_by_title <span class="op">=</span> data.groupby(<span class="st">&#39;title&#39;</span>)[<span class="st">&#39;rating&#39;</span>].std()</span>
<span id="cb39-3"><a href="#cb39-3"></a></span>
<span id="cb39-4"><a href="#cb39-4"></a><span class="co"># Filter down to active_titles</span></span>
<span id="cb39-5"><a href="#cb39-5"></a>In [<span class="dv">92</span>]: rating_std_by_title <span class="op">=</span> rating_std_by_title.loc[active_titles]</span>
<span id="cb39-6"><a href="#cb39-6"></a></span>
<span id="cb39-7"><a href="#cb39-7"></a><span class="co"># Order Series by value in descending order</span></span>
<span id="cb39-8"><a href="#cb39-8"></a>In [<span class="dv">93</span>]: rating_std_by_title.sort_values(ascending<span class="op">=</span><span class="va">False</span>)[:<span class="dv">10</span>]</span>
<span id="cb39-9"><a href="#cb39-9"></a>Out[<span class="dv">93</span>]: </span>
<span id="cb39-10"><a href="#cb39-10"></a>title</span>
<span id="cb39-11"><a href="#cb39-11"></a>Dumb <span class="op">&amp;</span> Dumber (<span class="dv">1994</span>)                     <span class="fl">1.321333</span></span>
<span id="cb39-12"><a href="#cb39-12"></a>Blair Witch Project, The (<span class="dv">1999</span>)          <span class="fl">1.316368</span></span>
<span id="cb39-13"><a href="#cb39-13"></a>Natural Born Killers (<span class="dv">1994</span>)              <span class="fl">1.307198</span></span>
<span id="cb39-14"><a href="#cb39-14"></a>Tank Girl (<span class="dv">1995</span>)                         <span class="fl">1.277695</span></span>
<span id="cb39-15"><a href="#cb39-15"></a>Rocky Horror Picture Show, The (<span class="dv">1975</span>)    <span class="fl">1.260177</span></span>
<span id="cb39-16"><a href="#cb39-16"></a>Eyes Wide Shut (<span class="dv">1999</span>)                    <span class="fl">1.259624</span></span>
<span id="cb39-17"><a href="#cb39-17"></a>Evita (<span class="dv">1996</span>)                             <span class="fl">1.253631</span></span>
<span id="cb39-18"><a href="#cb39-18"></a>Billy Madison (<span class="dv">1995</span>)                     <span class="fl">1.249970</span></span>
<span id="cb39-19"><a href="#cb39-19"></a>Fear <span class="kw">and</span> Loathing <span class="kw">in</span> Las Vegas (<span class="dv">1998</span>)    <span class="fl">1.246408</span></span>
<span id="cb39-20"><a href="#cb39-20"></a>Bicentennial Man (<span class="dv">1999</span>)                  <span class="fl">1.245533</span></span>
<span id="cb39-21"><a href="#cb39-21"></a>Name: rating, dtype: float64</span></code></pre></div>
<p>可能你已经注意到了，电影分类是以竖线（|）分隔的字符串形式给出的。如果想对电影分类进行分析的话，就需要先将其转换成更有用的形式才行。</p>
<h1 id="年间全美婴儿姓名">14.3 1880-2010年间全美婴儿姓名</h1>
<p>美国社会保障总署（SSA）提供了一份从1880年到现在的婴儿名字频率数据。Hadley Wickham（许多流行R包的作者）经常用这份数据来演示R的数据处理功能。</p>
<p>我们要做一些数据规整才能加载这个数据集，这么做就会产生一个如下的DataFrame：</p>
<div class="sourceCode" id="cb40"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb40-1"><a href="#cb40-1"></a>In [<span class="dv">4</span>]: names.head(<span class="dv">10</span>)</span>
<span id="cb40-2"><a href="#cb40-2"></a>Out[<span class="dv">4</span>]:</span>
<span id="cb40-3"><a href="#cb40-3"></a>        name sex  births  year</span>
<span id="cb40-4"><a href="#cb40-4"></a><span class="dv">0</span>       Mary   F    <span class="dv">7065</span>  <span class="dv">1880</span></span>
<span id="cb40-5"><a href="#cb40-5"></a><span class="dv">1</span>       Anna   F    <span class="dv">2604</span>  <span class="dv">1880</span></span>
<span id="cb40-6"><a href="#cb40-6"></a><span class="dv">2</span>       Emma   F    <span class="dv">2003</span>  <span class="dv">1880</span></span>
<span id="cb40-7"><a href="#cb40-7"></a><span class="dv">3</span>  Elizabeth   F    <span class="dv">1939</span>  <span class="dv">1880</span></span>
<span id="cb40-8"><a href="#cb40-8"></a><span class="dv">4</span>     Minnie   F    <span class="dv">1746</span>  <span class="dv">1880</span></span>
<span id="cb40-9"><a href="#cb40-9"></a><span class="dv">5</span>   Margaret   F    <span class="dv">1578</span>  <span class="dv">1880</span></span>
<span id="cb40-10"><a href="#cb40-10"></a><span class="dv">6</span>        Ida   F    <span class="dv">1472</span>  <span class="dv">1880</span></span>
<span id="cb40-11"><a href="#cb40-11"></a><span class="dv">7</span>      Alice   F    <span class="dv">1414</span>  <span class="dv">1880</span></span>
<span id="cb40-12"><a href="#cb40-12"></a><span class="dv">8</span>     Bertha   F    <span class="dv">1320</span>  <span class="dv">1880</span></span>
<span id="cb40-13"><a href="#cb40-13"></a><span class="dv">9</span>      Sarah   F    <span class="dv">1288</span>  <span class="dv">1880</span></span></code></pre></div>
<p>你可以用这个数据集做很多事，例如：</p>
<ul>
<li>计算指定名字（可以是你自己的，也可以是别人的）的年度比例。</li>
<li>计算某个名字的相对排名。</li>
<li>计算各年度最流行的名字，以及增长或减少最快的名字。</li>
<li>分析名字趋势：元音、辅音、长度、总体多样性、拼写变化、首尾字母等。</li>
<li>分析外源性趋势：圣经中的名字、名人、人口结构变化等。</li>
</ul>
<p>利用前面介绍过的那些工具，这些分析工作都能很轻松地完成，我会讲解其中的一些。</p>
<p>到编写本书时为止，美国社会保障总署将该数据库按年度制成了多个数据文件，其中给出了每个性别/名字组合的出生总数。这些文件的原始档案可以在这里获取：<a href="http://www.ssa.gov/oact/babynames/limits.html">http://www.ssa.gov/oact/babynames/limits.html</a>。</p>
<p>如果你在阅读本书的时候这个页面已经不见了，也可以用搜索引擎找找。</p>
<p>下载“National data”文件names.zip，解压后的目录中含有一组文件（如yob1880.txt）。我用UNIX的head命令查看了其中一个文件的前10行（在Windows上，你可以用more命令，或直接在文本编辑器中打开）：</p>
<pre><code>In [94]: !head -n 10 datasets/babynames/yob1880.txt
Mary,F,7065
Anna,F,2604
Emma,F,2003
Elizabeth,F,1939
Minnie,F,1746
Margaret,F,1578
Ida,F,1472
Alice,F,1414
Bertha,F,1320
Sarah,F,1288</code></pre>
<p>由于这是一个非常标准的以逗号隔开的格式，所以可以用pandas.read_csv将其加载到DataFrame中：</p>
<div class="sourceCode" id="cb42"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb42-1"><a href="#cb42-1"></a>In [<span class="dv">95</span>]: <span class="im">import</span> pandas <span class="im">as</span> pd</span>
<span id="cb42-2"><a href="#cb42-2"></a></span>
<span id="cb42-3"><a href="#cb42-3"></a>In [<span class="dv">96</span>]: names1880 <span class="op">=</span></span>
<span id="cb42-4"><a href="#cb42-4"></a>pd.read_csv(<span class="st">&#39;datasets/babynames/yob1880.txt&#39;</span>,</span>
<span id="cb42-5"><a href="#cb42-5"></a>   ....:                         names<span class="op">=</span>[<span class="st">&#39;name&#39;</span>, <span class="st">&#39;sex&#39;</span>, <span class="st">&#39;births&#39;</span>])</span>
<span id="cb42-6"><a href="#cb42-6"></a></span>
<span id="cb42-7"><a href="#cb42-7"></a>In [<span class="dv">97</span>]: names1880</span>
<span id="cb42-8"><a href="#cb42-8"></a>Out[<span class="dv">97</span>]: </span>
<span id="cb42-9"><a href="#cb42-9"></a>           name sex  births</span>
<span id="cb42-10"><a href="#cb42-10"></a><span class="dv">0</span>          Mary   F    <span class="dv">7065</span></span>
<span id="cb42-11"><a href="#cb42-11"></a><span class="dv">1</span>          Anna   F    <span class="dv">2604</span></span>
<span id="cb42-12"><a href="#cb42-12"></a><span class="dv">2</span>          Emma   F    <span class="dv">2003</span></span>
<span id="cb42-13"><a href="#cb42-13"></a><span class="dv">3</span>     Elizabeth   F    <span class="dv">1939</span></span>
<span id="cb42-14"><a href="#cb42-14"></a><span class="dv">4</span>        Minnie   F    <span class="dv">1746</span></span>
<span id="cb42-15"><a href="#cb42-15"></a>...         ...  ..     ...</span>
<span id="cb42-16"><a href="#cb42-16"></a><span class="dv">1995</span>     Woodie   M       <span class="dv">5</span></span>
<span id="cb42-17"><a href="#cb42-17"></a><span class="dv">1996</span>     Worthy   M       <span class="dv">5</span></span>
<span id="cb42-18"><a href="#cb42-18"></a><span class="dv">1997</span>     Wright   M       <span class="dv">5</span></span>
<span id="cb42-19"><a href="#cb42-19"></a><span class="dv">1998</span>       York   M       <span class="dv">5</span></span>
<span id="cb42-20"><a href="#cb42-20"></a><span class="dv">1999</span>  Zachariah   M       <span class="dv">5</span></span>
<span id="cb42-21"><a href="#cb42-21"></a>[<span class="dv">2000</span> rows x <span class="dv">3</span> columns]</span></code></pre></div>
<p>这些文件中仅含有当年出现超过5次的名字。为了简单起见，我们可以用births列的sex分组小计表示该年度的births总计：</p>
<div class="sourceCode" id="cb43"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb43-1"><a href="#cb43-1"></a>In [<span class="dv">98</span>]: names1880.groupby(<span class="st">&#39;sex&#39;</span>).births.<span class="bu">sum</span>()</span>
<span id="cb43-2"><a href="#cb43-2"></a>Out[<span class="dv">98</span>]: </span>
<span id="cb43-3"><a href="#cb43-3"></a>sex</span>
<span id="cb43-4"><a href="#cb43-4"></a>F     <span class="dv">90993</span></span>
<span id="cb43-5"><a href="#cb43-5"></a>M    <span class="dv">110493</span></span>
<span id="cb43-6"><a href="#cb43-6"></a>Name: births, dtype: int64</span></code></pre></div>
<p>由于该数据集按年度被分隔成了多个文件，所以第一件事情就是要将所有数据都组装到一个DataFrame里面，并加上一个year字段。使用pandas.concat即可达到这个目的：</p>
<div class="sourceCode" id="cb44"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb44-1"><a href="#cb44-1"></a>years <span class="op">=</span> <span class="bu">range</span>(<span class="dv">1880</span>, <span class="dv">2011</span>)</span>
<span id="cb44-2"><a href="#cb44-2"></a></span>
<span id="cb44-3"><a href="#cb44-3"></a>pieces <span class="op">=</span> []</span>
<span id="cb44-4"><a href="#cb44-4"></a>columns <span class="op">=</span> [<span class="st">&#39;name&#39;</span>, <span class="st">&#39;sex&#39;</span>, <span class="st">&#39;births&#39;</span>]</span>
<span id="cb44-5"><a href="#cb44-5"></a></span>
<span id="cb44-6"><a href="#cb44-6"></a><span class="cf">for</span> year <span class="kw">in</span> years:</span>
<span id="cb44-7"><a href="#cb44-7"></a>    path <span class="op">=</span> <span class="st">&#39;datasets/babynames/yob</span><span class="sc">%d</span><span class="st">.txt&#39;</span> <span class="op">%</span> year</span>
<span id="cb44-8"><a href="#cb44-8"></a>    frame <span class="op">=</span> pd.read_csv(path, names<span class="op">=</span>columns)</span>
<span id="cb44-9"><a href="#cb44-9"></a></span>
<span id="cb44-10"><a href="#cb44-10"></a>    frame[<span class="st">&#39;year&#39;</span>] <span class="op">=</span> year</span>
<span id="cb44-11"><a href="#cb44-11"></a>    pieces.append(frame)</span>
<span id="cb44-12"><a href="#cb44-12"></a></span>
<span id="cb44-13"><a href="#cb44-13"></a><span class="co"># Concatenate everything into a single DataFrame</span></span>
<span id="cb44-14"><a href="#cb44-14"></a>names <span class="op">=</span> pd.concat(pieces, ignore_index<span class="op">=</span><span class="va">True</span>)</span></code></pre></div>
<p>这里需要注意几件事情。第一，concat默认是按行将多个DataFrame组合到一起的；第二，必须指定ignore_index=True，因为我们不希望保留read_csv所返回的原始行号。现在我们得到了一个非常大的DataFrame，它含有全部的名字数据：</p>
<div class="sourceCode" id="cb45"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb45-1"><a href="#cb45-1"></a>In [<span class="dv">100</span>]: names</span>
<span id="cb45-2"><a href="#cb45-2"></a>Out[<span class="dv">100</span>]: </span>
<span id="cb45-3"><a href="#cb45-3"></a>              name sex  births  year</span>
<span id="cb45-4"><a href="#cb45-4"></a><span class="dv">0</span>             Mary   F    <span class="dv">7065</span>  <span class="dv">1880</span></span>
<span id="cb45-5"><a href="#cb45-5"></a><span class="dv">1</span>             Anna   F    <span class="dv">2604</span>  <span class="dv">1880</span></span>
<span id="cb45-6"><a href="#cb45-6"></a><span class="dv">2</span>             Emma   F    <span class="dv">2003</span>  <span class="dv">1880</span></span>
<span id="cb45-7"><a href="#cb45-7"></a><span class="dv">3</span>        Elizabeth   F    <span class="dv">1939</span>  <span class="dv">1880</span></span>
<span id="cb45-8"><a href="#cb45-8"></a><span class="dv">4</span>           Minnie   F    <span class="dv">1746</span>  <span class="dv">1880</span></span>
<span id="cb45-9"><a href="#cb45-9"></a>...            ...  ..     ...   ...</span>
<span id="cb45-10"><a href="#cb45-10"></a><span class="dv">1690779</span>    Zymaire   M       <span class="dv">5</span>  <span class="dv">2010</span></span>
<span id="cb45-11"><a href="#cb45-11"></a><span class="dv">1690780</span>     Zyonne   M       <span class="dv">5</span>  <span class="dv">2010</span></span>
<span id="cb45-12"><a href="#cb45-12"></a><span class="dv">1690781</span>  Zyquarius   M       <span class="dv">5</span>  <span class="dv">2010</span></span>
<span id="cb45-13"><a href="#cb45-13"></a><span class="dv">1690782</span>      Zyran   M       <span class="dv">5</span>  <span class="dv">2010</span></span>
<span id="cb45-14"><a href="#cb45-14"></a><span class="dv">1690783</span>      Zzyzx   M       <span class="dv">5</span>  <span class="dv">2010</span></span>
<span id="cb45-15"><a href="#cb45-15"></a>[<span class="dv">1690784</span> rows x <span class="dv">4</span> columns]</span></code></pre></div>
<p>有了这些数据之后，我们就可以利用groupby或pivot_table在year和sex级别上对其进行聚合了，如图14-4所示：</p>
<div class="sourceCode" id="cb46"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb46-1"><a href="#cb46-1"></a>In [<span class="dv">101</span>]: total_births <span class="op">=</span> names.pivot_table(<span class="st">&#39;births&#39;</span>, index<span class="op">=</span><span class="st">&#39;year&#39;</span>,</span>
<span id="cb46-2"><a href="#cb46-2"></a>   .....:                                  columns<span class="op">=</span><span class="st">&#39;sex&#39;</span>, aggfunc<span class="op">=</span><span class="bu">sum</span>)</span>
<span id="cb46-3"><a href="#cb46-3"></a></span>
<span id="cb46-4"><a href="#cb46-4"></a>In [<span class="dv">102</span>]: total_births.tail()</span>
<span id="cb46-5"><a href="#cb46-5"></a>Out[<span class="dv">102</span>]: </span>
<span id="cb46-6"><a href="#cb46-6"></a>sex         F        M</span>
<span id="cb46-7"><a href="#cb46-7"></a>year                  </span>
<span id="cb46-8"><a href="#cb46-8"></a><span class="dv">2006</span>  <span class="dv">1896468</span>  <span class="dv">2050234</span></span>
<span id="cb46-9"><a href="#cb46-9"></a><span class="dv">2007</span>  <span class="dv">1916888</span>  <span class="dv">2069242</span></span>
<span id="cb46-10"><a href="#cb46-10"></a><span class="dv">2008</span>  <span class="dv">1883645</span>  <span class="dv">2032310</span></span>
<span id="cb46-11"><a href="#cb46-11"></a><span class="dv">2009</span>  <span class="dv">1827643</span>  <span class="dv">1973359</span></span>
<span id="cb46-12"><a href="#cb46-12"></a><span class="dv">2010</span>  <span class="dv">1759010</span>  <span class="dv">1898382</span></span>
<span id="cb46-13"><a href="#cb46-13"></a></span>
<span id="cb46-14"><a href="#cb46-14"></a>In [<span class="dv">103</span>]: total_births.plot(title<span class="op">=</span><span class="st">&#39;Total births by sex and year&#39;</span>)</span></code></pre></div>
<figure>
<img src="http://upload-images.jianshu.io/upload_images/7178691-7643b150d88aae11.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="" /><figcaption>图14-4 按性别和年度统计的总出生数</figcaption>
</figure>
<p>下面我们来插入一个prop列，用于存放指定名字的婴儿数相对于总出生数的比例。prop值为0.02表示每100名婴儿中有2名取了当前这个名字。因此，我们先按year和sex分组，然后再将新列加到各个分组上：</p>
<div class="sourceCode" id="cb47"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb47-1"><a href="#cb47-1"></a><span class="kw">def</span> add_prop(group):</span>
<span id="cb47-2"><a href="#cb47-2"></a>    group[<span class="st">&#39;prop&#39;</span>] <span class="op">=</span> group.births <span class="op">/</span> group.births.<span class="bu">sum</span>()</span>
<span id="cb47-3"><a href="#cb47-3"></a>    <span class="cf">return</span> group</span>
<span id="cb47-4"><a href="#cb47-4"></a>names <span class="op">=</span> names.groupby([<span class="st">&#39;year&#39;</span>, <span class="st">&#39;sex&#39;</span>]).<span class="bu">apply</span>(add_prop)</span></code></pre></div>
<p>现在，完整的数据集就有了下面这些列：</p>
<div class="sourceCode" id="cb48"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb48-1"><a href="#cb48-1"></a>In [<span class="dv">105</span>]: names</span>
<span id="cb48-2"><a href="#cb48-2"></a>Out[<span class="dv">105</span>]: </span>
<span id="cb48-3"><a href="#cb48-3"></a>              name sex  births  year      prop</span>
<span id="cb48-4"><a href="#cb48-4"></a><span class="dv">0</span>             Mary   F    <span class="dv">7065</span>  <span class="dv">1880</span>  <span class="fl">0.077643</span></span>
<span id="cb48-5"><a href="#cb48-5"></a><span class="dv">1</span>             Anna   F    <span class="dv">2604</span>  <span class="dv">1880</span>  <span class="fl">0.028618</span></span>
<span id="cb48-6"><a href="#cb48-6"></a><span class="dv">2</span>             Emma   F    <span class="dv">2003</span>  <span class="dv">1880</span>  <span class="fl">0.022013</span></span>
<span id="cb48-7"><a href="#cb48-7"></a><span class="dv">3</span>        Elizabeth   F    <span class="dv">1939</span>  <span class="dv">1880</span>  <span class="fl">0.021309</span></span>
<span id="cb48-8"><a href="#cb48-8"></a><span class="dv">4</span>           Minnie   F    <span class="dv">1746</span>  <span class="dv">1880</span>  <span class="fl">0.019188</span></span>
<span id="cb48-9"><a href="#cb48-9"></a>...            ...  ..     ...   ...       ...</span>
<span id="cb48-10"><a href="#cb48-10"></a><span class="dv">1690779</span>    Zymaire   M       <span class="dv">5</span>  <span class="dv">2010</span>  <span class="fl">0.000003</span></span>
<span id="cb48-11"><a href="#cb48-11"></a><span class="dv">1690780</span>     Zyonne   M       <span class="dv">5</span>  <span class="dv">2010</span>  <span class="fl">0.000003</span></span>
<span id="cb48-12"><a href="#cb48-12"></a><span class="dv">1690781</span>  Zyquarius   M       <span class="dv">5</span>  <span class="dv">2010</span>  <span class="fl">0.000003</span></span>
<span id="cb48-13"><a href="#cb48-13"></a><span class="dv">1690782</span>      Zyran   M       <span class="dv">5</span>  <span class="dv">2010</span>  <span class="fl">0.000003</span></span>
<span id="cb48-14"><a href="#cb48-14"></a><span class="dv">1690783</span>      Zzyzx   M       <span class="dv">5</span>  <span class="dv">2010</span>  <span class="fl">0.000003</span></span>
<span id="cb48-15"><a href="#cb48-15"></a>[<span class="dv">1690784</span> rows x <span class="dv">5</span> columns]</span></code></pre></div>
<p>在执行这样的分组处理时，一般都应该做一些有效性检查，比如验证所有分组的prop的总和是否为1：</p>
<div class="sourceCode" id="cb49"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb49-1"><a href="#cb49-1"></a>In [<span class="dv">106</span>]: names.groupby([<span class="st">&#39;year&#39;</span>, <span class="st">&#39;sex&#39;</span>]).prop.<span class="bu">sum</span>()</span>
<span id="cb49-2"><a href="#cb49-2"></a>Out[<span class="dv">106</span>]: </span>
<span id="cb49-3"><a href="#cb49-3"></a>year  sex</span>
<span id="cb49-4"><a href="#cb49-4"></a><span class="dv">1880</span>  F      <span class="fl">1.0</span></span>
<span id="cb49-5"><a href="#cb49-5"></a>      M      <span class="fl">1.0</span></span>
<span id="cb49-6"><a href="#cb49-6"></a><span class="dv">1881</span>  F      <span class="fl">1.0</span></span>
<span id="cb49-7"><a href="#cb49-7"></a>      M      <span class="fl">1.0</span></span>
<span id="cb49-8"><a href="#cb49-8"></a><span class="dv">1882</span>  F      <span class="fl">1.0</span></span>
<span id="cb49-9"><a href="#cb49-9"></a>            ... </span>
<span id="cb49-10"><a href="#cb49-10"></a><span class="dv">2008</span>  M      <span class="fl">1.0</span></span>
<span id="cb49-11"><a href="#cb49-11"></a><span class="dv">2009</span>  F      <span class="fl">1.0</span></span>
<span id="cb49-12"><a href="#cb49-12"></a>      M      <span class="fl">1.0</span></span>
<span id="cb49-13"><a href="#cb49-13"></a><span class="dv">2010</span>  F      <span class="fl">1.0</span></span>
<span id="cb49-14"><a href="#cb49-14"></a>      M      <span class="fl">1.0</span></span>
<span id="cb49-15"><a href="#cb49-15"></a>Name: prop, Length: <span class="dv">262</span>, dtype: float64</span></code></pre></div>
<p>工作完成。为了便于实现更进一步的分析，我需要取出该数据的一个子集：每对sex/year组合的前1000个名字。这又是一个分组操作：</p>
<div class="sourceCode" id="cb50"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb50-1"><a href="#cb50-1"></a><span class="kw">def</span> get_top1000(group):</span>
<span id="cb50-2"><a href="#cb50-2"></a>    <span class="cf">return</span> group.sort_values(by<span class="op">=</span><span class="st">&#39;births&#39;</span>, ascending<span class="op">=</span><span class="va">False</span>)[:<span class="dv">1000</span>]</span>
<span id="cb50-3"><a href="#cb50-3"></a>grouped <span class="op">=</span> names.groupby([<span class="st">&#39;year&#39;</span>, <span class="st">&#39;sex&#39;</span>])</span>
<span id="cb50-4"><a href="#cb50-4"></a>top1000 <span class="op">=</span> grouped.<span class="bu">apply</span>(get_top1000)</span>
<span id="cb50-5"><a href="#cb50-5"></a><span class="co"># Drop the group index, not needed</span></span>
<span id="cb50-6"><a href="#cb50-6"></a>top1000.reset_index(inplace<span class="op">=</span><span class="va">True</span>, drop<span class="op">=</span><span class="va">True</span>)</span></code></pre></div>
<p>如果你喜欢DIY的话，也可以这样：</p>
<div class="sourceCode" id="cb51"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb51-1"><a href="#cb51-1"></a>pieces <span class="op">=</span> []</span>
<span id="cb51-2"><a href="#cb51-2"></a><span class="cf">for</span> year, group <span class="kw">in</span> names.groupby([<span class="st">&#39;year&#39;</span>, <span class="st">&#39;sex&#39;</span>]):</span>
<span id="cb51-3"><a href="#cb51-3"></a>    pieces.append(group.sort_values(by<span class="op">=</span><span class="st">&#39;births&#39;</span>, ascending<span class="op">=</span><span class="va">False</span>)[:<span class="dv">1000</span>])</span>
<span id="cb51-4"><a href="#cb51-4"></a>top1000 <span class="op">=</span> pd.concat(pieces, ignore_index<span class="op">=</span><span class="va">True</span>)</span></code></pre></div>
<p>现在的结果数据集就小多了：</p>
<div class="sourceCode" id="cb52"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb52-1"><a href="#cb52-1"></a>In [<span class="dv">108</span>]: top1000</span>
<span id="cb52-2"><a href="#cb52-2"></a>Out[<span class="dv">108</span>]: </span>
<span id="cb52-3"><a href="#cb52-3"></a>             name sex  births  year      prop</span>
<span id="cb52-4"><a href="#cb52-4"></a><span class="dv">0</span>            Mary   F    <span class="dv">7065</span>  <span class="dv">1880</span>  <span class="fl">0.077643</span></span>
<span id="cb52-5"><a href="#cb52-5"></a><span class="dv">1</span>            Anna   F    <span class="dv">2604</span>  <span class="dv">1880</span>  <span class="fl">0.028618</span></span>
<span id="cb52-6"><a href="#cb52-6"></a><span class="dv">2</span>            Emma   F    <span class="dv">2003</span>  <span class="dv">1880</span>  <span class="fl">0.022013</span></span>
<span id="cb52-7"><a href="#cb52-7"></a><span class="dv">3</span>       Elizabeth   F    <span class="dv">1939</span>  <span class="dv">1880</span>  <span class="fl">0.021309</span></span>
<span id="cb52-8"><a href="#cb52-8"></a><span class="dv">4</span>          Minnie   F    <span class="dv">1746</span>  <span class="dv">1880</span>  <span class="fl">0.019188</span></span>
<span id="cb52-9"><a href="#cb52-9"></a>...           ...  ..     ...   ...       ...</span>
<span id="cb52-10"><a href="#cb52-10"></a><span class="dv">261872</span>     Camilo   M     <span class="dv">194</span>  <span class="dv">2010</span>  <span class="fl">0.000102</span></span>
<span id="cb52-11"><a href="#cb52-11"></a><span class="dv">261873</span>     Destin   M     <span class="dv">194</span>  <span class="dv">2010</span>  <span class="fl">0.000102</span></span>
<span id="cb52-12"><a href="#cb52-12"></a><span class="dv">261874</span>     Jaquan   M     <span class="dv">194</span>  <span class="dv">2010</span>  <span class="fl">0.000102</span></span>
<span id="cb52-13"><a href="#cb52-13"></a><span class="dv">261875</span>     Jaydan   M     <span class="dv">194</span>  <span class="dv">2010</span>  <span class="fl">0.000102</span></span>
<span id="cb52-14"><a href="#cb52-14"></a><span class="dv">261876</span>     Maxton   M     <span class="dv">193</span>  <span class="dv">2010</span>  <span class="fl">0.000102</span></span>
<span id="cb52-15"><a href="#cb52-15"></a>[<span class="dv">261877</span> rows x <span class="dv">5</span> columns]</span></code></pre></div>
<p>接下来的数据分析工作就针对这个top1000数据集了。</p>
<h2 id="分析命名趋势">分析命名趋势</h2>
<p>有了完整的数据集和刚才生成的top1000数据集，我们就可以开始分析各种命名趋势了。首先将前1000个名字分为男女两个部分：</p>
<div class="sourceCode" id="cb53"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb53-1"><a href="#cb53-1"></a>In [<span class="dv">109</span>]: boys <span class="op">=</span> top1000[top1000.sex <span class="op">==</span> <span class="st">&#39;M&#39;</span>]</span>
<span id="cb53-2"><a href="#cb53-2"></a></span>
<span id="cb53-3"><a href="#cb53-3"></a>In [<span class="dv">110</span>]: girls <span class="op">=</span> top1000[top1000.sex <span class="op">==</span> <span class="st">&#39;F&#39;</span>]</span></code></pre></div>
<p>这是两个简单的时间序列，只需稍作整理即可绘制出相应的图表（比如每年叫做John和Mary的婴儿数）。我们先生成一张按year和name统计的总出生数透视表：</p>
<div class="sourceCode" id="cb54"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb54-1"><a href="#cb54-1"></a>In [<span class="dv">111</span>]: total_births <span class="op">=</span> top1000.pivot_table(<span class="st">&#39;births&#39;</span>, index<span class="op">=</span><span class="st">&#39;year&#39;</span>,</span>
<span id="cb54-2"><a href="#cb54-2"></a>   .....:                                    columns<span class="op">=</span><span class="st">&#39;name&#39;</span>,</span>
<span id="cb54-3"><a href="#cb54-3"></a>   .....:                                    aggfunc<span class="op">=</span><span class="bu">sum</span>)</span></code></pre></div>
<p>现在，我们用DataFrame的plot方法绘制几个名字的曲线图（见图14-5）：</p>
<div class="sourceCode" id="cb55"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb55-1"><a href="#cb55-1"></a>In [<span class="dv">112</span>]: total_births.info()</span>
<span id="cb55-2"><a href="#cb55-2"></a><span class="op">&lt;</span><span class="kw">class</span> <span class="st">&#39;pandas.core.frame.DataFrame&#39;</span><span class="op">&gt;</span></span>
<span id="cb55-3"><a href="#cb55-3"></a>Int64Index: <span class="dv">131</span> entries, <span class="dv">1880</span> to <span class="dv">2010</span></span>
<span id="cb55-4"><a href="#cb55-4"></a>Columns: <span class="dv">6868</span> entries, Aaden to Zuri</span>
<span id="cb55-5"><a href="#cb55-5"></a>dtypes: float64(<span class="dv">6868</span>)</span>
<span id="cb55-6"><a href="#cb55-6"></a>memory usage: <span class="fl">6.9</span> MB</span>
<span id="cb55-7"><a href="#cb55-7"></a></span>
<span id="cb55-8"><a href="#cb55-8"></a>In [<span class="dv">113</span>]: subset <span class="op">=</span> total_births[[<span class="st">&#39;John&#39;</span>, <span class="st">&#39;Harry&#39;</span>, <span class="st">&#39;Mary&#39;</span>, <span class="st">&#39;Marilyn&#39;</span>]]</span>
<span id="cb55-9"><a href="#cb55-9"></a></span>
<span id="cb55-10"><a href="#cb55-10"></a>In [<span class="dv">114</span>]: subset.plot(subplots<span class="op">=</span><span class="va">True</span>, figsize<span class="op">=</span>(<span class="dv">12</span>, <span class="dv">10</span>), grid<span class="op">=</span><span class="va">False</span>,</span>
<span id="cb55-11"><a href="#cb55-11"></a>   .....:             title<span class="op">=</span><span class="st">&quot;Number of births per year&quot;</span>)</span></code></pre></div>
<figure>
<img src="http://upload-images.jianshu.io/upload_images/7178691-33f0f97656367a53.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="" /><figcaption>图14-5 几个男孩和女孩名字随时间变化的使用数量</figcaption>
</figure>
<p>从图中可以看出，这几个名字在美国人民的心目中已经风光不再了。但事实并非如此简单，我们在下一节中就能知道是怎么一回事了。</p>
<h2 id="评估命名多样性的增长">评估命名多样性的增长</h2>
<p>一种解释是父母愿意给小孩起常见的名字越来越少。这个假设可以从数据中得到验证。一个办法是计算最流行的1000个名字所占的比例，我按year和sex进行聚合并绘图（见图14-6）：</p>
<div class="sourceCode" id="cb56"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb56-1"><a href="#cb56-1"></a>In [<span class="dv">116</span>]: table <span class="op">=</span> top1000.pivot_table(<span class="st">&#39;prop&#39;</span>, index<span class="op">=</span><span class="st">&#39;year&#39;</span>,</span>
<span id="cb56-2"><a href="#cb56-2"></a>   .....:                             columns<span class="op">=</span><span class="st">&#39;sex&#39;</span>, aggfunc<span class="op">=</span><span class="bu">sum</span>)</span>
<span id="cb56-3"><a href="#cb56-3"></a></span>
<span id="cb56-4"><a href="#cb56-4"></a>In [<span class="dv">117</span>]: table.plot(title<span class="op">=</span><span class="st">&#39;Sum of table1000.prop by year and sex&#39;</span>,</span>
<span id="cb56-5"><a href="#cb56-5"></a>   .....:            yticks<span class="op">=</span>np.linspace(<span class="dv">0</span>, <span class="fl">1.2</span>, <span class="dv">13</span>), xticks<span class="op">=</span><span class="bu">range</span>(<span class="dv">1880</span>, <span class="dv">2020</span>, <span class="dv">10</span>)</span>
<span id="cb56-6"><a href="#cb56-6"></a>)</span></code></pre></div>
<figure>
<img src="http://upload-images.jianshu.io/upload_images/7178691-63e1ddc326a033b9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="" /><figcaption>图14-6 分性别统计的前1000个名字在总出生人数中的比例</figcaption>
</figure>
<p>从图中可以看出，名字的多样性确实出现了增长（前1000项的比例降低）。另一个办法是计算占总出生人数前50%的不同名字的数量，这个数字不太好计算。我们只考虑2010年男孩的名字：</p>
<div class="sourceCode" id="cb57"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb57-1"><a href="#cb57-1"></a>In [<span class="dv">118</span>]: df <span class="op">=</span> boys[boys.year <span class="op">==</span> <span class="dv">2010</span>]</span>
<span id="cb57-2"><a href="#cb57-2"></a></span>
<span id="cb57-3"><a href="#cb57-3"></a>In [<span class="dv">119</span>]: df</span>
<span id="cb57-4"><a href="#cb57-4"></a>Out[<span class="dv">119</span>]: </span>
<span id="cb57-5"><a href="#cb57-5"></a>           name sex  births  year      prop</span>
<span id="cb57-6"><a href="#cb57-6"></a><span class="dv">260877</span>    Jacob   M   <span class="dv">21875</span>  <span class="dv">2010</span>  <span class="fl">0.011523</span></span>
<span id="cb57-7"><a href="#cb57-7"></a><span class="dv">260878</span>    Ethan   M   <span class="dv">17866</span>  <span class="dv">2010</span>  <span class="fl">0.009411</span></span>
<span id="cb57-8"><a href="#cb57-8"></a><span class="dv">260879</span>  Michael   M   <span class="dv">17133</span>  <span class="dv">2010</span>  <span class="fl">0.009025</span></span>
<span id="cb57-9"><a href="#cb57-9"></a><span class="dv">260880</span>   Jayden   M   <span class="dv">17030</span>  <span class="dv">2010</span>  <span class="fl">0.008971</span></span>
<span id="cb57-10"><a href="#cb57-10"></a><span class="dv">260881</span>  William   M   <span class="dv">16870</span>  <span class="dv">2010</span>  <span class="fl">0.008887</span></span>
<span id="cb57-11"><a href="#cb57-11"></a>...         ...  ..     ...   ...       ...</span>
<span id="cb57-12"><a href="#cb57-12"></a><span class="dv">261872</span>   Camilo   M     <span class="dv">194</span>  <span class="dv">2010</span>  <span class="fl">0.000102</span></span>
<span id="cb57-13"><a href="#cb57-13"></a><span class="dv">261873</span>   Destin   M     <span class="dv">194</span>  <span class="dv">2010</span>  <span class="fl">0.000102</span></span>
<span id="cb57-14"><a href="#cb57-14"></a><span class="dv">261874</span>   Jaquan   M     <span class="dv">194</span>  <span class="dv">2010</span>  <span class="fl">0.000102</span></span>
<span id="cb57-15"><a href="#cb57-15"></a><span class="dv">261875</span>   Jaydan   M     <span class="dv">194</span>  <span class="dv">2010</span>  <span class="fl">0.000102</span></span>
<span id="cb57-16"><a href="#cb57-16"></a><span class="dv">261876</span>   Maxton   M     <span class="dv">193</span>  <span class="dv">2010</span>  <span class="fl">0.000102</span></span>
<span id="cb57-17"><a href="#cb57-17"></a>[<span class="dv">1000</span> rows x <span class="dv">5</span> columns]</span></code></pre></div>
<p>在对prop降序排列之后，我们想知道前面多少个名字的人数加起来才够50%。虽然编写一个for循环确实也能达到目的，但NumPy有一种更聪明的矢量方式。先计算prop的累计和cumsum，然后再通过searchsorted方法找出0.5应该被插入在哪个位置才能保证不破坏顺序：</p>
<div class="sourceCode" id="cb58"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb58-1"><a href="#cb58-1"></a>In [<span class="dv">120</span>]: prop_cumsum <span class="op">=</span> df.sort_values(by<span class="op">=</span><span class="st">&#39;prop&#39;</span>, ascending<span class="op">=</span><span class="va">False</span>).prop.cumsum()</span>
<span id="cb58-2"><a href="#cb58-2"></a></span>
<span id="cb58-3"><a href="#cb58-3"></a>In [<span class="dv">121</span>]: prop_cumsum[:<span class="dv">10</span>]</span>
<span id="cb58-4"><a href="#cb58-4"></a>Out[<span class="dv">121</span>]: </span>
<span id="cb58-5"><a href="#cb58-5"></a><span class="dv">260877</span>    <span class="fl">0.011523</span></span>
<span id="cb58-6"><a href="#cb58-6"></a><span class="dv">260878</span>    <span class="fl">0.020934</span></span>
<span id="cb58-7"><a href="#cb58-7"></a><span class="dv">260879</span>    <span class="fl">0.029959</span></span>
<span id="cb58-8"><a href="#cb58-8"></a><span class="dv">260880</span>    <span class="fl">0.038930</span></span>
<span id="cb58-9"><a href="#cb58-9"></a><span class="dv">260881</span>    <span class="fl">0.047817</span></span>
<span id="cb58-10"><a href="#cb58-10"></a><span class="dv">260882</span>    <span class="fl">0.056579</span></span>
<span id="cb58-11"><a href="#cb58-11"></a><span class="dv">260883</span>    <span class="fl">0.065155</span></span>
<span id="cb58-12"><a href="#cb58-12"></a><span class="dv">260884</span>    <span class="fl">0.073414</span></span>
<span id="cb58-13"><a href="#cb58-13"></a><span class="dv">260885</span>    <span class="fl">0.081528</span></span>
<span id="cb58-14"><a href="#cb58-14"></a><span class="dv">260886</span>    <span class="fl">0.089621</span></span>
<span id="cb58-15"><a href="#cb58-15"></a>Name: prop, dtype: float64</span>
<span id="cb58-16"><a href="#cb58-16"></a></span>
<span id="cb58-17"><a href="#cb58-17"></a>In [<span class="dv">122</span>]: prop_cumsum.values.searchsorted(<span class="fl">0.5</span>)</span>
<span id="cb58-18"><a href="#cb58-18"></a>Out[<span class="dv">122</span>]: <span class="dv">116</span></span></code></pre></div>
<p>由于数组索引是从0开始的，因此我们要给这个结果加1，即最终结果为117。拿1900年的数据来做个比较，这个数字要小得多：</p>
<div class="sourceCode" id="cb59"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb59-1"><a href="#cb59-1"></a>In [<span class="dv">123</span>]: df <span class="op">=</span> boys[boys.year <span class="op">==</span> <span class="dv">1900</span>]</span>
<span id="cb59-2"><a href="#cb59-2"></a></span>
<span id="cb59-3"><a href="#cb59-3"></a>In [<span class="dv">124</span>]: in1900 <span class="op">=</span> df.sort_values(by<span class="op">=</span><span class="st">&#39;prop&#39;</span>, ascending<span class="op">=</span><span class="va">False</span>).prop.cumsum()</span>
<span id="cb59-4"><a href="#cb59-4"></a></span>
<span id="cb59-5"><a href="#cb59-5"></a>In [<span class="dv">125</span>]: in1900.values.searchsorted(<span class="fl">0.5</span>) <span class="op">+</span> <span class="dv">1</span></span>
<span id="cb59-6"><a href="#cb59-6"></a>Out[<span class="dv">125</span>]: <span class="dv">25</span></span></code></pre></div>
<p>现在就可以对所有year/sex组合执行这个计算了。按这两个字段进行groupby处理，然后用一个函数计算各分组的这个值：</p>
<div class="sourceCode" id="cb60"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb60-1"><a href="#cb60-1"></a><span class="kw">def</span> get_quantile_count(group, q<span class="op">=</span><span class="fl">0.5</span>):</span>
<span id="cb60-2"><a href="#cb60-2"></a>    group <span class="op">=</span> group.sort_values(by<span class="op">=</span><span class="st">&#39;prop&#39;</span>, ascending<span class="op">=</span><span class="va">False</span>)</span>
<span id="cb60-3"><a href="#cb60-3"></a>    <span class="cf">return</span> group.prop.cumsum().values.searchsorted(q) <span class="op">+</span> <span class="dv">1</span></span>
<span id="cb60-4"><a href="#cb60-4"></a></span>
<span id="cb60-5"><a href="#cb60-5"></a>diversity <span class="op">=</span> top1000.groupby([<span class="st">&#39;year&#39;</span>, <span class="st">&#39;sex&#39;</span>]).<span class="bu">apply</span>(get_quantile_count)</span>
<span id="cb60-6"><a href="#cb60-6"></a>diversity <span class="op">=</span> diversity.unstack(<span class="st">&#39;sex&#39;</span>)</span></code></pre></div>
<p>现在，diversity这个DataFrame拥有两个时间序列（每个性别各一个，按年度索引）。通过IPython，你可以查看其内容，还可以像之前那样绘制图表（如图14-7所示）：</p>
<div class="sourceCode" id="cb61"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb61-1"><a href="#cb61-1"></a>In [<span class="dv">128</span>]: diversity.head()</span>
<span id="cb61-2"><a href="#cb61-2"></a>Out[<span class="dv">128</span>]: </span>
<span id="cb61-3"><a href="#cb61-3"></a>sex    F   M</span>
<span id="cb61-4"><a href="#cb61-4"></a>year        </span>
<span id="cb61-5"><a href="#cb61-5"></a><span class="dv">1880</span>  <span class="dv">38</span>  <span class="dv">14</span></span>
<span id="cb61-6"><a href="#cb61-6"></a><span class="dv">1881</span>  <span class="dv">38</span>  <span class="dv">14</span></span>
<span id="cb61-7"><a href="#cb61-7"></a><span class="dv">1882</span>  <span class="dv">38</span>  <span class="dv">15</span></span>
<span id="cb61-8"><a href="#cb61-8"></a><span class="dv">1883</span>  <span class="dv">39</span>  <span class="dv">15</span></span>
<span id="cb61-9"><a href="#cb61-9"></a><span class="dv">1884</span>  <span class="dv">39</span>  <span class="dv">16</span></span>
<span id="cb61-10"><a href="#cb61-10"></a></span>
<span id="cb61-11"><a href="#cb61-11"></a>In [<span class="dv">129</span>]: diversity.plot(title<span class="op">=</span><span class="st">&quot;Number of popular names in top 50%&quot;</span>)</span></code></pre></div>
<figure>
<img src="http://upload-images.jianshu.io/upload_images/7178691-574b53a383cad681.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="" /><figcaption>图14-7 按年度统计的密度表</figcaption>
</figure>
<p>从图中可以看出，女孩名字的多样性总是比男孩的高，而且还在变得越来越高。读者们可以自己分析一下具体是什么在驱动这个多样性（比如拼写形式的变化）。</p>
<h2 id="最后一个字母的变革">“最后一个字母”的变革</h2>
<p>2007年，一名婴儿姓名研究人员Laura Wattenberg在她自己的网站上指出（http://www.babynamewizard.com）：近百年来，男孩名字在最后一个字母上的分布发生了显著的变化。为了了解具体的情况，我首先将全部出生数据在年度、性别以及末字母上进行了聚合：</p>
<div class="sourceCode" id="cb62"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb62-1"><a href="#cb62-1"></a><span class="co"># extract last letter from name column</span></span>
<span id="cb62-2"><a href="#cb62-2"></a>get_last_letter <span class="op">=</span> <span class="kw">lambda</span> x: x[<span class="op">-</span><span class="dv">1</span>]</span>
<span id="cb62-3"><a href="#cb62-3"></a>last_letters <span class="op">=</span> names.name.<span class="bu">map</span>(get_last_letter)</span>
<span id="cb62-4"><a href="#cb62-4"></a>last_letters.name <span class="op">=</span> <span class="st">&#39;last_letter&#39;</span></span>
<span id="cb62-5"><a href="#cb62-5"></a></span>
<span id="cb62-6"><a href="#cb62-6"></a>table <span class="op">=</span> names.pivot_table(<span class="st">&#39;births&#39;</span>, index<span class="op">=</span>last_letters,</span>
<span id="cb62-7"><a href="#cb62-7"></a>                          columns<span class="op">=</span>[<span class="st">&#39;sex&#39;</span>, <span class="st">&#39;year&#39;</span>], aggfunc<span class="op">=</span><span class="bu">sum</span>)</span></code></pre></div>
<p>然后，我选出具有一定代表性的三年，并输出前面几行：</p>
<div class="sourceCode" id="cb63"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb63-1"><a href="#cb63-1"></a>In [<span class="dv">131</span>]: subtable <span class="op">=</span> table.reindex(columns<span class="op">=</span>[<span class="dv">1910</span>, <span class="dv">1960</span>, <span class="dv">2010</span>], level<span class="op">=</span><span class="st">&#39;year&#39;</span>)</span>
<span id="cb63-2"><a href="#cb63-2"></a></span>
<span id="cb63-3"><a href="#cb63-3"></a>In [<span class="dv">132</span>]: subtable.head()</span>
<span id="cb63-4"><a href="#cb63-4"></a>Out[<span class="dv">132</span>]: </span>
<span id="cb63-5"><a href="#cb63-5"></a>sex                 F                            M                    </span>
<span id="cb63-6"><a href="#cb63-6"></a>year             <span class="dv">1910</span>      <span class="dv">1960</span>      <span class="dv">2010</span>     <span class="dv">1910</span>      <span class="dv">1960</span>      <span class="dv">2010</span></span>
<span id="cb63-7"><a href="#cb63-7"></a>last_letter                                                           </span>
<span id="cb63-8"><a href="#cb63-8"></a>a            <span class="fl">108376.0</span>  <span class="fl">691247.0</span>  <span class="fl">670605.0</span>    <span class="fl">977.0</span>    <span class="fl">5204.0</span>   <span class="fl">28438.0</span></span>
<span id="cb63-9"><a href="#cb63-9"></a>b                 NaN     <span class="fl">694.0</span>     <span class="fl">450.0</span>    <span class="fl">411.0</span>    <span class="fl">3912.0</span>   <span class="fl">38859.0</span></span>
<span id="cb63-10"><a href="#cb63-10"></a>c                 <span class="fl">5.0</span>      <span class="fl">49.0</span>     <span class="fl">946.0</span>    <span class="fl">482.0</span>   <span class="fl">15476.0</span>   <span class="fl">23125.0</span></span>
<span id="cb63-11"><a href="#cb63-11"></a>d              <span class="fl">6750.0</span>    <span class="fl">3729.0</span>    <span class="fl">2607.0</span>  <span class="fl">22111.0</span>  <span class="fl">262112.0</span>   <span class="fl">44398.0</span></span>
<span id="cb63-12"><a href="#cb63-12"></a>e            <span class="fl">133569.0</span>  <span class="fl">435013.0</span>  <span class="fl">313833.0</span>  <span class="fl">28655.0</span>  <span class="fl">178823.0</span>  <span class="fl">129012.0</span></span></code></pre></div>
<p>接下来我们需要按总出生数对该表进行规范化处理，以便计算出各性别各末字母占总出生人数的比例：</p>
<div class="sourceCode" id="cb64"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb64-1"><a href="#cb64-1"></a>In [<span class="dv">133</span>]: subtable.<span class="bu">sum</span>()</span>
<span id="cb64-2"><a href="#cb64-2"></a>Out[<span class="dv">133</span>]: </span>
<span id="cb64-3"><a href="#cb64-3"></a>sex  year</span>
<span id="cb64-4"><a href="#cb64-4"></a>F    <span class="dv">1910</span>     <span class="fl">396416.0</span></span>
<span id="cb64-5"><a href="#cb64-5"></a>     <span class="dv">1960</span>    <span class="fl">2022062.0</span></span>
<span id="cb64-6"><a href="#cb64-6"></a>     <span class="dv">2010</span>    <span class="fl">1759010.0</span></span>
<span id="cb64-7"><a href="#cb64-7"></a>M    <span class="dv">1910</span>     <span class="fl">194198.0</span></span>
<span id="cb64-8"><a href="#cb64-8"></a>     <span class="dv">1960</span>    <span class="fl">2132588.0</span></span>
<span id="cb64-9"><a href="#cb64-9"></a><span class="dv">2010</span>    <span class="fl">1898382.0</span></span>
<span id="cb64-10"><a href="#cb64-10"></a>dtype: float64</span>
<span id="cb64-11"><a href="#cb64-11"></a></span>
<span id="cb64-12"><a href="#cb64-12"></a>In [<span class="dv">134</span>]: letter_prop <span class="op">=</span> subtable <span class="op">/</span> subtable.<span class="bu">sum</span>()</span>
<span id="cb64-13"><a href="#cb64-13"></a></span>
<span id="cb64-14"><a href="#cb64-14"></a>In [<span class="dv">135</span>]: letter_prop</span>
<span id="cb64-15"><a href="#cb64-15"></a>Out[<span class="dv">135</span>]: </span>
<span id="cb64-16"><a href="#cb64-16"></a>sex                 F                             M                    </span>
<span id="cb64-17"><a href="#cb64-17"></a>year             <span class="dv">1910</span>      <span class="dv">1960</span>      <span class="dv">2010</span>      <span class="dv">1910</span>      <span class="dv">1960</span>      <span class="dv">2010</span></span>
<span id="cb64-18"><a href="#cb64-18"></a>last_letter                                                            </span>
<span id="cb64-19"><a href="#cb64-19"></a>a            <span class="fl">0.273390</span>  <span class="fl">0.341853</span>  <span class="fl">0.381240</span>  <span class="fl">0.005031</span>  <span class="fl">0.002440</span>  <span class="fl">0.014980</span></span>
<span id="cb64-20"><a href="#cb64-20"></a>b                 NaN  <span class="fl">0.000343</span>  <span class="fl">0.000256</span>  <span class="fl">0.002116</span>  <span class="fl">0.001834</span>  <span class="fl">0.020470</span></span>
<span id="cb64-21"><a href="#cb64-21"></a>c            <span class="fl">0.000013</span>  <span class="fl">0.000024</span>  <span class="fl">0.000538</span>  <span class="fl">0.002482</span>  <span class="fl">0.007257</span>  <span class="fl">0.012181</span></span>
<span id="cb64-22"><a href="#cb64-22"></a>d            <span class="fl">0.017028</span>  <span class="fl">0.001844</span>  <span class="fl">0.001482</span>  <span class="fl">0.113858</span>  <span class="fl">0.122908</span>  <span class="fl">0.023387</span></span>
<span id="cb64-23"><a href="#cb64-23"></a>e            <span class="fl">0.336941</span>  <span class="fl">0.215133</span>  <span class="fl">0.178415</span>  <span class="fl">0.147556</span>  <span class="fl">0.083853</span>  <span class="fl">0.067959</span></span>
<span id="cb64-24"><a href="#cb64-24"></a>...               ...       ...       ...       ...       ...       ...</span>
<span id="cb64-25"><a href="#cb64-25"></a>v                 NaN  <span class="fl">0.000060</span>  <span class="fl">0.000117</span>  <span class="fl">0.000113</span></span>
<span id="cb64-26"><a href="#cb64-26"></a><span class="fl">0.000037</span>  <span class="fl">0.001434</span></span>
<span id="cb64-27"><a href="#cb64-27"></a>w            <span class="fl">0.000020</span>  <span class="fl">0.000031</span>  <span class="fl">0.001182</span>  <span class="fl">0.006329</span>  <span class="fl">0.007711</span>  <span class="fl">0.016148</span></span>
<span id="cb64-28"><a href="#cb64-28"></a>x            <span class="fl">0.000015</span>  <span class="fl">0.000037</span>  <span class="fl">0.000727</span>  <span class="fl">0.003965</span>  <span class="fl">0.001851</span>  <span class="fl">0.008614</span></span>
<span id="cb64-29"><a href="#cb64-29"></a>y            <span class="fl">0.110972</span>  <span class="fl">0.152569</span>  <span class="fl">0.116828</span>  <span class="fl">0.077349</span>  <span class="fl">0.160987</span>  <span class="fl">0.058168</span></span>
<span id="cb64-30"><a href="#cb64-30"></a>z            <span class="fl">0.002439</span>  <span class="fl">0.000659</span>  <span class="fl">0.000704</span>  <span class="fl">0.000170</span>  <span class="fl">0.000184</span>  <span class="fl">0.001831</span></span>
<span id="cb64-31"><a href="#cb64-31"></a>[<span class="dv">26</span> rows x <span class="dv">6</span> columns]</span></code></pre></div>
<p>有了这个字母比例数据之后，就可以生成一张各年度各性别的条形图了，如图14-8所示：</p>
<div class="sourceCode" id="cb65"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb65-1"><a href="#cb65-1"></a><span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt</span>
<span id="cb65-2"><a href="#cb65-2"></a></span>
<span id="cb65-3"><a href="#cb65-3"></a>fig, axes <span class="op">=</span> plt.subplots(<span class="dv">2</span>, <span class="dv">1</span>, figsize<span class="op">=</span>(<span class="dv">10</span>, <span class="dv">8</span>))</span>
<span id="cb65-4"><a href="#cb65-4"></a>letter_prop[<span class="st">&#39;M&#39;</span>].plot(kind<span class="op">=</span><span class="st">&#39;bar&#39;</span>, rot<span class="op">=</span><span class="dv">0</span>, ax<span class="op">=</span>axes[<span class="dv">0</span>], title<span class="op">=</span><span class="st">&#39;Male&#39;</span>)</span>
<span id="cb65-5"><a href="#cb65-5"></a>letter_prop[<span class="st">&#39;F&#39;</span>].plot(kind<span class="op">=</span><span class="st">&#39;bar&#39;</span>, rot<span class="op">=</span><span class="dv">0</span>, ax<span class="op">=</span>axes[<span class="dv">1</span>], title<span class="op">=</span><span class="st">&#39;Female&#39;</span>,</span>
<span id="cb65-6"><a href="#cb65-6"></a>                      legend<span class="op">=</span><span class="va">False</span>)</span></code></pre></div>
<figure>
<img src="http://upload-images.jianshu.io/upload_images/7178691-67686f38e66ef5f1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="" /><figcaption>图14-8 男孩女孩名字中各个末字母的比例</figcaption>
</figure>
<p>可以看出，从20世纪60年代开始，以字母“n”结尾的男孩名字出现了显著的增长。回到之前创建的那个完整表，按年度和性别对其进行规范化处理，并在男孩名字中选取几个字母，最后进行转置以便将各个列做成一个时间序列：</p>
<div class="sourceCode" id="cb66"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb66-1"><a href="#cb66-1"></a>In [<span class="dv">138</span>]: letter_prop <span class="op">=</span> table <span class="op">/</span> table.<span class="bu">sum</span>()</span>
<span id="cb66-2"><a href="#cb66-2"></a></span>
<span id="cb66-3"><a href="#cb66-3"></a>In [<span class="dv">139</span>]: dny_ts <span class="op">=</span> letter_prop.loc[[<span class="st">&#39;d&#39;</span>, <span class="st">&#39;n&#39;</span>, <span class="st">&#39;y&#39;</span>], <span class="st">&#39;M&#39;</span>].T</span>
<span id="cb66-4"><a href="#cb66-4"></a></span>
<span id="cb66-5"><a href="#cb66-5"></a>In [<span class="dv">140</span>]: dny_ts.head()</span>
<span id="cb66-6"><a href="#cb66-6"></a>Out[<span class="dv">140</span>]: </span>
<span id="cb66-7"><a href="#cb66-7"></a>last_letter         d         n         y</span>
<span id="cb66-8"><a href="#cb66-8"></a>year                                     </span>
<span id="cb66-9"><a href="#cb66-9"></a><span class="dv">1880</span>         <span class="fl">0.083055</span>  <span class="fl">0.153213</span>  <span class="fl">0.075760</span></span>
<span id="cb66-10"><a href="#cb66-10"></a><span class="dv">1881</span>         <span class="fl">0.083247</span>  <span class="fl">0.153214</span>  <span class="fl">0.077451</span></span>
<span id="cb66-11"><a href="#cb66-11"></a><span class="dv">1882</span>         <span class="fl">0.085340</span>  <span class="fl">0.149560</span>  <span class="fl">0.077537</span></span>
<span id="cb66-12"><a href="#cb66-12"></a><span class="dv">1883</span>         <span class="fl">0.084066</span>  <span class="fl">0.151646</span>  <span class="fl">0.079144</span></span>
<span id="cb66-13"><a href="#cb66-13"></a><span class="dv">1884</span>         <span class="fl">0.086120</span>  <span class="fl">0.149915</span>  <span class="fl">0.080405</span></span></code></pre></div>
<p>有了这个时间序列的DataFrame之后，就可以通过其plot方法绘制出一张趋势图了（如图14-9所示）：</p>
<div class="sourceCode" id="cb67"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb67-1"><a href="#cb67-1"></a>In [<span class="dv">143</span>]: dny_ts.plot()</span></code></pre></div>
<figure>
<img src="http://upload-images.jianshu.io/upload_images/7178691-51c431b2490424c2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="" /><figcaption>图14-9 各年出生的男孩中名字以d/n/y结尾的人数比例</figcaption>
</figure>
<h2 id="变成女孩名字的男孩名字以及相反的情况">变成女孩名字的男孩名字（以及相反的情况）</h2>
<p>另一个有趣的趋势是，早年流行于男孩的名字近年来“变性了”，例如Lesley或Leslie。回到top1000数据集，找出其中以“lesl”开头的一组名字：</p>
<div class="sourceCode" id="cb68"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb68-1"><a href="#cb68-1"></a>In [<span class="dv">144</span>]: all_names <span class="op">=</span> pd.Series(top1000.name.unique())</span>
<span id="cb68-2"><a href="#cb68-2"></a></span>
<span id="cb68-3"><a href="#cb68-3"></a>In [<span class="dv">145</span>]: lesley_like <span class="op">=</span> all_names[all_names.<span class="bu">str</span>.lower().<span class="bu">str</span>.contains(<span class="st">&#39;lesl&#39;</span>)]</span>
<span id="cb68-4"><a href="#cb68-4"></a></span>
<span id="cb68-5"><a href="#cb68-5"></a>In [<span class="dv">146</span>]: lesley_like</span>
<span id="cb68-6"><a href="#cb68-6"></a>Out[<span class="dv">146</span>]: </span>
<span id="cb68-7"><a href="#cb68-7"></a><span class="dv">632</span>     Leslie</span>
<span id="cb68-8"><a href="#cb68-8"></a><span class="dv">2294</span>    Lesley</span>
<span id="cb68-9"><a href="#cb68-9"></a><span class="dv">4262</span>    Leslee</span>
<span id="cb68-10"><a href="#cb68-10"></a><span class="dv">4728</span>     Lesli</span>
<span id="cb68-11"><a href="#cb68-11"></a><span class="dv">6103</span>     Lesly</span>
<span id="cb68-12"><a href="#cb68-12"></a>dtype: <span class="bu">object</span></span></code></pre></div>
<p>然后利用这个结果过滤其他的名字，并按名字分组计算出生数以查看相对频率：</p>
<div class="sourceCode" id="cb69"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb69-1"><a href="#cb69-1"></a>In [<span class="dv">147</span>]: filtered <span class="op">=</span> top1000[top1000.name.isin(lesley_like)]</span>
<span id="cb69-2"><a href="#cb69-2"></a></span>
<span id="cb69-3"><a href="#cb69-3"></a>In [<span class="dv">148</span>]: filtered.groupby(<span class="st">&#39;name&#39;</span>).births.<span class="bu">sum</span>()</span>
<span id="cb69-4"><a href="#cb69-4"></a>Out[<span class="dv">148</span>]: </span>
<span id="cb69-5"><a href="#cb69-5"></a>name</span>
<span id="cb69-6"><a href="#cb69-6"></a>Leslee      <span class="dv">1082</span></span>
<span id="cb69-7"><a href="#cb69-7"></a>Lesley     <span class="dv">35022</span></span>
<span id="cb69-8"><a href="#cb69-8"></a>Lesli        <span class="dv">929</span></span>
<span id="cb69-9"><a href="#cb69-9"></a>Leslie    <span class="dv">370429</span></span>
<span id="cb69-10"><a href="#cb69-10"></a>Lesly      <span class="dv">10067</span></span>
<span id="cb69-11"><a href="#cb69-11"></a>Name: births, dtype: int64</span></code></pre></div>
<p>接下来，我们按性别和年度进行聚合，并按年度进行规范化处理：</p>
<div class="sourceCode" id="cb70"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb70-1"><a href="#cb70-1"></a>In [<span class="dv">149</span>]: table <span class="op">=</span> filtered.pivot_table(<span class="st">&#39;births&#39;</span>, index<span class="op">=</span><span class="st">&#39;year&#39;</span>,</span>
<span id="cb70-2"><a href="#cb70-2"></a>   .....:                              columns<span class="op">=</span><span class="st">&#39;sex&#39;</span>, aggfunc<span class="op">=</span><span class="st">&#39;sum&#39;</span>)</span>
<span id="cb70-3"><a href="#cb70-3"></a></span>
<span id="cb70-4"><a href="#cb70-4"></a>In [<span class="dv">150</span>]: table <span class="op">=</span> table.div(table.<span class="bu">sum</span>(<span class="dv">1</span>), axis<span class="op">=</span><span class="dv">0</span>)</span>
<span id="cb70-5"><a href="#cb70-5"></a></span>
<span id="cb70-6"><a href="#cb70-6"></a>In [<span class="dv">151</span>]: table.tail()</span>
<span id="cb70-7"><a href="#cb70-7"></a>Out[<span class="dv">151</span>]: </span>
<span id="cb70-8"><a href="#cb70-8"></a>sex     F   M</span>
<span id="cb70-9"><a href="#cb70-9"></a>year         </span>
<span id="cb70-10"><a href="#cb70-10"></a><span class="dv">2006</span>  <span class="fl">1.0</span> NaN</span>
<span id="cb70-11"><a href="#cb70-11"></a><span class="dv">2007</span>  <span class="fl">1.0</span> NaN</span>
<span id="cb70-12"><a href="#cb70-12"></a><span class="dv">2008</span>  <span class="fl">1.0</span> NaN</span>
<span id="cb70-13"><a href="#cb70-13"></a><span class="dv">2009</span>  <span class="fl">1.0</span> NaN</span>
<span id="cb70-14"><a href="#cb70-14"></a><span class="dv">2010</span>  <span class="fl">1.0</span> NaN</span></code></pre></div>
<p>最后，就可以轻松绘制一张分性别的年度曲线图了（如图2-10所示）：</p>
<div class="sourceCode" id="cb71"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb71-1"><a href="#cb71-1"></a>In [<span class="dv">153</span>]: table.plot(style<span class="op">=</span>{<span class="st">&#39;M&#39;</span>: <span class="st">&#39;k-&#39;</span>, <span class="st">&#39;F&#39;</span>: <span class="st">&#39;k--&#39;</span>})</span></code></pre></div>
<figure>
<img src="http://upload-images.jianshu.io/upload_images/7178691-b99d98f8bb5fc695.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="" /><figcaption>图14-10 各年度使用“Lesley型”名字的男女比例</figcaption>
</figure>
<h1 id="usda食品数据库">14.4 USDA食品数据库</h1>
<p>美国农业部（USDA）制作了一份有关食物营养信息的数据库。Ashley Williams制作了该数据的JSON版（http://ashleyw.co.uk/project/food-nutrient-database）。其中的记录如下所示：</p>
<div class="sourceCode" id="cb72"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb72-1"><a href="#cb72-1"></a>{</span>
<span id="cb72-2"><a href="#cb72-2"></a>  <span class="st">&quot;id&quot;</span>: <span class="dv">21441</span>,</span>
<span id="cb72-3"><a href="#cb72-3"></a>  <span class="st">&quot;description&quot;</span>: <span class="st">&quot;KENTUCKY FRIED CHICKEN, Fried Chicken, EXTRA CRISPY,</span></span>
<span id="cb72-4"><a href="#cb72-4"></a><span class="st">Wing, meat and skin with breading&quot;</span>,</span>
<span id="cb72-5"><a href="#cb72-5"></a>  <span class="st">&quot;tags&quot;</span>: [<span class="st">&quot;KFC&quot;</span>],</span>
<span id="cb72-6"><a href="#cb72-6"></a>  <span class="st">&quot;manufacturer&quot;</span>: <span class="st">&quot;Kentucky Fried Chicken&quot;</span>,</span>
<span id="cb72-7"><a href="#cb72-7"></a><span class="st">&quot;group&quot;</span>: <span class="st">&quot;Fast Foods&quot;</span>,</span>
<span id="cb72-8"><a href="#cb72-8"></a>  <span class="st">&quot;portions&quot;</span>: [</span>
<span id="cb72-9"><a href="#cb72-9"></a>    {</span>
<span id="cb72-10"><a href="#cb72-10"></a>      <span class="st">&quot;amount&quot;</span>: <span class="dv">1</span>,</span>
<span id="cb72-11"><a href="#cb72-11"></a>      <span class="st">&quot;unit&quot;</span>: <span class="st">&quot;wing, with skin&quot;</span>,</span>
<span id="cb72-12"><a href="#cb72-12"></a>      <span class="st">&quot;grams&quot;</span>: <span class="fl">68.0</span></span>
<span id="cb72-13"><a href="#cb72-13"></a>    },</span>
<span id="cb72-14"><a href="#cb72-14"></a></span>
<span id="cb72-15"><a href="#cb72-15"></a>    ...</span>
<span id="cb72-16"><a href="#cb72-16"></a>  ],</span>
<span id="cb72-17"><a href="#cb72-17"></a>  <span class="st">&quot;nutrients&quot;</span>: [</span>
<span id="cb72-18"><a href="#cb72-18"></a>    {</span>
<span id="cb72-19"><a href="#cb72-19"></a>      <span class="st">&quot;value&quot;</span>: <span class="fl">20.8</span>,</span>
<span id="cb72-20"><a href="#cb72-20"></a>      <span class="st">&quot;units&quot;</span>: <span class="st">&quot;g&quot;</span>,</span>
<span id="cb72-21"><a href="#cb72-21"></a>      <span class="st">&quot;description&quot;</span>: <span class="st">&quot;Protein&quot;</span>,</span>
<span id="cb72-22"><a href="#cb72-22"></a>      <span class="st">&quot;group&quot;</span>: <span class="st">&quot;Composition&quot;</span></span>
<span id="cb72-23"><a href="#cb72-23"></a>    },</span>
<span id="cb72-24"><a href="#cb72-24"></a></span>
<span id="cb72-25"><a href="#cb72-25"></a>    ...</span>
<span id="cb72-26"><a href="#cb72-26"></a>  ]</span>
<span id="cb72-27"><a href="#cb72-27"></a>}</span></code></pre></div>
<p>每种食物都带有若干标识性属性以及两个有关营养成分和分量的列表。这种形式的数据不是很适合分析工作，因此我们需要做一些规整化以使其具有更好用的形式。</p>
<p>从上面列举的那个网址下载并解压数据之后，你可以用任何喜欢的JSON库将其加载到Python中。我用的是Python内置的json模块：</p>
<div class="sourceCode" id="cb73"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb73-1"><a href="#cb73-1"></a>In [<span class="dv">154</span>]: <span class="im">import</span> json</span>
<span id="cb73-2"><a href="#cb73-2"></a></span>
<span id="cb73-3"><a href="#cb73-3"></a>In [<span class="dv">155</span>]: db <span class="op">=</span> json.load(<span class="bu">open</span>(<span class="st">&#39;datasets/usda_food/database.json&#39;</span>))</span>
<span id="cb73-4"><a href="#cb73-4"></a></span>
<span id="cb73-5"><a href="#cb73-5"></a>In [<span class="dv">156</span>]: <span class="bu">len</span>(db)</span>
<span id="cb73-6"><a href="#cb73-6"></a>Out[<span class="dv">156</span>]: <span class="dv">6636</span></span></code></pre></div>
<p>db中的每个条目都是一个含有某种食物全部数据的字典。nutrients字段是一个字典列表，其中的每个字典对应一种营养成分：</p>
<div class="sourceCode" id="cb74"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb74-1"><a href="#cb74-1"></a>In [<span class="dv">157</span>]: db[<span class="dv">0</span>].keys()</span>
<span id="cb74-2"><a href="#cb74-2"></a>Out[<span class="dv">157</span>]: dict_keys([<span class="st">&#39;id&#39;</span>, <span class="st">&#39;description&#39;</span>, <span class="st">&#39;tags&#39;</span>, <span class="st">&#39;manufacturer&#39;</span>, <span class="st">&#39;group&#39;</span>, <span class="st">&#39;porti</span></span>
<span id="cb74-3"><a href="#cb74-3"></a><span class="st">ons&#39;</span>, <span class="st">&#39;nutrients&#39;</span>])</span>
<span id="cb74-4"><a href="#cb74-4"></a></span>
<span id="cb74-5"><a href="#cb74-5"></a>In [<span class="dv">158</span>]: db[<span class="dv">0</span>][<span class="st">&#39;nutrients&#39;</span>][<span class="dv">0</span>]</span>
<span id="cb74-6"><a href="#cb74-6"></a>Out[<span class="dv">158</span>]: </span>
<span id="cb74-7"><a href="#cb74-7"></a>{<span class="st">&#39;description&#39;</span>: <span class="st">&#39;Protein&#39;</span>,</span>
<span id="cb74-8"><a href="#cb74-8"></a> <span class="st">&#39;group&#39;</span>: <span class="st">&#39;Composition&#39;</span>,</span>
<span id="cb74-9"><a href="#cb74-9"></a> <span class="st">&#39;units&#39;</span>: <span class="st">&#39;g&#39;</span>,</span>
<span id="cb74-10"><a href="#cb74-10"></a> <span class="st">&#39;value&#39;</span>: <span class="fl">25.18</span>}</span>
<span id="cb74-11"><a href="#cb74-11"></a></span>
<span id="cb74-12"><a href="#cb74-12"></a>In [<span class="dv">159</span>]: nutrients <span class="op">=</span> pd.DataFrame(db[<span class="dv">0</span>][<span class="st">&#39;nutrients&#39;</span>])</span>
<span id="cb74-13"><a href="#cb74-13"></a></span>
<span id="cb74-14"><a href="#cb74-14"></a>In [<span class="dv">160</span>]: nutrients[:<span class="dv">7</span>]</span>
<span id="cb74-15"><a href="#cb74-15"></a>Out[<span class="dv">160</span>]: </span>
<span id="cb74-16"><a href="#cb74-16"></a>                   description        group units    value</span>
<span id="cb74-17"><a href="#cb74-17"></a><span class="dv">0</span>                      Protein  Composition     g    <span class="fl">25.18</span></span>
<span id="cb74-18"><a href="#cb74-18"></a><span class="dv">1</span>            Total lipid (fat)  Composition     g    <span class="fl">29.20</span></span>
<span id="cb74-19"><a href="#cb74-19"></a><span class="dv">2</span>  Carbohydrate, by difference  Composition     g     <span class="fl">3.06</span></span>
<span id="cb74-20"><a href="#cb74-20"></a><span class="dv">3</span>                          Ash        Other     g     <span class="fl">3.28</span></span>
<span id="cb74-21"><a href="#cb74-21"></a><span class="dv">4</span>                       Energy       Energy  kcal   <span class="fl">376.00</span></span>
<span id="cb74-22"><a href="#cb74-22"></a><span class="dv">5</span>                        Water  Composition     g    <span class="fl">39.28</span></span>
<span id="cb74-23"><a href="#cb74-23"></a><span class="dv">6</span>                       Energy       Energy    kJ  <span class="fl">1573.00</span></span></code></pre></div>
<p>在将字典列表转换为DataFrame时，可以只抽取其中的一部分字段。这里，我们将取出食物的名称、分类、编号以及制造商等信息：</p>
<div class="sourceCode" id="cb75"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb75-1"><a href="#cb75-1"></a>In [<span class="dv">161</span>]: info_keys <span class="op">=</span> [<span class="st">&#39;description&#39;</span>, <span class="st">&#39;group&#39;</span>, <span class="st">&#39;id&#39;</span>, <span class="st">&#39;manufacturer&#39;</span>]</span>
<span id="cb75-2"><a href="#cb75-2"></a></span>
<span id="cb75-3"><a href="#cb75-3"></a>In [<span class="dv">162</span>]: info <span class="op">=</span> pd.DataFrame(db, columns<span class="op">=</span>info_keys)</span>
<span id="cb75-4"><a href="#cb75-4"></a></span>
<span id="cb75-5"><a href="#cb75-5"></a>In [<span class="dv">163</span>]: info[:<span class="dv">5</span>]</span>
<span id="cb75-6"><a href="#cb75-6"></a>Out[<span class="dv">163</span>]: </span>
<span id="cb75-7"><a href="#cb75-7"></a>                          description                   group    <span class="bu">id</span>  <span class="op">\</span></span>
<span id="cb75-8"><a href="#cb75-8"></a><span class="dv">0</span>                     Cheese, caraway  Dairy <span class="kw">and</span> Egg Products  <span class="dv">1008</span>   </span>
<span id="cb75-9"><a href="#cb75-9"></a><span class="dv">1</span>                     Cheese, cheddar  Dairy <span class="kw">and</span> Egg Products  <span class="dv">1009</span></span>
<span id="cb75-10"><a href="#cb75-10"></a><span class="dv">2</span>                        Cheese, edam  Dairy <span class="kw">and</span> Egg Products  <span class="dv">1018</span>   </span>
<span id="cb75-11"><a href="#cb75-11"></a><span class="dv">3</span>                        Cheese, feta  Dairy <span class="kw">and</span> Egg Products  <span class="dv">1019</span>   </span>
<span id="cb75-12"><a href="#cb75-12"></a><span class="dv">4</span>  Cheese, mozzarella, part skim milk  Dairy <span class="kw">and</span> Egg Products  <span class="dv">1028</span>   </span>
<span id="cb75-13"><a href="#cb75-13"></a>  manufacturer  </span>
<span id="cb75-14"><a href="#cb75-14"></a><span class="dv">0</span>               </span>
<span id="cb75-15"><a href="#cb75-15"></a><span class="dv">1</span>               </span>
<span id="cb75-16"><a href="#cb75-16"></a><span class="dv">2</span>               </span>
<span id="cb75-17"><a href="#cb75-17"></a><span class="dv">3</span>               </span>
<span id="cb75-18"><a href="#cb75-18"></a><span class="dv">4</span>               </span>
<span id="cb75-19"><a href="#cb75-19"></a></span>
<span id="cb75-20"><a href="#cb75-20"></a>In [<span class="dv">164</span>]: info.info()</span>
<span id="cb75-21"><a href="#cb75-21"></a><span class="op">&lt;</span><span class="kw">class</span> <span class="st">&#39;pandas.core.frame.DataFrame&#39;</span><span class="op">&gt;</span></span>
<span id="cb75-22"><a href="#cb75-22"></a>RangeIndex: <span class="dv">6636</span> entries, <span class="dv">0</span> to <span class="dv">6635</span></span>
<span id="cb75-23"><a href="#cb75-23"></a>Data columns (total <span class="dv">4</span> columns):</span>
<span id="cb75-24"><a href="#cb75-24"></a>description     <span class="dv">6636</span> non<span class="op">-</span>null <span class="bu">object</span></span>
<span id="cb75-25"><a href="#cb75-25"></a>group           <span class="dv">6636</span> non<span class="op">-</span>null <span class="bu">object</span></span>
<span id="cb75-26"><a href="#cb75-26"></a><span class="bu">id</span>              <span class="dv">6636</span> non<span class="op">-</span>null int64</span>
<span id="cb75-27"><a href="#cb75-27"></a>manufacturer    <span class="dv">5195</span> non<span class="op">-</span>null <span class="bu">object</span></span>
<span id="cb75-28"><a href="#cb75-28"></a>dtypes: int64(<span class="dv">1</span>), <span class="bu">object</span>(<span class="dv">3</span>)</span>
<span id="cb75-29"><a href="#cb75-29"></a>memory usage: <span class="fl">207.5</span><span class="op">+</span> KB</span></code></pre></div>
<p>通过value_counts，你可以查看食物类别的分布情况：</p>
<div class="sourceCode" id="cb76"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb76-1"><a href="#cb76-1"></a>In [<span class="dv">165</span>]: pd.value_counts(info.group)[:<span class="dv">10</span>]</span>
<span id="cb76-2"><a href="#cb76-2"></a>Out[<span class="dv">165</span>]: </span>
<span id="cb76-3"><a href="#cb76-3"></a>Vegetables <span class="kw">and</span> Vegetable Products    <span class="dv">812</span></span>
<span id="cb76-4"><a href="#cb76-4"></a>Beef Products                        <span class="dv">618</span></span>
<span id="cb76-5"><a href="#cb76-5"></a>Baked Products                       <span class="dv">496</span></span>
<span id="cb76-6"><a href="#cb76-6"></a>Breakfast Cereals                    <span class="dv">403</span></span>
<span id="cb76-7"><a href="#cb76-7"></a>Fast Foods                           <span class="dv">365</span></span>
<span id="cb76-8"><a href="#cb76-8"></a>Legumes <span class="kw">and</span> Legume Products          <span class="dv">365</span></span>
<span id="cb76-9"><a href="#cb76-9"></a>Lamb, Veal, <span class="kw">and</span> Game Products        <span class="dv">345</span></span>
<span id="cb76-10"><a href="#cb76-10"></a>Sweets                               <span class="dv">341</span></span>
<span id="cb76-11"><a href="#cb76-11"></a>Pork Products                        <span class="dv">328</span></span>
<span id="cb76-12"><a href="#cb76-12"></a>Fruits <span class="kw">and</span> Fruit Juices              <span class="dv">328</span></span>
<span id="cb76-13"><a href="#cb76-13"></a>Name: group, dtype: int64</span></code></pre></div>
<p>现在，为了对全部营养数据做一些分析，最简单的办法是将所有食物的营养成分整合到一个大表中。我们分几个步骤来实现该目的。首先，将各食物的营养成分列表转换为一个DataFrame，并添加一个表示编号的列，然后将该DataFrame添加到一个列表中。最后通过concat将这些东西连接起来就可以了：</p>
<p>顺利的话，nutrients的结果是：</p>
<div class="sourceCode" id="cb77"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb77-1"><a href="#cb77-1"></a>In [<span class="dv">167</span>]: nutrients</span>
<span id="cb77-2"><a href="#cb77-2"></a>Out[<span class="dv">167</span>]: </span>
<span id="cb77-3"><a href="#cb77-3"></a>                               description        group units    value     <span class="bu">id</span></span>
<span id="cb77-4"><a href="#cb77-4"></a><span class="dv">0</span>                                  Protein  Composition     g   <span class="fl">25.180</span>   <span class="dv">1008</span></span>
<span id="cb77-5"><a href="#cb77-5"></a><span class="dv">1</span>                        Total lipid (fat)  Composition     g   <span class="fl">29.200</span>   <span class="dv">1008</span></span>
<span id="cb77-6"><a href="#cb77-6"></a><span class="dv">2</span>              Carbohydrate, by difference  Composition     g    <span class="fl">3.060</span>   <span class="dv">1008</span></span>
<span id="cb77-7"><a href="#cb77-7"></a><span class="dv">3</span>                                      Ash        Other     g    <span class="fl">3.280</span>   <span class="dv">1008</span></span>
<span id="cb77-8"><a href="#cb77-8"></a><span class="dv">4</span>                                   Energy       Energy  kcal  <span class="fl">376.000</span>   <span class="dv">1008</span></span>
<span id="cb77-9"><a href="#cb77-9"></a>...                                    ...          ...</span>
<span id="cb77-10"><a href="#cb77-10"></a>...      ...    ...</span>
<span id="cb77-11"><a href="#cb77-11"></a><span class="dv">389350</span>                 Vitamin B<span class="op">-</span><span class="dv">12</span>, added     Vitamins   mcg    <span class="fl">0.000</span>  <span class="dv">43546</span></span>
<span id="cb77-12"><a href="#cb77-12"></a><span class="dv">389351</span>                         Cholesterol        Other    mg    <span class="fl">0.000</span>  <span class="dv">43546</span></span>
<span id="cb77-13"><a href="#cb77-13"></a><span class="dv">389352</span>        Fatty acids, total saturated        Other     g    <span class="fl">0.072</span>  <span class="dv">43546</span></span>
<span id="cb77-14"><a href="#cb77-14"></a><span class="dv">389353</span>  Fatty acids, total monounsaturated        Other     g    <span class="fl">0.028</span>  <span class="dv">43546</span></span>
<span id="cb77-15"><a href="#cb77-15"></a><span class="dv">389354</span>  Fatty acids, total polyunsaturated        Other     g    <span class="fl">0.041</span>  <span class="dv">43546</span></span>
<span id="cb77-16"><a href="#cb77-16"></a>[<span class="dv">389355</span> rows x <span class="dv">5</span> columns]</span></code></pre></div>
<p>我发现这个DataFrame中无论如何都会有一些重复项，所以直接丢弃就可以了：</p>
<div class="sourceCode" id="cb78"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb78-1"><a href="#cb78-1"></a>In [<span class="dv">168</span>]: nutrients.duplicated().<span class="bu">sum</span>()  <span class="co"># number of duplicates</span></span>
<span id="cb78-2"><a href="#cb78-2"></a>Out[<span class="dv">168</span>]: <span class="dv">14179</span></span>
<span id="cb78-3"><a href="#cb78-3"></a></span>
<span id="cb78-4"><a href="#cb78-4"></a>In [<span class="dv">169</span>]: nutrients <span class="op">=</span> nutrients.drop_duplicates()</span></code></pre></div>
<p>由于两个DataFrame对象中都有“group”和“description”，所以为了明确到底谁是谁，我们需要对它们进行重命名：</p>
<div class="sourceCode" id="cb79"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb79-1"><a href="#cb79-1"></a>In [<span class="dv">170</span>]: col_mapping <span class="op">=</span> {<span class="st">&#39;description&#39;</span> : <span class="st">&#39;food&#39;</span>,</span>
<span id="cb79-2"><a href="#cb79-2"></a>   .....:                <span class="st">&#39;group&#39;</span>       : <span class="st">&#39;fgroup&#39;</span>}</span>
<span id="cb79-3"><a href="#cb79-3"></a></span>
<span id="cb79-4"><a href="#cb79-4"></a>In [<span class="dv">171</span>]: info <span class="op">=</span> info.rename(columns<span class="op">=</span>col_mapping, copy<span class="op">=</span><span class="va">False</span>)</span>
<span id="cb79-5"><a href="#cb79-5"></a></span>
<span id="cb79-6"><a href="#cb79-6"></a>In [<span class="dv">172</span>]: info.info()</span>
<span id="cb79-7"><a href="#cb79-7"></a><span class="op">&lt;</span><span class="kw">class</span> <span class="st">&#39;pandas.core.frame.DataFrame&#39;</span><span class="op">&gt;</span></span>
<span id="cb79-8"><a href="#cb79-8"></a>RangeIndex: <span class="dv">6636</span> entries, <span class="dv">0</span> to <span class="dv">6635</span></span>
<span id="cb79-9"><a href="#cb79-9"></a>Data columns (total <span class="dv">4</span> columns):</span>
<span id="cb79-10"><a href="#cb79-10"></a>food            <span class="dv">6636</span> non<span class="op">-</span>null <span class="bu">object</span></span>
<span id="cb79-11"><a href="#cb79-11"></a>fgroup          <span class="dv">6636</span> non<span class="op">-</span>null <span class="bu">object</span></span>
<span id="cb79-12"><a href="#cb79-12"></a><span class="bu">id</span>              <span class="dv">6636</span> non<span class="op">-</span>null int64</span>
<span id="cb79-13"><a href="#cb79-13"></a>manufacturer    <span class="dv">5195</span> non<span class="op">-</span>null <span class="bu">object</span></span>
<span id="cb79-14"><a href="#cb79-14"></a>dtypes: int64(<span class="dv">1</span>), <span class="bu">object</span>(<span class="dv">3</span>)</span>
<span id="cb79-15"><a href="#cb79-15"></a>memory usage: <span class="fl">207.5</span><span class="op">+</span> KB</span>
<span id="cb79-16"><a href="#cb79-16"></a></span>
<span id="cb79-17"><a href="#cb79-17"></a>In [<span class="dv">173</span>]: col_mapping <span class="op">=</span> {<span class="st">&#39;description&#39;</span> : <span class="st">&#39;nutrient&#39;</span>,</span>
<span id="cb79-18"><a href="#cb79-18"></a>   .....:                <span class="st">&#39;group&#39;</span> : <span class="st">&#39;nutgroup&#39;</span>}</span>
<span id="cb79-19"><a href="#cb79-19"></a>In [<span class="dv">174</span>]: nutrients <span class="op">=</span> nutrients.rename(columns<span class="op">=</span>col_mapping, copy<span class="op">=</span><span class="va">False</span>)</span>
<span id="cb79-20"><a href="#cb79-20"></a></span>
<span id="cb79-21"><a href="#cb79-21"></a>In [<span class="dv">175</span>]: nutrients</span>
<span id="cb79-22"><a href="#cb79-22"></a>Out[<span class="dv">175</span>]: </span>
<span id="cb79-23"><a href="#cb79-23"></a>                                  nutrient     nutgroup units    value     <span class="bu">id</span></span>
<span id="cb79-24"><a href="#cb79-24"></a><span class="dv">0</span>                                  Protein  Composition     g   <span class="fl">25.180</span>   <span class="dv">1008</span></span>
<span id="cb79-25"><a href="#cb79-25"></a><span class="dv">1</span>                        Total lipid (fat)  Composition     g   <span class="fl">29.200</span>   <span class="dv">1008</span></span>
<span id="cb79-26"><a href="#cb79-26"></a><span class="dv">2</span>              Carbohydrate, by difference  Composition     g    <span class="fl">3.060</span>   <span class="dv">1008</span></span>
<span id="cb79-27"><a href="#cb79-27"></a><span class="dv">3</span>                                      Ash        Other     g    <span class="fl">3.280</span>   <span class="dv">1008</span></span>
<span id="cb79-28"><a href="#cb79-28"></a><span class="dv">4</span>                                   Energy       Energy  kcal  <span class="fl">376.000</span>   <span class="dv">1008</span></span>
<span id="cb79-29"><a href="#cb79-29"></a>...                                    ...          ...   ...      ...    ...</span>
<span id="cb79-30"><a href="#cb79-30"></a><span class="dv">389350</span>                 Vitamin B<span class="op">-</span><span class="dv">12</span>, added     Vitamins   mcg    <span class="fl">0.000</span>  <span class="dv">43546</span></span>
<span id="cb79-31"><a href="#cb79-31"></a><span class="dv">389351</span>                         Cholesterol        Other    mg    <span class="fl">0.000</span>  <span class="dv">43546</span></span>
<span id="cb79-32"><a href="#cb79-32"></a><span class="dv">389352</span>        Fatty acids, total saturated        Other     g    <span class="fl">0.072</span>  <span class="dv">43546</span></span>
<span id="cb79-33"><a href="#cb79-33"></a><span class="dv">389353</span>  Fatty acids, total monounsaturated        Other     g    <span class="fl">0.028</span>  <span class="dv">43546</span></span>
<span id="cb79-34"><a href="#cb79-34"></a><span class="dv">389354</span>  Fatty acids, total polyunsaturated        Other     g    <span class="fl">0.041</span>  <span class="dv">43546</span></span>
<span id="cb79-35"><a href="#cb79-35"></a>[<span class="dv">375176</span> rows x <span class="dv">5</span> columns]</span></code></pre></div>
<p>做完这些，就可以将info跟nutrients合并起来：</p>
<div class="sourceCode" id="cb80"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb80-1"><a href="#cb80-1"></a>In [<span class="dv">176</span>]: ndata <span class="op">=</span> pd.merge(nutrients, info, on<span class="op">=</span><span class="st">&#39;id&#39;</span>, how<span class="op">=</span><span class="st">&#39;outer&#39;</span>)</span>
<span id="cb80-2"><a href="#cb80-2"></a></span>
<span id="cb80-3"><a href="#cb80-3"></a>In [<span class="dv">177</span>]: ndata.info()</span>
<span id="cb80-4"><a href="#cb80-4"></a><span class="op">&lt;</span><span class="kw">class</span> <span class="st">&#39;pandas.core.frame.DataFrame&#39;</span><span class="op">&gt;</span></span>
<span id="cb80-5"><a href="#cb80-5"></a>Int64Index: <span class="dv">375176</span> entries, <span class="dv">0</span> to <span class="dv">375175</span></span>
<span id="cb80-6"><a href="#cb80-6"></a>Data columns (total <span class="dv">8</span> columns):</span>
<span id="cb80-7"><a href="#cb80-7"></a>nutrient        <span class="dv">375176</span> non<span class="op">-</span>null <span class="bu">object</span></span>
<span id="cb80-8"><a href="#cb80-8"></a>nutgroup        <span class="dv">375176</span> non<span class="op">-</span>null <span class="bu">object</span></span>
<span id="cb80-9"><a href="#cb80-9"></a>units           <span class="dv">375176</span> non<span class="op">-</span>null <span class="bu">object</span></span>
<span id="cb80-10"><a href="#cb80-10"></a>value           <span class="dv">375176</span> non<span class="op">-</span>null float64</span>
<span id="cb80-11"><a href="#cb80-11"></a><span class="bu">id</span>              <span class="dv">375176</span> non<span class="op">-</span>null int64</span>
<span id="cb80-12"><a href="#cb80-12"></a>food            <span class="dv">375176</span> non<span class="op">-</span>null <span class="bu">object</span></span>
<span id="cb80-13"><a href="#cb80-13"></a>fgroup          <span class="dv">375176</span> non<span class="op">-</span>null <span class="bu">object</span></span>
<span id="cb80-14"><a href="#cb80-14"></a>manufacturer    <span class="dv">293054</span> non<span class="op">-</span>null <span class="bu">object</span></span>
<span id="cb80-15"><a href="#cb80-15"></a>dtypes: float64(<span class="dv">1</span>), int64(<span class="dv">1</span>), <span class="bu">object</span>(<span class="dv">6</span>)</span>
<span id="cb80-16"><a href="#cb80-16"></a>memory usage: <span class="fl">25.8</span><span class="op">+</span> MB</span>
<span id="cb80-17"><a href="#cb80-17"></a></span>
<span id="cb80-18"><a href="#cb80-18"></a>In [<span class="dv">178</span>]: ndata.iloc[<span class="dv">30000</span>]</span>
<span id="cb80-19"><a href="#cb80-19"></a>Out[<span class="dv">178</span>]: </span>
<span id="cb80-20"><a href="#cb80-20"></a>nutrient                                       Glycine</span>
<span id="cb80-21"><a href="#cb80-21"></a>nutgroup                                   Amino Acids</span>
<span id="cb80-22"><a href="#cb80-22"></a>units                                                g</span>
<span id="cb80-23"><a href="#cb80-23"></a>value                                             <span class="fl">0.04</span></span>
<span id="cb80-24"><a href="#cb80-24"></a><span class="bu">id</span>                                                <span class="dv">6158</span></span>
<span id="cb80-25"><a href="#cb80-25"></a>food            Soup, tomato bisque, canned, condensed</span>
<span id="cb80-26"><a href="#cb80-26"></a>fgroup                      Soups, Sauces, <span class="kw">and</span> Gravies</span>
<span id="cb80-27"><a href="#cb80-27"></a>manufacturer                                          </span>
<span id="cb80-28"><a href="#cb80-28"></a>Name: <span class="dv">30000</span>, dtype: <span class="bu">object</span></span></code></pre></div>
<p>我们现在可以根据食物分类和营养类型画出一张中位值图（如图14-11所示）：</p>
<div class="sourceCode" id="cb81"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb81-1"><a href="#cb81-1"></a>In [<span class="dv">180</span>]: result <span class="op">=</span> ndata.groupby([<span class="st">&#39;nutrient&#39;</span>, <span class="st">&#39;fgroup&#39;</span>])[<span class="st">&#39;value&#39;</span>].quantile(<span class="fl">0.5</span>)</span>
<span id="cb81-2"><a href="#cb81-2"></a></span>
<span id="cb81-3"><a href="#cb81-3"></a>In [<span class="dv">181</span>]: result[<span class="st">&#39;Zinc, Zn&#39;</span>].sort_values().plot(kind<span class="op">=</span><span class="st">&#39;barh&#39;</span>)</span></code></pre></div>
<figure>
<img src="http://upload-images.jianshu.io/upload_images/7178691-99b176d022a444c0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="" /><figcaption>图片14-11 根据营养分类得出的锌中位值</figcaption>
</figure>
<p>只要稍微动一动脑子，就可以发现各营养成分最为丰富的食物是什么了：</p>
<div class="sourceCode" id="cb82"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb82-1"><a href="#cb82-1"></a>by_nutrient <span class="op">=</span> ndata.groupby([<span class="st">&#39;nutgroup&#39;</span>, <span class="st">&#39;nutrient&#39;</span>])</span>
<span id="cb82-2"><a href="#cb82-2"></a></span>
<span id="cb82-3"><a href="#cb82-3"></a>get_maximum <span class="op">=</span> <span class="kw">lambda</span> x: x.loc[x.value.idxmax()]</span>
<span id="cb82-4"><a href="#cb82-4"></a>get_minimum <span class="op">=</span> <span class="kw">lambda</span> x: x.loc[x.value.idxmin()]</span>
<span id="cb82-5"><a href="#cb82-5"></a></span>
<span id="cb82-6"><a href="#cb82-6"></a>max_foods <span class="op">=</span> by_nutrient.<span class="bu">apply</span>(get_maximum)[[<span class="st">&#39;value&#39;</span>, <span class="st">&#39;food&#39;</span>]]</span>
<span id="cb82-7"><a href="#cb82-7"></a></span>
<span id="cb82-8"><a href="#cb82-8"></a><span class="co"># make the food a little smaller</span></span>
<span id="cb82-9"><a href="#cb82-9"></a>max_foods.food <span class="op">=</span> max_foods.food.<span class="bu">str</span>[:<span class="dv">50</span>]</span></code></pre></div>
<p>由于得到的DataFrame很大，所以不方便在书里面全部打印出来。这里只给出“Amino Acids”营养分组：</p>
<div class="sourceCode" id="cb83"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb83-1"><a href="#cb83-1"></a>In [<span class="dv">183</span>]: max_foods.loc[<span class="st">&#39;Amino Acids&#39;</span>][<span class="st">&#39;food&#39;</span>]</span>
<span id="cb83-2"><a href="#cb83-2"></a>Out[<span class="dv">183</span>]: </span>
<span id="cb83-3"><a href="#cb83-3"></a>nutrient</span>
<span id="cb83-4"><a href="#cb83-4"></a>Alanine                          Gelatins, dry powder, unsweetened</span>
<span id="cb83-5"><a href="#cb83-5"></a>Arginine                              Seeds, sesame flour, low<span class="op">-</span>fat</span>
<span id="cb83-6"><a href="#cb83-6"></a>Aspartic acid                                  Soy protein isolate</span>
<span id="cb83-7"><a href="#cb83-7"></a>Cystine               Seeds, cottonseed flour, low fat (glandless)</span>
<span id="cb83-8"><a href="#cb83-8"></a>Glutamic acid                                  Soy protein isolate</span>
<span id="cb83-9"><a href="#cb83-9"></a>                                       ...                        </span>
<span id="cb83-10"><a href="#cb83-10"></a>Serine           Soy protein isolate, PROTEIN TECHNOLOGIES INTE...</span>
<span id="cb83-11"><a href="#cb83-11"></a>Threonine        Soy protein isolate, PROTEIN TECHNOLOGIES INTE...</span>
<span id="cb83-12"><a href="#cb83-12"></a>Tryptophan        Sea lion, Steller, meat <span class="cf">with</span> fat (Alaska Native)</span>
<span id="cb83-13"><a href="#cb83-13"></a>Tyrosine         Soy protein isolate, PROTEIN TECHNOLOGIES INTE...</span>
<span id="cb83-14"><a href="#cb83-14"></a>Valine           Soy protein isolate, PROTEIN TECHNOLOGIES INTE...</span>
<span id="cb83-15"><a href="#cb83-15"></a>Name: food, Length: <span class="dv">19</span>, dtype: <span class="bu">object</span></span></code></pre></div>
<h1 id="联邦选举委员会数据库">14.5 2012联邦选举委员会数据库</h1>
<p>美国联邦选举委员会发布了有关政治竞选赞助方面的数据。其中包括赞助者的姓名、职业、雇主、地址以及出资额等信息。我们对2012年美国总统大选的数据集比较感兴趣（http://www.fec.gov/disclosurep/PDownload.do）。我在2012年6月下载的数据集是一个150MB的CSV文件（P00000001-ALL.csv），我们先用pandas.read_csv将其加载进来：</p>
<div class="sourceCode" id="cb84"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb84-1"><a href="#cb84-1"></a>In [<span class="dv">184</span>]: fec <span class="op">=</span> pd.read_csv(<span class="st">&#39;datasets/fec/P00000001-ALL.csv&#39;</span>)</span>
<span id="cb84-2"><a href="#cb84-2"></a></span>
<span id="cb84-3"><a href="#cb84-3"></a>In [<span class="dv">185</span>]: fec.info()</span>
<span id="cb84-4"><a href="#cb84-4"></a><span class="op">&lt;</span><span class="kw">class</span> <span class="st">&#39;pandas.core.frame.DataFrame&#39;</span><span class="op">&gt;</span></span>
<span id="cb84-5"><a href="#cb84-5"></a>RangeIndex: <span class="dv">1001731</span> entries, <span class="dv">0</span> to <span class="dv">1001730</span></span>
<span id="cb84-6"><a href="#cb84-6"></a>Data columns (total <span class="dv">16</span> columns):</span>
<span id="cb84-7"><a href="#cb84-7"></a>cmte_id              <span class="dv">1001731</span> non<span class="op">-</span>null <span class="bu">object</span></span>
<span id="cb84-8"><a href="#cb84-8"></a>cand_id              <span class="dv">1001731</span> non<span class="op">-</span>null <span class="bu">object</span></span>
<span id="cb84-9"><a href="#cb84-9"></a>cand_nm              <span class="dv">1001731</span> non<span class="op">-</span>null <span class="bu">object</span></span>
<span id="cb84-10"><a href="#cb84-10"></a>contbr_nm            <span class="dv">1001731</span> non<span class="op">-</span>null <span class="bu">object</span></span>
<span id="cb84-11"><a href="#cb84-11"></a>contbr_city          <span class="dv">1001712</span> non<span class="op">-</span>null <span class="bu">object</span></span>
<span id="cb84-12"><a href="#cb84-12"></a>contbr_st            <span class="dv">1001727</span> non<span class="op">-</span>null <span class="bu">object</span></span>
<span id="cb84-13"><a href="#cb84-13"></a>contbr_zip           <span class="dv">1001620</span> non<span class="op">-</span>null <span class="bu">object</span></span>
<span id="cb84-14"><a href="#cb84-14"></a>contbr_employer      <span class="dv">988002</span> non<span class="op">-</span>null <span class="bu">object</span></span>
<span id="cb84-15"><a href="#cb84-15"></a>contbr_occupation    <span class="dv">993301</span> non<span class="op">-</span>null <span class="bu">object</span></span>
<span id="cb84-16"><a href="#cb84-16"></a>contb_receipt_amt    <span class="dv">1001731</span> non<span class="op">-</span>null float64</span>
<span id="cb84-17"><a href="#cb84-17"></a>contb_receipt_dt     <span class="dv">1001731</span> non<span class="op">-</span>null <span class="bu">object</span></span>
<span id="cb84-18"><a href="#cb84-18"></a>receipt_desc         <span class="dv">14166</span> non<span class="op">-</span>null <span class="bu">object</span></span>
<span id="cb84-19"><a href="#cb84-19"></a>memo_cd              <span class="dv">92482</span> non<span class="op">-</span>null <span class="bu">object</span></span>
<span id="cb84-20"><a href="#cb84-20"></a>memo_text            <span class="dv">97770</span> non<span class="op">-</span>null <span class="bu">object</span></span>
<span id="cb84-21"><a href="#cb84-21"></a>form_tp              <span class="dv">1001731</span> non<span class="op">-</span>null <span class="bu">object</span></span>
<span id="cb84-22"><a href="#cb84-22"></a>file_num             <span class="dv">1001731</span> non<span class="op">-</span>null int64</span>
<span id="cb84-23"><a href="#cb84-23"></a>dtypes: float64(<span class="dv">1</span>), int64(<span class="dv">1</span>), <span class="bu">object</span>(<span class="dv">14</span>)</span>
<span id="cb84-24"><a href="#cb84-24"></a>memory usage: <span class="fl">122.3</span><span class="op">+</span> MB</span></code></pre></div>
<p>该DataFrame中的记录如下所示：</p>
<div class="sourceCode" id="cb85"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb85-1"><a href="#cb85-1"></a>In [<span class="dv">186</span>]: fec.iloc[<span class="dv">123456</span>]</span>
<span id="cb85-2"><a href="#cb85-2"></a>Out[<span class="dv">186</span>]: </span>
<span id="cb85-3"><a href="#cb85-3"></a>cmte_id             C00431445</span>
<span id="cb85-4"><a href="#cb85-4"></a>cand_id             P80003338</span>
<span id="cb85-5"><a href="#cb85-5"></a>cand_nm         Obama, Barack</span>
<span id="cb85-6"><a href="#cb85-6"></a>contbr_nm         ELLMAN, IRA</span>
<span id="cb85-7"><a href="#cb85-7"></a>contbr_city             TEMPE</span>
<span id="cb85-8"><a href="#cb85-8"></a>                    ...      </span>
<span id="cb85-9"><a href="#cb85-9"></a>receipt_desc              NaN</span>
<span id="cb85-10"><a href="#cb85-10"></a>memo_cd                   NaN</span>
<span id="cb85-11"><a href="#cb85-11"></a>memo_text                 NaN</span>
<span id="cb85-12"><a href="#cb85-12"></a>form_tp                 SA17A</span>
<span id="cb85-13"><a href="#cb85-13"></a>file_num               <span class="dv">772372</span></span>
<span id="cb85-14"><a href="#cb85-14"></a>Name: <span class="dv">123456</span>, Length: <span class="dv">16</span>, dtype: <span class="bu">object</span></span></code></pre></div>
<p>你可能已经想出了许多办法从这些竞选赞助数据中抽取有关赞助人和赞助模式的统计信息。我将在接下来的内容中介绍几种不同的分析工作（运用到目前为止已经学到的方法）。</p>
<p>不难看出，该数据中没有党派信息，因此最好把它加进去。通过unique，你可以获取全部的候选人名单：</p>
<div class="sourceCode" id="cb86"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb86-1"><a href="#cb86-1"></a>In [<span class="dv">187</span>]: unique_cands <span class="op">=</span> fec.cand_nm.unique()</span>
<span id="cb86-2"><a href="#cb86-2"></a></span>
<span id="cb86-3"><a href="#cb86-3"></a>In [<span class="dv">188</span>]: unique_cands</span>
<span id="cb86-4"><a href="#cb86-4"></a>Out[<span class="dv">188</span>]: </span>
<span id="cb86-5"><a href="#cb86-5"></a>array([<span class="st">&#39;Bachmann, Michelle&#39;</span>, <span class="st">&#39;Romney, Mitt&#39;</span>, <span class="st">&#39;Obama, Barack&#39;</span>,</span>
<span id="cb86-6"><a href="#cb86-6"></a>       <span class="st">&quot;Roemer, Charles E. &#39;Buddy&#39; III&quot;</span>, <span class="st">&#39;Pawlenty, Timothy&#39;</span>,</span>
<span id="cb86-7"><a href="#cb86-7"></a>       <span class="st">&#39;Johnson, Gary Earl&#39;</span>, <span class="st">&#39;Paul, Ron&#39;</span>, <span class="st">&#39;Santorum, Rick&#39;</span>, <span class="st">&#39;Cain, Herman&#39;</span>,</span>
<span id="cb86-8"><a href="#cb86-8"></a>       <span class="st">&#39;Gingrich, Newt&#39;</span>, <span class="st">&#39;McCotter, Thaddeus G&#39;</span>, <span class="st">&#39;Huntsman, Jon&#39;</span>,</span>
<span id="cb86-9"><a href="#cb86-9"></a>       <span class="st">&#39;Perry, Rick&#39;</span>], dtype<span class="op">=</span><span class="bu">object</span>)</span>
<span id="cb86-10"><a href="#cb86-10"></a></span>
<span id="cb86-11"><a href="#cb86-11"></a>In [<span class="dv">189</span>]: unique_cands[<span class="dv">2</span>]</span>
<span id="cb86-12"><a href="#cb86-12"></a>Out[<span class="dv">189</span>]: <span class="st">&#39;Obama, Barack&#39;</span></span></code></pre></div>
<p>指明党派信息的方法之一是使用字典：</p>
<div class="sourceCode" id="cb87"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb87-1"><a href="#cb87-1"></a>parties <span class="op">=</span> {<span class="st">&#39;Bachmann, Michelle&#39;</span>: <span class="st">&#39;Republican&#39;</span>,</span>
<span id="cb87-2"><a href="#cb87-2"></a>           <span class="st">&#39;Cain, Herman&#39;</span>: <span class="st">&#39;Republican&#39;</span>,</span>
<span id="cb87-3"><a href="#cb87-3"></a>           <span class="st">&#39;Gingrich, Newt&#39;</span>: <span class="st">&#39;Republican&#39;</span>,</span>
<span id="cb87-4"><a href="#cb87-4"></a>           <span class="st">&#39;Huntsman, Jon&#39;</span>: <span class="st">&#39;Republican&#39;</span>,</span>
<span id="cb87-5"><a href="#cb87-5"></a>           <span class="st">&#39;Johnson, Gary Earl&#39;</span>: <span class="st">&#39;Republican&#39;</span>,</span>
<span id="cb87-6"><a href="#cb87-6"></a>           <span class="st">&#39;McCotter, Thaddeus G&#39;</span>: <span class="st">&#39;Republican&#39;</span>,</span>
<span id="cb87-7"><a href="#cb87-7"></a>           <span class="st">&#39;Obama, Barack&#39;</span>: <span class="st">&#39;Democrat&#39;</span>,</span>
<span id="cb87-8"><a href="#cb87-8"></a>           <span class="st">&#39;Paul, Ron&#39;</span>: <span class="st">&#39;Republican&#39;</span>,</span>
<span id="cb87-9"><a href="#cb87-9"></a>           <span class="st">&#39;Pawlenty, Timothy&#39;</span>: <span class="st">&#39;Republican&#39;</span>,</span>
<span id="cb87-10"><a href="#cb87-10"></a>           <span class="st">&#39;Perry, Rick&#39;</span>: <span class="st">&#39;Republican&#39;</span>,</span>
<span id="cb87-11"><a href="#cb87-11"></a>           <span class="st">&quot;Roemer, Charles E. &#39;Buddy&#39; III&quot;</span>: <span class="st">&#39;Republican&#39;</span>,</span>
<span id="cb87-12"><a href="#cb87-12"></a>           <span class="st">&#39;Romney, Mitt&#39;</span>: <span class="st">&#39;Republican&#39;</span>,</span>
<span id="cb87-13"><a href="#cb87-13"></a>           <span class="st">&#39;Santorum, Rick&#39;</span>: <span class="st">&#39;Republican&#39;</span>}</span></code></pre></div>
<p>现在，通过这个映射以及Series对象的map方法，你可以根据候选人姓名得到一组党派信息：</p>
<div class="sourceCode" id="cb88"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb88-1"><a href="#cb88-1"></a>In [<span class="dv">191</span>]: fec.cand_nm[<span class="dv">123456</span>:<span class="dv">123461</span>]</span>
<span id="cb88-2"><a href="#cb88-2"></a>Out[<span class="dv">191</span>]: </span>
<span id="cb88-3"><a href="#cb88-3"></a><span class="dv">123456</span>    Obama, Barack</span>
<span id="cb88-4"><a href="#cb88-4"></a><span class="dv">123457</span>    Obama, Barack</span>
<span id="cb88-5"><a href="#cb88-5"></a><span class="dv">123458</span>    Obama, Barack</span>
<span id="cb88-6"><a href="#cb88-6"></a><span class="dv">123459</span>    Obama, Barack</span>
<span id="cb88-7"><a href="#cb88-7"></a><span class="dv">123460</span>    Obama, Barack</span>
<span id="cb88-8"><a href="#cb88-8"></a>Name: cand_nm, dtype: <span class="bu">object</span></span>
<span id="cb88-9"><a href="#cb88-9"></a></span>
<span id="cb88-10"><a href="#cb88-10"></a>In [<span class="dv">192</span>]: fec.cand_nm[<span class="dv">123456</span>:<span class="dv">123461</span>].<span class="bu">map</span>(parties)</span>
<span id="cb88-11"><a href="#cb88-11"></a>Out[<span class="dv">192</span>]: </span>
<span id="cb88-12"><a href="#cb88-12"></a><span class="dv">123456</span>    Democrat</span>
<span id="cb88-13"><a href="#cb88-13"></a><span class="dv">123457</span>    Democrat</span>
<span id="cb88-14"><a href="#cb88-14"></a><span class="dv">123458</span>    Democrat</span>
<span id="cb88-15"><a href="#cb88-15"></a><span class="dv">123459</span>    Democrat</span>
<span id="cb88-16"><a href="#cb88-16"></a><span class="dv">123460</span>    Democrat</span>
<span id="cb88-17"><a href="#cb88-17"></a>Name: cand_nm, dtype: <span class="bu">object</span></span>
<span id="cb88-18"><a href="#cb88-18"></a></span>
<span id="cb88-19"><a href="#cb88-19"></a><span class="co"># Add it as a column</span></span>
<span id="cb88-20"><a href="#cb88-20"></a>In [<span class="dv">193</span>]: fec[<span class="st">&#39;party&#39;</span>] <span class="op">=</span> fec.cand_nm.<span class="bu">map</span>(parties)</span>
<span id="cb88-21"><a href="#cb88-21"></a></span>
<span id="cb88-22"><a href="#cb88-22"></a>In [<span class="dv">194</span>]: fec[<span class="st">&#39;party&#39;</span>].value_counts()</span>
<span id="cb88-23"><a href="#cb88-23"></a>Out[<span class="dv">194</span>]: </span>
<span id="cb88-24"><a href="#cb88-24"></a>Democrat      <span class="dv">593746</span></span>
<span id="cb88-25"><a href="#cb88-25"></a>Republican    <span class="dv">407985</span></span>
<span id="cb88-26"><a href="#cb88-26"></a>Name: party, dtype: int64</span></code></pre></div>
<p>这里有两个需要注意的地方。第一，该数据既包括赞助也包括退款（负的出资额）：</p>
<div class="sourceCode" id="cb89"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb89-1"><a href="#cb89-1"></a>In [<span class="dv">195</span>]: (fec.contb_receipt_amt <span class="op">&gt;</span> <span class="dv">0</span>).value_counts()</span>
<span id="cb89-2"><a href="#cb89-2"></a>Out[<span class="dv">195</span>]: </span>
<span id="cb89-3"><a href="#cb89-3"></a><span class="va">True</span>     <span class="dv">991475</span></span>
<span id="cb89-4"><a href="#cb89-4"></a><span class="va">False</span>     <span class="dv">10256</span></span>
<span id="cb89-5"><a href="#cb89-5"></a>Name: contb_receipt_amt, dtype: int64</span></code></pre></div>
<p>为了简化分析过程，我限定该数据集只能有正的出资额：</p>
<div class="sourceCode" id="cb90"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb90-1"><a href="#cb90-1"></a>In [<span class="dv">196</span>]: fec <span class="op">=</span> fec[fec.contb_receipt_amt <span class="op">&gt;</span> <span class="dv">0</span>]</span></code></pre></div>
<p>由于Barack Obama和Mitt Romney是最主要的两名候选人，所以我还专门准备了一个子集，只包含针对他们两人的竞选活动的赞助信息：</p>
<div class="sourceCode" id="cb91"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb91-1"><a href="#cb91-1"></a>In [<span class="dv">197</span>]: fec_mrbo <span class="op">=</span> fec[fec.cand_nm.isin([<span class="st">&#39;Obama, Barack&#39;</span>,<span class="st">&#39;Romney, Mitt&#39;</span>])]</span></code></pre></div>
<h2 id="根据职业和雇主统计赞助信息">根据职业和雇主统计赞助信息</h2>
<p>基于职业的赞助信息统计是另一种经常被研究的统计任务。例如，律师们更倾向于资助民主党，而企业主则更倾向于资助共和党。你可以不相信我，自己看那些数据就知道了。首先，根据职业计算出资总额，这很简单：</p>
<div class="sourceCode" id="cb92"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb92-1"><a href="#cb92-1"></a>In [<span class="dv">198</span>]: fec.contbr_occupation.value_counts()[:<span class="dv">10</span>]</span>
<span id="cb92-2"><a href="#cb92-2"></a>Out[<span class="dv">198</span>]: </span>
<span id="cb92-3"><a href="#cb92-3"></a>RETIRED                                   <span class="dv">233990</span></span>
<span id="cb92-4"><a href="#cb92-4"></a>INFORMATION REQUESTED                      <span class="dv">35107</span></span>
<span id="cb92-5"><a href="#cb92-5"></a>ATTORNEY                                   <span class="dv">34286</span></span>
<span id="cb92-6"><a href="#cb92-6"></a>HOMEMAKER                                  <span class="dv">29931</span></span>
<span id="cb92-7"><a href="#cb92-7"></a>PHYSICIAN                                  <span class="dv">23432</span></span>
<span id="cb92-8"><a href="#cb92-8"></a>INFORMATION REQUESTED PER BEST EFFORTS     <span class="dv">21138</span></span>
<span id="cb92-9"><a href="#cb92-9"></a>ENGINEER                                   <span class="dv">14334</span></span>
<span id="cb92-10"><a href="#cb92-10"></a>TEACHER                                    <span class="dv">13990</span></span>
<span id="cb92-11"><a href="#cb92-11"></a>CONSULTANT                                 <span class="dv">13273</span></span>
<span id="cb92-12"><a href="#cb92-12"></a>PROFESSOR                                  <span class="dv">12555</span></span>
<span id="cb92-13"><a href="#cb92-13"></a>Name: contbr_occupation, dtype: int64</span></code></pre></div>
<p>不难看出，许多职业都涉及相同的基本工作类型，或者同一样东西有多种变体。下面的代码片段可以清理一些这样的数据（将一个职业信息映射到另一个）。注意，这里巧妙地利用了dict.get，它允许没有映射关系的职业也能“通过”：</p>
<div class="sourceCode" id="cb93"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb93-1"><a href="#cb93-1"></a>occ_mapping <span class="op">=</span> {</span>
<span id="cb93-2"><a href="#cb93-2"></a>   <span class="st">&#39;INFORMATION REQUESTED PER BEST EFFORTS&#39;</span> : <span class="st">&#39;NOT PROVIDED&#39;</span>,</span>
<span id="cb93-3"><a href="#cb93-3"></a>   <span class="st">&#39;INFORMATION REQUESTED&#39;</span> : <span class="st">&#39;NOT PROVIDED&#39;</span>,</span>
<span id="cb93-4"><a href="#cb93-4"></a>   <span class="st">&#39;INFORMATION REQUESTED (BEST EFFORTS)&#39;</span> : <span class="st">&#39;NOT PROVIDED&#39;</span>,</span>
<span id="cb93-5"><a href="#cb93-5"></a>   <span class="st">&#39;C.E.O.&#39;</span>: <span class="st">&#39;CEO&#39;</span></span>
<span id="cb93-6"><a href="#cb93-6"></a>}</span>
<span id="cb93-7"><a href="#cb93-7"></a></span>
<span id="cb93-8"><a href="#cb93-8"></a><span class="co"># If no mapping provided, return x</span></span>
<span id="cb93-9"><a href="#cb93-9"></a>f <span class="op">=</span> <span class="kw">lambda</span> x: occ_mapping.get(x, x)</span>
<span id="cb93-10"><a href="#cb93-10"></a>fec.contbr_occupation <span class="op">=</span> fec.contbr_occupation.<span class="bu">map</span>(f)</span></code></pre></div>
<p>我对雇主信息也进行了同样的处理：</p>
<div class="sourceCode" id="cb94"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb94-1"><a href="#cb94-1"></a>emp_mapping <span class="op">=</span> {</span>
<span id="cb94-2"><a href="#cb94-2"></a>   <span class="st">&#39;INFORMATION REQUESTED PER BEST EFFORTS&#39;</span> : <span class="st">&#39;NOT PROVIDED&#39;</span>,</span>
<span id="cb94-3"><a href="#cb94-3"></a>   <span class="st">&#39;INFORMATION REQUESTED&#39;</span> : <span class="st">&#39;NOT PROVIDED&#39;</span>,</span>
<span id="cb94-4"><a href="#cb94-4"></a>   <span class="st">&#39;SELF&#39;</span> : <span class="st">&#39;SELF-EMPLOYED&#39;</span>,</span>
<span id="cb94-5"><a href="#cb94-5"></a>   <span class="st">&#39;SELF EMPLOYED&#39;</span> : <span class="st">&#39;SELF-EMPLOYED&#39;</span>,</span>
<span id="cb94-6"><a href="#cb94-6"></a>}</span>
<span id="cb94-7"><a href="#cb94-7"></a></span>
<span id="cb94-8"><a href="#cb94-8"></a><span class="co"># If no mapping provided, return x</span></span>
<span id="cb94-9"><a href="#cb94-9"></a>f <span class="op">=</span> <span class="kw">lambda</span> x: emp_mapping.get(x, x)</span>
<span id="cb94-10"><a href="#cb94-10"></a>fec.contbr_employer <span class="op">=</span> fec.contbr_employer.<span class="bu">map</span>(f)</span></code></pre></div>
<p>现在，你可以通过pivot_table根据党派和职业对数据进行聚合，然后过滤掉总出资额不足200万美元的数据：</p>
<div class="sourceCode" id="cb95"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb95-1"><a href="#cb95-1"></a>In [<span class="dv">201</span>]: by_occupation <span class="op">=</span> fec.pivot_table(<span class="st">&#39;contb_receipt_amt&#39;</span>,</span>
<span id="cb95-2"><a href="#cb95-2"></a>   .....:                                 index<span class="op">=</span><span class="st">&#39;contbr_occupation&#39;</span>,</span>
<span id="cb95-3"><a href="#cb95-3"></a>   .....:                                 columns<span class="op">=</span><span class="st">&#39;party&#39;</span>, aggfunc<span class="op">=</span><span class="st">&#39;sum&#39;</span>)</span>
<span id="cb95-4"><a href="#cb95-4"></a></span>
<span id="cb95-5"><a href="#cb95-5"></a>In [<span class="dv">202</span>]: over_2mm <span class="op">=</span> by_occupation[by_occupation.<span class="bu">sum</span>(<span class="dv">1</span>) <span class="op">&gt;</span> <span class="dv">2000000</span>]</span>
<span id="cb95-6"><a href="#cb95-6"></a></span>
<span id="cb95-7"><a href="#cb95-7"></a>In [<span class="dv">203</span>]: over_2mm</span>
<span id="cb95-8"><a href="#cb95-8"></a>Out[<span class="dv">203</span>]: </span>
<span id="cb95-9"><a href="#cb95-9"></a>party                 Democrat    Republican</span>
<span id="cb95-10"><a href="#cb95-10"></a>contbr_occupation                           </span>
<span id="cb95-11"><a href="#cb95-11"></a>ATTORNEY           <span class="fl">11141982.97</span>  <span class="fl">7.477194e+06</span></span>
<span id="cb95-12"><a href="#cb95-12"></a>CEO                 <span class="fl">2074974.79</span>  <span class="fl">4.211041e+06</span></span>
<span id="cb95-13"><a href="#cb95-13"></a>CONSULTANT          <span class="fl">2459912.71</span>  <span class="fl">2.544725e+06</span></span>
<span id="cb95-14"><a href="#cb95-14"></a>ENGINEER             <span class="fl">951525.55</span>  <span class="fl">1.818374e+06</span></span>
<span id="cb95-15"><a href="#cb95-15"></a>EXECUTIVE           <span class="fl">1355161.05</span>  <span class="fl">4.138850e+06</span></span>
<span id="cb95-16"><a href="#cb95-16"></a>...                        ...           ...</span>
<span id="cb95-17"><a href="#cb95-17"></a>PRESIDENT           <span class="fl">1878509.95</span>  <span class="fl">4.720924e+06</span></span>
<span id="cb95-18"><a href="#cb95-18"></a>PROFESSOR           <span class="fl">2165071.08</span>  <span class="fl">2.967027e+05</span></span>
<span id="cb95-19"><a href="#cb95-19"></a>REAL ESTATE          <span class="fl">528902.09</span>  <span class="fl">1.625902e+06</span></span>
<span id="cb95-20"><a href="#cb95-20"></a>RETIRED            <span class="fl">25305116.38</span>  <span class="fl">2.356124e+07</span></span>
<span id="cb95-21"><a href="#cb95-21"></a>SELF<span class="op">-</span>EMPLOYED        <span class="fl">672393.40</span>  <span class="fl">1.640253e+06</span></span>
<span id="cb95-22"><a href="#cb95-22"></a>[<span class="dv">17</span> rows x <span class="dv">2</span> columns]</span></code></pre></div>
<p>把这些数据做成柱状图看起来会更加清楚（’barh’表示水平柱状图，如图14-12所示）：</p>
<div class="sourceCode" id="cb96"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb96-1"><a href="#cb96-1"></a>In [<span class="dv">205</span>]: over_2mm.plot(kind<span class="op">=</span><span class="st">&#39;barh&#39;</span>)</span></code></pre></div>
<figure>
<img src="http://upload-images.jianshu.io/upload_images/7178691-d2254e547c6ce537.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="" /><figcaption>图14-12 对各党派总出资额最高的职业</figcaption>
</figure>
<p>你可能还想了解一下对Obama和Romney总出资额最高的职业和企业。为此，我们先对候选人进行分组，然后使用本章前面介绍的类似top的方法：</p>
<div class="sourceCode" id="cb97"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb97-1"><a href="#cb97-1"></a><span class="kw">def</span> get_top_amounts(group, key, n<span class="op">=</span><span class="dv">5</span>):</span>
<span id="cb97-2"><a href="#cb97-2"></a>    totals <span class="op">=</span> group.groupby(key)[<span class="st">&#39;contb_receipt_amt&#39;</span>].<span class="bu">sum</span>()</span>
<span id="cb97-3"><a href="#cb97-3"></a>    <span class="cf">return</span> totals.nlargest(n)</span></code></pre></div>
<p>然后根据职业和雇主进行聚合：</p>
<div class="sourceCode" id="cb98"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb98-1"><a href="#cb98-1"></a>In [<span class="dv">207</span>]: grouped <span class="op">=</span> fec_mrbo.groupby(<span class="st">&#39;cand_nm&#39;</span>)</span>
<span id="cb98-2"><a href="#cb98-2"></a></span>
<span id="cb98-3"><a href="#cb98-3"></a>In [<span class="dv">208</span>]: grouped.<span class="bu">apply</span>(get_top_amounts, <span class="st">&#39;contbr_occupation&#39;</span>, n<span class="op">=</span><span class="dv">7</span>)</span>
<span id="cb98-4"><a href="#cb98-4"></a>Out[<span class="dv">208</span>]: </span>
<span id="cb98-5"><a href="#cb98-5"></a>cand_nm        contbr_occupation    </span>
<span id="cb98-6"><a href="#cb98-6"></a>Obama, Barack  RETIRED                  <span class="fl">25305116.38</span></span>
<span id="cb98-7"><a href="#cb98-7"></a>               ATTORNEY                 <span class="fl">11141982.97</span></span>
<span id="cb98-8"><a href="#cb98-8"></a>               INFORMATION REQUESTED     <span class="fl">4866973.96</span></span>
<span id="cb98-9"><a href="#cb98-9"></a>               HOMEMAKER                 <span class="fl">4248875.80</span></span>
<span id="cb98-10"><a href="#cb98-10"></a>               PHYSICIAN                 <span class="fl">3735124.94</span></span>
<span id="cb98-11"><a href="#cb98-11"></a>                                           ...     </span>
<span id="cb98-12"><a href="#cb98-12"></a>Romney, Mitt   HOMEMAKER                 <span class="fl">8147446.22</span></span>
<span id="cb98-13"><a href="#cb98-13"></a>               ATTORNEY                  <span class="fl">5364718.82</span></span>
<span id="cb98-14"><a href="#cb98-14"></a>               PRESIDENT                 <span class="fl">2491244.89</span></span>
<span id="cb98-15"><a href="#cb98-15"></a>               EXECUTIVE                 <span class="fl">2300947.03</span></span>
<span id="cb98-16"><a href="#cb98-16"></a>               C.E.O.                    <span class="fl">1968386.11</span></span>
<span id="cb98-17"><a href="#cb98-17"></a>Name: contb_receipt_amt, Length: <span class="dv">14</span>, dtype: float64</span>
<span id="cb98-18"><a href="#cb98-18"></a></span>
<span id="cb98-19"><a href="#cb98-19"></a>In [<span class="dv">209</span>]: grouped.<span class="bu">apply</span>(get_top_amounts, <span class="st">&#39;contbr_employer&#39;</span>, n<span class="op">=</span><span class="dv">10</span>)</span>
<span id="cb98-20"><a href="#cb98-20"></a>Out[<span class="dv">209</span>]: </span>
<span id="cb98-21"><a href="#cb98-21"></a>cand_nm        contbr_employer      </span>
<span id="cb98-22"><a href="#cb98-22"></a>Obama, Barack  RETIRED                  <span class="fl">22694358.85</span></span>
<span id="cb98-23"><a href="#cb98-23"></a>               SELF<span class="op">-</span>EMPLOYED            <span class="fl">17080985.96</span></span>
<span id="cb98-24"><a href="#cb98-24"></a>               NOT EMPLOYED              <span class="fl">8586308.70</span></span>
<span id="cb98-25"><a href="#cb98-25"></a>               INFORMATION REQUESTED     <span class="fl">5053480.37</span></span>
<span id="cb98-26"><a href="#cb98-26"></a>               HOMEMAKER                 <span class="fl">2605408.54</span></span>
<span id="cb98-27"><a href="#cb98-27"></a>                                           ...     </span>
<span id="cb98-28"><a href="#cb98-28"></a>Romney, Mitt   CREDIT SUISSE              <span class="fl">281150.00</span></span>
<span id="cb98-29"><a href="#cb98-29"></a>               MORGAN STANLEY             <span class="fl">267266.00</span></span>
<span id="cb98-30"><a href="#cb98-30"></a>               GOLDMAN SACH <span class="op">&amp;</span> CO.         <span class="fl">238250.00</span></span>
<span id="cb98-31"><a href="#cb98-31"></a>               BARCLAYS CAPITAL           <span class="fl">162750.00</span></span>
<span id="cb98-32"><a href="#cb98-32"></a>               H.I.G. CAPITAL             <span class="fl">139500.00</span></span>
<span id="cb98-33"><a href="#cb98-33"></a>Name: contb_receipt_amt, Length: <span class="dv">20</span>, dtype: float64</span></code></pre></div>
<h2 id="对出资额分组">对出资额分组</h2>
<p>还可以对该数据做另一种非常实用的分析：利用cut函数根据出资额的大小将数据离散化到多个面元中：</p>
<div class="sourceCode" id="cb99"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb99-1"><a href="#cb99-1"></a>In [<span class="dv">210</span>]: bins <span class="op">=</span> np.array([<span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">10</span>, <span class="dv">100</span>, <span class="dv">1000</span>, <span class="dv">10000</span>,</span>
<span id="cb99-2"><a href="#cb99-2"></a>   .....:                  <span class="dv">100000</span>, <span class="dv">1000000</span>, <span class="dv">10000000</span>])</span>
<span id="cb99-3"><a href="#cb99-3"></a></span>
<span id="cb99-4"><a href="#cb99-4"></a>In [<span class="dv">211</span>]: labels <span class="op">=</span> pd.cut(fec_mrbo.contb_receipt_amt, bins)</span>
<span id="cb99-5"><a href="#cb99-5"></a></span>
<span id="cb99-6"><a href="#cb99-6"></a>In [<span class="dv">212</span>]: labels</span>
<span id="cb99-7"><a href="#cb99-7"></a>Out[<span class="dv">212</span>]: </span>
<span id="cb99-8"><a href="#cb99-8"></a><span class="dv">411</span>         (<span class="dv">10</span>, <span class="dv">100</span>]</span>
<span id="cb99-9"><a href="#cb99-9"></a><span class="dv">412</span>       (<span class="dv">100</span>, <span class="dv">1000</span>]</span>
<span id="cb99-10"><a href="#cb99-10"></a><span class="dv">413</span>       (<span class="dv">100</span>, <span class="dv">1000</span>]</span>
<span id="cb99-11"><a href="#cb99-11"></a><span class="dv">414</span>         (<span class="dv">10</span>, <span class="dv">100</span>]</span>
<span id="cb99-12"><a href="#cb99-12"></a><span class="dv">415</span>         (<span class="dv">10</span>, <span class="dv">100</span>]</span>
<span id="cb99-13"><a href="#cb99-13"></a>             ...     </span>
<span id="cb99-14"><a href="#cb99-14"></a><span class="dv">701381</span>      (<span class="dv">10</span>, <span class="dv">100</span>]</span>
<span id="cb99-15"><a href="#cb99-15"></a><span class="dv">701382</span>    (<span class="dv">100</span>, <span class="dv">1000</span>]</span>
<span id="cb99-16"><a href="#cb99-16"></a><span class="dv">701383</span>        (<span class="dv">1</span>, <span class="dv">10</span>]</span>
<span id="cb99-17"><a href="#cb99-17"></a><span class="dv">701384</span>      (<span class="dv">10</span>, <span class="dv">100</span>]</span>
<span id="cb99-18"><a href="#cb99-18"></a><span class="dv">701385</span>    (<span class="dv">100</span>, <span class="dv">1000</span>]</span>
<span id="cb99-19"><a href="#cb99-19"></a>Name: contb_receipt_amt, Length: <span class="dv">694282</span>, dtype: category</span>
<span id="cb99-20"><a href="#cb99-20"></a>Categories (<span class="dv">8</span>, interval[int64]): [(<span class="dv">0</span>, <span class="dv">1</span>] <span class="op">&lt;</span> (<span class="dv">1</span>, <span class="dv">10</span>] <span class="op">&lt;</span> (<span class="dv">10</span>, <span class="dv">100</span>] <span class="op">&lt;</span> (<span class="dv">100</span>, <span class="dv">1000</span>] <span class="op">&lt;</span> (<span class="dv">1</span></span>
<span id="cb99-21"><a href="#cb99-21"></a><span class="dv">000</span>, <span class="dv">10000</span>] <span class="op">&lt;</span></span>
<span id="cb99-22"><a href="#cb99-22"></a>                                  (<span class="dv">10000</span>, <span class="dv">100000</span>] <span class="op">&lt;</span> (<span class="dv">100000</span>, <span class="dv">1000000</span>] <span class="op">&lt;</span> (<span class="dv">1000000</span>,</span>
<span id="cb99-23"><a href="#cb99-23"></a> <span class="dv">10000000</span>]]</span></code></pre></div>
<p>现在可以根据候选人姓名以及面元标签对奥巴马和罗姆尼数据进行分组，以得到一个柱状图：</p>
<div class="sourceCode" id="cb100"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb100-1"><a href="#cb100-1"></a>In [<span class="dv">213</span>]: grouped <span class="op">=</span> fec_mrbo.groupby([<span class="st">&#39;cand_nm&#39;</span>, labels])</span>
<span id="cb100-2"><a href="#cb100-2"></a></span>
<span id="cb100-3"><a href="#cb100-3"></a>In [<span class="dv">214</span>]: grouped.size().unstack(<span class="dv">0</span>)</span>
<span id="cb100-4"><a href="#cb100-4"></a>Out[<span class="dv">214</span>]: </span>
<span id="cb100-5"><a href="#cb100-5"></a>cand_nm              Obama, Barack  Romney, Mitt</span>
<span id="cb100-6"><a href="#cb100-6"></a>contb_receipt_amt                               </span>
<span id="cb100-7"><a href="#cb100-7"></a>(<span class="dv">0</span>, <span class="dv">1</span>]                       <span class="fl">493.0</span>          <span class="fl">77.0</span></span>
<span id="cb100-8"><a href="#cb100-8"></a>(<span class="dv">1</span>, <span class="dv">10</span>]                    <span class="fl">40070.0</span>        <span class="fl">3681.0</span></span>
<span id="cb100-9"><a href="#cb100-9"></a>(<span class="dv">10</span>, <span class="dv">100</span>]                 <span class="fl">372280.0</span>       <span class="fl">31853.0</span></span>
<span id="cb100-10"><a href="#cb100-10"></a>(<span class="dv">100</span>, <span class="dv">1000</span>]               <span class="fl">153991.0</span>       <span class="fl">43357.0</span></span>
<span id="cb100-11"><a href="#cb100-11"></a>(<span class="dv">1000</span>, <span class="dv">10000</span>]              <span class="fl">22284.0</span>       <span class="fl">26186.0</span></span>
<span id="cb100-12"><a href="#cb100-12"></a>(<span class="dv">10000</span>, <span class="dv">100000</span>]                <span class="fl">2.0</span>           <span class="fl">1.0</span></span>
<span id="cb100-13"><a href="#cb100-13"></a>(<span class="dv">100000</span>, <span class="dv">1000000</span>]              <span class="fl">3.0</span>           NaN</span>
<span id="cb100-14"><a href="#cb100-14"></a>(<span class="dv">1000000</span>, <span class="dv">10000000</span>]            <span class="fl">4.0</span>           NaN</span></code></pre></div>
<p>从这个数据中可以看出，在小额赞助方面，Obama获得的数量比Romney多得多。你还可以对出资额求和并在面元内规格化，以便图形化显示两位候选人各种赞助额度的比例（见图14-13）：</p>
<div class="sourceCode" id="cb101"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb101-1"><a href="#cb101-1"></a>In [<span class="dv">216</span>]: bucket_sums <span class="op">=</span> grouped.contb_receipt_amt.<span class="bu">sum</span>().unstack(<span class="dv">0</span>)</span>
<span id="cb101-2"><a href="#cb101-2"></a></span>
<span id="cb101-3"><a href="#cb101-3"></a>In [<span class="dv">217</span>]: normed_sums <span class="op">=</span> bucket_sums.div(bucket_sums.<span class="bu">sum</span>(axis<span class="op">=</span><span class="dv">1</span>), axis<span class="op">=</span><span class="dv">0</span>)</span>
<span id="cb101-4"><a href="#cb101-4"></a></span>
<span id="cb101-5"><a href="#cb101-5"></a>In [<span class="dv">218</span>]: normed_sums</span>
<span id="cb101-6"><a href="#cb101-6"></a>Out[<span class="dv">218</span>]: </span>
<span id="cb101-7"><a href="#cb101-7"></a>cand_nm              Obama, Barack  Romney, Mitt</span>
<span id="cb101-8"><a href="#cb101-8"></a>contb_receipt_amt                               </span>
<span id="cb101-9"><a href="#cb101-9"></a>(<span class="dv">0</span>, <span class="dv">1</span>]                    <span class="fl">0.805182</span>      <span class="fl">0.194818</span></span>
<span id="cb101-10"><a href="#cb101-10"></a>(<span class="dv">1</span>, <span class="dv">10</span>]                   <span class="fl">0.918767</span>      <span class="fl">0.081233</span></span>
<span id="cb101-11"><a href="#cb101-11"></a>(<span class="dv">10</span>, <span class="dv">100</span>]                 <span class="fl">0.910769</span>      <span class="fl">0.089231</span></span>
<span id="cb101-12"><a href="#cb101-12"></a>(<span class="dv">100</span>, <span class="dv">1000</span>]               <span class="fl">0.710176</span>      <span class="fl">0.289824</span></span>
<span id="cb101-13"><a href="#cb101-13"></a>(<span class="dv">1000</span>, <span class="dv">10000</span>]             <span class="fl">0.447326</span>      <span class="fl">0.552674</span></span>
<span id="cb101-14"><a href="#cb101-14"></a>(<span class="dv">10000</span>, <span class="dv">100000</span>]           <span class="fl">0.823120</span>      <span class="fl">0.176880</span></span>
<span id="cb101-15"><a href="#cb101-15"></a>(<span class="dv">100000</span>, <span class="dv">1000000</span>]         <span class="fl">1.000000</span>           NaN</span>
<span id="cb101-16"><a href="#cb101-16"></a>(<span class="dv">1000000</span>, <span class="dv">10000000</span>]       <span class="fl">1.000000</span>           NaN</span>
<span id="cb101-17"><a href="#cb101-17"></a></span>
<span id="cb101-18"><a href="#cb101-18"></a>In [<span class="dv">219</span>]: normed_sums[:<span class="op">-</span><span class="dv">2</span>].plot(kind<span class="op">=</span><span class="st">&#39;barh&#39;</span>)</span></code></pre></div>
<figure>
<img src="http://upload-images.jianshu.io/upload_images/7178691-77e8c8d3c784692b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="" /><figcaption>图14-13 两位候选人收到的各种捐赠额度的总额比例</figcaption>
</figure>
<p>我排除了两个最大的面元，因为这些不是由个人捐赠的。</p>
<p>还可以对该分析过程做许多的提炼和改进。比如说，可以根据赞助人的姓名和邮编对数据进行聚合，以便找出哪些人进行了多次小额捐款，哪些人又进行了一次或多次大额捐款。我强烈建议你下载这些数据并自己摸索一下。</p>
<h2 id="根据州统计赞助信息">根据州统计赞助信息</h2>
<p>根据候选人和州对数据进行聚合是常规操作：</p>
<div class="sourceCode" id="cb102"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb102-1"><a href="#cb102-1"></a>In [<span class="dv">220</span>]: grouped <span class="op">=</span> fec_mrbo.groupby([<span class="st">&#39;cand_nm&#39;</span>, <span class="st">&#39;contbr_st&#39;</span>])</span>
<span id="cb102-2"><a href="#cb102-2"></a></span>
<span id="cb102-3"><a href="#cb102-3"></a>In [<span class="dv">221</span>]: totals <span class="op">=</span> grouped.contb_receipt_amt.<span class="bu">sum</span>().unstack(<span class="dv">0</span>).fillna(<span class="dv">0</span>)</span>
<span id="cb102-4"><a href="#cb102-4"></a></span>
<span id="cb102-5"><a href="#cb102-5"></a>In [<span class="dv">222</span>]: totals <span class="op">=</span> totals[totals.<span class="bu">sum</span>(<span class="dv">1</span>) <span class="op">&gt;</span> <span class="dv">100000</span>]</span>
<span id="cb102-6"><a href="#cb102-6"></a></span>
<span id="cb102-7"><a href="#cb102-7"></a>In [<span class="dv">223</span>]: totals[:<span class="dv">10</span>]</span>
<span id="cb102-8"><a href="#cb102-8"></a>Out[<span class="dv">223</span>]: </span>
<span id="cb102-9"><a href="#cb102-9"></a>cand_nm    Obama, Barack  Romney, Mitt</span>
<span id="cb102-10"><a href="#cb102-10"></a>contbr_st                             </span>
<span id="cb102-11"><a href="#cb102-11"></a>AK             <span class="fl">281840.15</span>      <span class="fl">86204.24</span></span>
<span id="cb102-12"><a href="#cb102-12"></a>AL             <span class="fl">543123.48</span>     <span class="fl">527303.51</span></span>
<span id="cb102-13"><a href="#cb102-13"></a>AR             <span class="fl">359247.28</span>     <span class="fl">105556.00</span></span>
<span id="cb102-14"><a href="#cb102-14"></a>AZ            <span class="fl">1506476.98</span>    <span class="fl">1888436.23</span></span>
<span id="cb102-15"><a href="#cb102-15"></a>CA           <span class="fl">23824984.24</span>   <span class="fl">11237636.60</span></span>
<span id="cb102-16"><a href="#cb102-16"></a>CO            <span class="fl">2132429.49</span>    <span class="fl">1506714.12</span></span>
<span id="cb102-17"><a href="#cb102-17"></a>CT            <span class="fl">2068291.26</span>    <span class="fl">3499475.45</span></span>
<span id="cb102-18"><a href="#cb102-18"></a>DC            <span class="fl">4373538.80</span>    <span class="fl">1025137.50</span></span>
<span id="cb102-19"><a href="#cb102-19"></a>DE             <span class="fl">336669.14</span>      <span class="fl">82712.00</span></span>
<span id="cb102-20"><a href="#cb102-20"></a>FL            <span class="fl">7318178.58</span>    <span class="fl">8338458.81</span></span></code></pre></div>
<p>如果对各行除以总赞助额，就会得到各候选人在各州的总赞助额比例：</p>
<div class="sourceCode" id="cb103"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb103-1"><a href="#cb103-1"></a>In [<span class="dv">224</span>]: percent <span class="op">=</span> totals.div(totals.<span class="bu">sum</span>(<span class="dv">1</span>), axis<span class="op">=</span><span class="dv">0</span>)</span>
<span id="cb103-2"><a href="#cb103-2"></a></span>
<span id="cb103-3"><a href="#cb103-3"></a>In [<span class="dv">225</span>]: percent[:<span class="dv">10</span>]</span>
<span id="cb103-4"><a href="#cb103-4"></a>Out[<span class="dv">225</span>]: </span>
<span id="cb103-5"><a href="#cb103-5"></a>cand_nm    Obama, Barack  Romney, Mitt</span>
<span id="cb103-6"><a href="#cb103-6"></a>contbr_st                             </span>
<span id="cb103-7"><a href="#cb103-7"></a>AK              <span class="fl">0.765778</span>      <span class="fl">0.234222</span></span>
<span id="cb103-8"><a href="#cb103-8"></a>AL              <span class="fl">0.507390</span>      <span class="fl">0.492610</span></span>
<span id="cb103-9"><a href="#cb103-9"></a>AR              <span class="fl">0.772902</span>      <span class="fl">0.227098</span></span>
<span id="cb103-10"><a href="#cb103-10"></a>AZ              <span class="fl">0.443745</span>      <span class="fl">0.556255</span></span>
<span id="cb103-11"><a href="#cb103-11"></a>CA              <span class="fl">0.679498</span>      <span class="fl">0.320502</span></span>
<span id="cb103-12"><a href="#cb103-12"></a>CO              <span class="fl">0.585970</span>      <span class="fl">0.414030</span></span>
<span id="cb103-13"><a href="#cb103-13"></a>CT              <span class="fl">0.371476</span>      <span class="fl">0.628524</span></span>
<span id="cb103-14"><a href="#cb103-14"></a>DC              <span class="fl">0.810113</span>      <span class="fl">0.189887</span></span>
<span id="cb103-15"><a href="#cb103-15"></a>DE              <span class="fl">0.802776</span>      <span class="fl">0.197224</span></span>
<span id="cb103-16"><a href="#cb103-16"></a>FL              <span class="fl">0.467417</span>      <span class="fl">0.532583</span></span></code></pre></div>
<p>#14.6 总结</p>
<p>我们已经完成了正文的最后一章。附录中有一些额外的内容，可能对你有用。</p>
<p>本书第一版出版已经有5年了，Python已经成为了一个流行的、广泛使用的数据分析语言。你从本书中学到的方法，在相当长的一段时间都是可用的。我希望本书介绍的工具和库对你的工作有用。</p>
